(()=>{var __webpack_modules__={74:module=>{"use strict";eval("\n\nconst arrayMoveMutate = (array, from, to) => {\n\tconst startIndex = from < 0 ? array.length + from : from;\n\n\tif (startIndex >= 0 && startIndex < array.length) {\n\t\tconst endIndex = to < 0 ? array.length + to : to;\n\n\t\tconst [item] = array.splice(from, 1);\n\t\tarray.splice(endIndex, 0, item);\n\t}\n};\n\nconst arrayMove = (array, from, to) => {\n\tarray = [...array];\n\tarrayMoveMutate(array, from, to);\n\treturn array;\n};\n\nmodule.exports = arrayMove;\nmodule.exports.mutate = arrayMoveMutate;\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../../node_modules/array-move/index.js?")},984:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ../../../../gutenberg/src/blocks/ta-index/required-taxonomies.js\nvar required_taxonomies = __webpack_require__(366);\n// EXTERNAL MODULE: external "React"\nvar external_React_ = __webpack_require__(804);\nvar external_React_default = /*#__PURE__*/__webpack_require__.n(external_React_);\n;// CONCATENATED MODULE: external "lodash"\nconst external_lodash_namespaceObject = lodash;\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/TAEtiquetador/helpers.js\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\nvar _wp$data = wp.data,\n    useSelect = _wp$data.useSelect,\n    useDispatch = _wp$data.useDispatch,\n    registerGenericStore = _wp$data.registerGenericStore;\n/**\r\n*   Utilizes the etiquetador API to return suggested tags for an article.\r\n*   @return\r\n*   @property {string[]} tags                                                   The suggested tags\r\n*   @property {string[]} analizedText                                           The latest analized text\r\n*   @property {function} updateTags                                             Function that recieves text an amount, and sets the result state.\r\n*   @property {bool} fetching                                                   Indicates if the suggested tags are being fetched\r\n*   @property {bool} error                                                      Indicates if an error ocurred while fetching the suggested tags\r\n*/\n\nfunction useEtiquetador(props) {\n  var etiquetadorStates = useSelect(function (select) {\n    return select(\'ta-etiquetador\');\n  });\n  var result = etiquetadorStates.getResult();\n\n  var _useDispatch = useDispatch(\'ta-etiquetador\'),\n      setResult = _useDispatch.setResult;\n\n  var _ref = result ? result : {},\n      _ref$keywords = _ref.keywords,\n      tags = _ref$keywords === void 0 ? [] : _ref$keywords,\n      _ref$text = _ref.text,\n      analizedText = _ref$text === void 0 ? \'\' : _ref$text;\n\n  var _useState = (0,external_React_.useState)(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      fetching = _useState2[0],\n      setFetching = _useState2[1];\n\n  var _useState3 = (0,external_React_.useState)(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      error = _useState4[0],\n      setError = _useState4[1];\n\n  var updateTags = function updateTags(_ref2) {\n    var text = _ref2.text,\n        amount = _ref2.amount;\n    if (!text) return;\n    setResult(null);\n    setError(false);\n    setFetching(true);\n    var myHeaders = new Headers();\n    myHeaders.append("Content-Type", "application/json");\n    var requestOptions = {\n      method: \'POST\',\n      headers: myHeaders,\n      body: JSON.stringify({\n        query_string: text,\n        keywords_qty: "".concat(amount)\n      }),\n      redirect: \'follow\'\n    };\n    fetch("https://tiempoar-supervised-learning.herokuapp.com/api/textrank", requestOptions).then(function (response) {\n      return response.json();\n    })["catch"](function (error) {\n      console.log(\'ERROR\', error);\n      setError(error);\n      setFetching(false);\n      throw error;\n    }).then(function (finalData) {\n      console.log(\'finalData\', finalData);\n      setResult(finalData);\n      setFetching(false);\n      return finalData;\n    });\n  };\n\n  return {\n    tags: tags,\n    analizedText: analizedText,\n    updateTags: updateTags,\n    fetching: fetching,\n    error: error\n  };\n}\n/**\r\n*   @return {string} The current text content of the current post. The post title is\r\n*   prepended to the main content.\r\n*   It updates with any change in title or content.\r\n*/\n\nvar useArticleText = function useArticleText() {\n  var _useState5 = (0,external_React_.useState)(\'\'),\n      _useState6 = _slicedToArray(_useState5, 2),\n      articleText = _useState6[0],\n      setArticleText = _useState6[1];\n\n  var postContent = useSelect(function (select) {\n    return select(\'core/editor\').getEditedPostContent();\n  });\n  var postTitle = useSelect(function (select) {\n    return select(\'core/editor\').getEditedPostAttribute(\'title\');\n  });\n  var richText = wp.richText.create({\n    html: "".concat(postTitle, "\\n        ").concat(postContent)\n  });\n  if (richText.text !== articleText) setArticleText(richText.text);\n  return articleText;\n};\nregisterGenericStore(\'ta-etiquetador\', function () {\n  var storeChanged = function storeChanged() {};\n\n  var result = null;\n  var selectors = {\n    getResult: function getResult() {\n      return result;\n    }\n  };\n  var actions = {\n    setResult: function setResult(newResult) {\n      result = newResult;\n      storeChanged();\n    }\n  };\n  return {\n    getSelectors: function getSelectors() {\n      return selectors;\n    },\n    getActions: function getActions() {\n      return actions;\n    },\n    subscribe: function subscribe(listener) {\n      storeChanged = listener;\n    }\n  };\n}());\n// EXTERNAL MODULE: ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\nvar injectStylesIntoStyleTag = __webpack_require__(191);\nvar injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);\n// EXTERNAL MODULE: ../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js!../../../../gutenberg/src/components/TAEtiquetador/style.css\nvar style = __webpack_require__(311);\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/TAEtiquetador/style.css\n\n            \n\nvar options = {};\n\noptions.insert = "head";\noptions.singleton = false;\n\nvar update = injectStylesIntoStyleTag_default()(style/* default */.Z, options);\n\n\n\n/* harmony default export */ const TAEtiquetador_style = (style/* default.locals */.Z.locals || {});\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/TAEtiquetador/TAEtiquetador.js\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || TAEtiquetador_unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return TAEtiquetador_arrayLikeToArray(arr); }\n\nfunction TAEtiquetador_slicedToArray(arr, i) { return TAEtiquetador_arrayWithHoles(arr) || TAEtiquetador_iterableToArrayLimit(arr, i) || TAEtiquetador_unsupportedIterableToArray(arr, i) || TAEtiquetador_nonIterableRest(); }\n\nfunction TAEtiquetador_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction TAEtiquetador_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TAEtiquetador_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TAEtiquetador_arrayLikeToArray(o, minLen); }\n\nfunction TAEtiquetador_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction TAEtiquetador_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction TAEtiquetador_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nvar TAEtiquetador_useSelect = wp.data.useSelect;\nvar addQueryArgs = wp.url.addQueryArgs;\nvar _wp$components = wp.components,\n    Button = _wp$components.Button,\n    Spinner = _wp$components.Spinner;\n/**\r\n * Module constants\r\n */\n\nvar MAX_TERMS_SUGGESTIONS = 20;\nvar DEFAULT_QUERY = {\n  per_page: MAX_TERMS_SUGGESTIONS,\n  orderby: \'count\',\n  order: \'desc\',\n  _fields: \'id,name\'\n}; // Lodash unescape function handles &#39; but not &#039; which may be return in some API requests.\n\nvar unescapeString = function unescapeString(arg) {\n  return (0,external_lodash_namespaceObject.unescape)(arg.replace(\'&#039;\', "\'"));\n};\n/**\r\n * Returns a term object with name unescaped.\r\n * The unescape of the name property is done using lodash unescape function.\r\n *\r\n * @param {Object} term The term object to unescape.\r\n *\r\n * @return {Object} Term object with name property unescaped.\r\n */\n\n\nvar unescapeTerm = function unescapeTerm(term) {\n  return _objectSpread(_objectSpread({}, term), {}, {\n    name: unescapeString(term.name)\n  });\n};\n/**\r\n * Returns an array of term objects with names unescaped.\r\n * The unescape of each term is performed using the unescapeTerm function.\r\n *\r\n * @param {Object[]} terms Array of term objects to unescape.\r\n *\r\n * @return {Object[]} Array of term objects unescaped.\r\n */\n\n\nvar unescapeTerms = function unescapeTerms(terms) {\n  return (0,external_lodash_namespaceObject.map)(terms, unescapeTerm);\n};\n\nvar TAEtiquetador = function TAEtiquetador(props) {\n  var terms = props.terms,\n      taxonomy = props.taxonomy,\n      onUpdateTerms = props.onUpdateTerms; // Etiquetador API\n\n  var _useEtiquetador = useEtiquetador(),\n      etiquetadorTags = _useEtiquetador.tags,\n      analizedText = _useEtiquetador.analizedText,\n      updateTags = _useEtiquetador.updateTags,\n      etiquetadorFetching = _useEtiquetador.fetching,\n      etiquetadorError = _useEtiquetador.error;\n\n  var articleCurrentText = useArticleText();\n\n  var _useState = (0,external_React_.useState)(false),\n      _useState2 = TAEtiquetador_slicedToArray(_useState, 2),\n      fetchingTags = _useState2[0],\n      setFetchingTags = _useState2[1];\n\n  var _useState3 = (0,external_React_.useState)(false),\n      _useState4 = TAEtiquetador_slicedToArray(_useState3, 2),\n      loading = _useState4[0],\n      setLoading = _useState4[1];\n\n  var _useState5 = (0,external_React_.useState)([]),\n      _useState6 = TAEtiquetador_slicedToArray(_useState5, 2),\n      selectedTermsNames = _useState6[0],\n      setSelectedTermsNames = _useState6[1];\n\n  var _useState7 = (0,external_React_.useState)([]),\n      _useState8 = TAEtiquetador_slicedToArray(_useState7, 2),\n      requestedTermsNames = _useState8[0],\n      setRequestedTermsNames = _useState8[1];\n\n  var _useState9 = (0,external_React_.useState)([]),\n      _useState10 = TAEtiquetador_slicedToArray(_useState9, 2),\n      tagsOnQueue = _useState10[0],\n      setTagsOnQueue = _useState10[1];\n\n  var tagsFetchTimeout = (0,external_React_.useRef)(null);\n  var fetchWaitTimeout = (0,external_React_.useRef)(null);\n  var textChanged = articleCurrentText != analizedText;\n  var initRequest = (0,external_React_.useRef)(null);\n  var addRequest = (0,external_React_.useRef)(null);\n  var termNames = [];\n  var termsIds = []; // Wait for the user to stop selecting tags\n\n  (0,external_React_.useEffect)(function () {\n    clearTimeout(tagsFetchTimeout.current);\n\n    if (tagsOnQueue.length) {\n      if (!fetchingTags) {\n        tagsFetchTimeout.current = setTimeout(function () {\n          onChange(tagsOnQueue);\n          setTagsOnQueue([]);\n        }, 500);\n      }\n    }\n  }, [tagsOnQueue, fetchingTags]); // Populate termNames and termsIds arrays\n\n  if (terms) {\n    terms.forEach(function (term, i) {\n      termNames.push(term.name);\n      termsIds.push(term.id ? term.id : term.term_id);\n    });\n  }\n  /**\r\n  *   Cheks if the tags exists, and retrieves or creates them, dispatching the result updating the post.\r\n  */\n\n\n  var onChange = function onChange(newTermsNames) {\n    var updatedTermNames = termNames.concat(newTermsNames);\n    var uniqueTermsNames = (0,external_lodash_namespaceObject.uniqBy)(updatedTermNames, function (term) {\n      return term.toLowerCase();\n    });\n    setSelectedTermsNames(uniqueTermsNames); // New terms aren\'t in availableTerms\n\n    var newTermNames = uniqueTermsNames.filter(function (termName) {\n      return !(0,external_lodash_namespaceObject.find)(terms, function (term) {\n        return isSameTermName(term.name, termName);\n      });\n    });\n\n    var termNamesToObjects = function termNamesToObjects(names, availableTerms) {\n      return names.map(function (termName) {\n        return (0,external_lodash_namespaceObject.find)(availableTerms, function (term) {\n          return isSameTermName(term.name, termName);\n        });\n      });\n    };\n\n    if (newTermNames.length === 0) {\n      return onUpdateTerms(termNamesToObjects(uniqueTermsNames, terms), taxonomy.rest_base);\n    }\n\n    setFetchingTags(true);\n    setRequestedTermsNames([].concat(_toConsumableArray(requestedTermsNames), _toConsumableArray(newTermNames)));\n    Promise.all(newTermNames.map(findOrCreateTerm)).then(function (newTerms) {\n      // Old terms + new terms (WP_Terms data)\n      var newAvailableTerms = terms.concat(newTerms); // this.setState( { availableTerms: newAvailableTerms } );\n\n      var requestedTermsNamesCopy = _toConsumableArray(requestedTermsNames);\n\n      newTermNames.forEach(function (termName, i) {\n        (0,external_lodash_namespaceObject.remove)(requestedTermsNamesCopy, function (storedTermName) {\n          return storedTermName == termName;\n        });\n      });\n      setRequestedTermsNames(_toConsumableArray(requestedTermsNamesCopy));\n      return onUpdateTerms(termNamesToObjects(uniqueTermsNames, newAvailableTerms), taxonomy.rest_base).then(function () {\n        setFetchingTags(false);\n      });\n    });\n  };\n  /**\r\n  *   Returns tag data. If it doesn\'t exists, it creates it.\r\n  */\n\n\n  var findOrCreateTerm = function findOrCreateTerm(termName) {\n    var termNameEscaped = (0,external_lodash_namespaceObject.escape)(termName); // Tries to create a term or fetch it if it already exists.\n\n    return wp.apiFetch({\n      path: "/wp/v2/".concat(taxonomy.rest_base),\n      method: \'POST\',\n      data: {\n        name: termNameEscaped\n      }\n    })["catch"](function (error) {\n      var errorCode = error.code;\n\n      if (errorCode === \'term_exists\') {\n        // If the terms exist, fetch it instead of creating a new one.\n        addRequest.current = wp.apiFetch({\n          path: addQueryArgs("/wp/v2/".concat(taxonomy.rest_base), _objectSpread(_objectSpread({}, DEFAULT_QUERY), {}, {\n            search: termNameEscaped\n          }))\n        }).then(unescapeTerms);\n        return addRequest.current.then(function (searchResult) {\n          return (0,external_lodash_namespaceObject.find)(searchResult, function (result) {\n            return isSameTermName(result.name, termName);\n          });\n        });\n      }\n\n      return Promise.reject(error);\n    }).then(function (finalData) {\n      return unescapeTerm(finalData);\n    });\n  };\n\n  var generateTags = function generateTags() {\n    if (!etiquetadorFetching && textChanged) {\n      updateTags({\n        text: articleCurrentText,\n        amount: 20\n      });\n    }\n  };\n\n  var enqueueTag = function enqueueTag(tagName) {\n    return setTagsOnQueue([].concat(_toConsumableArray(tagsOnQueue), [tagName]));\n  };\n\n  var isSameTermName = function isSameTermName(termA, termB) {\n    return unescapeString(termA).toLowerCase() === unescapeString(termB).toLowerCase();\n  };\n\n  var isTermBeingFetched = function isTermBeingFetched(termName) {\n    return (0,external_lodash_namespaceObject.find)(requestedTermsNames, function (term) {\n      return isSameTermName(term, termName);\n    });\n  };\n\n  var isTermInQueue = function isTermInQueue(termName) {\n    return (0,external_lodash_namespaceObject.find)(tagsOnQueue, function (term) {\n      return isSameTermName(term, termName);\n    });\n  };\n\n  var isTagBeingLoaded = function isTagBeingLoaded(tagName) {\n    return isTermInQueue(tagName) || isTermBeingFetched(tagName);\n  };\n\n  var newTagsNames = etiquetadorTags ? etiquetadorTags.filter(function (termName) {\n    return !(0,external_lodash_namespaceObject.find)(terms, function (term) {\n      return isSameTermName(term.name, termName);\n    });\n  }) : null;\n\n  var getTagsButtons = function getTagsButtons() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$onlyDisabled = _ref.onlyDisabled,\n        onlyDisabled = _ref$onlyDisabled === void 0 ? false : _ref$onlyDisabled;\n\n    var tagsButtons = newTagsNames ? newTagsNames.filter(function (tagName) {\n      return !isTagBeingLoaded(tagName);\n    }).map(function (tagName) {\n      return /*#__PURE__*/external_React_default().createElement(Button, {\n        disabled: false,\n        isSecondary: true,\n        className: "tag-btn",\n        key: unescapeString(tagName),\n        onClick: function onClick() {\n          return enqueueTag(tagName);\n        }\n      }, tagName);\n    }) : \'\';\n    return tagsButtons && tagsButtons.length ? /*#__PURE__*/external_React_default().createElement("div", {\n      className: "tags-container"\n    }, tagsButtons) : \'\';\n  };\n\n  var getTagsLoadingButtons = function getTagsLoadingButtons() {\n    var tagsButtons = newTagsNames ? newTagsNames.filter(function (tagName) {\n      return isTagBeingLoaded(tagName);\n    }).map(function (tagName) {\n      return /*#__PURE__*/external_React_default().createElement(Button, {\n        disabled: true,\n        isSecondary: true,\n        className: "tag-btn",\n        key: unescapeString(tagName)\n      }, tagName);\n    }) : \'\';\n    return tagsButtons && tagsButtons.length ? /*#__PURE__*/external_React_default().createElement("div", null, /*#__PURE__*/external_React_default().createElement("p", {\n      className: ""\n    }, "Agregando los siguientes tags:"), /*#__PURE__*/external_React_default().createElement("div", {\n      className: "tags-container tags-fetching"\n    }, tagsButtons)) : \'\';\n  };\n\n  return /*#__PURE__*/external_React_default().createElement("div", {\n    className: "ta-etiquetador"\n  }, /*#__PURE__*/external_React_default().createElement("div", {\n    className: "header"\n  }, /*#__PURE__*/external_React_default().createElement("p", {\n    className: "title"\n  }, "Tags recomendados")), !newTagsNames.length && !etiquetadorFetching && /*#__PURE__*/external_React_default().createElement("div", {\n    className: "no-tags"\n  }, /*#__PURE__*/external_React_default().createElement("p", null, "No hay tags recomendados. Intente modificando el contenido del articulo y volviendo a hacer click en \\"GENERAR TAGS\\"")), getTagsButtons(), getTagsLoadingButtons(), etiquetadorFetching && /*#__PURE__*/external_React_default().createElement("div", {\n    className: "loading-spinner"\n  }, /*#__PURE__*/external_React_default().createElement(Spinner, null)), /*#__PURE__*/external_React_default().createElement(Button, {\n    disabled: !textChanged,\n    className: "generator-btn btn",\n    onClick: generateTags,\n    isSecondary: true\n  }, etiquetadorFetching ? \'GENERANDO\' : \'GENERAR TAGS\'));\n};\n\n/* harmony default export */ const TAEtiquetador_TAEtiquetador = (TAEtiquetador); // const { termsData, setTermsData } = useRbTerms(taxonomy, terms, {\n//     termsQueryArgs: {\n//         include: terms,\n//         only_include: true,\n//         taxonomy: taxonomy,\n//         include: terms.join( \',\' ),\n//         per_page: -1,\n//     },\n//     // fetchArgs: suplementsFetchArgs,\n// });\n// const onChange = ( termNames ) => {\n//     console.log(\'termNames\', termNames);\n// \tconst uniqueTermsNames = uniqBy( termNames, ( term ) => term.toLowerCase() );\n// \t// this.setState( { selectedTerms: uniqueTerms } );\n//\n//     // Stores the terms that are not in the props.terms array\n// \tconst newTermNames = uniqueTermsNames.filter( ( termName ) =>\n// \t\t!find( terms, ( term ) => isSameTermName( term.name, termName ) )\n// \t);\n//\n// \tconst termNamesToObjects = ( names, availableTerms ) => {\n// \t\treturn names.map( ( termName ) =>\n// \t\t\tfind( availableTerms, ( term ) =>\n// \t\t\t\tisSameTermName( term.name, termName )\n// \t\t\t)\n// \t\t);\n// \t};\n//\n// \tif ( newTermNames.length === 0 ) {\n//         console.log(terms);\n// \t\treturn onUpdateTerms(\n// \t\t\ttermNamesToObjects( uniqueTermsNames, terms ),\n// \t\t\ttaxonomy.rest_base\n// \t\t);\n// \t}\n//\n//     console.log(\'newTermNames\', newTermNames);\n// \tPromise.all( newTermNames.map( findOrCreateTerm ) ).then(\n// \t\t( newTerms ) => {\n//             // Old terms + new terms (WP_Terms data)\n// \t\t\tconst newAvailableTerms = terms.concat( newTerms );\n//             console.log(newAvailableTerms, newTerms);\n// \t\t\t// this.setState( { availableTerms: newAvailableTerms } );\n// \t\t\treturn onUpdateTerms(\n// \t\t\t\ttermNamesToObjects( uniqueTermsNames, newAvailableTerms ),\n// \t\t\t\ttaxonomy.rest_base\n// \t\t\t);\n// \t\t}\n// \t);\n// };\n;// CONCATENATED MODULE: external "wp.components"\nconst external_wp_components_namespaceObject = wp.components;\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/RBTagsManager/RBTagsManager.js\nfunction RBTagsManager_slicedToArray(arr, i) { return RBTagsManager_arrayWithHoles(arr) || RBTagsManager_iterableToArrayLimit(arr, i) || RBTagsManager_unsupportedIterableToArray(arr, i) || RBTagsManager_nonIterableRest(); }\n\nfunction RBTagsManager_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction RBTagsManager_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return RBTagsManager_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return RBTagsManager_arrayLikeToArray(o, minLen); }\n\nfunction RBTagsManager_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction RBTagsManager_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction RBTagsManager_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction RBTagsManager_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction RBTagsManager_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { RBTagsManager_ownKeys(Object(source), true).forEach(function (key) { RBTagsManager_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { RBTagsManager_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction RBTagsManager_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nvar RBTagsManager_addQueryArgs = wp.url.addQueryArgs;\n/**\r\n * Module constants\r\n */\n\nvar RBTagsManager_MAX_TERMS_SUGGESTIONS = 20;\nvar RBTagsManager_DEFAULT_QUERY = {\n  per_page: RBTagsManager_MAX_TERMS_SUGGESTIONS,\n  orderby: \'count\',\n  order: \'desc\',\n  _fields: \'id,name\'\n}; // Lodash unescape function handles &#39; but not &#039; which may be return in some API requests.\n\nvar RBTagsManager_unescapeString = function unescapeString(arg) {\n  return (0,external_lodash_namespaceObject.unescape)(arg.replace(\'&#039;\', "\'"));\n};\n/**\r\n * Returns a term object with name unescaped.\r\n * The unescape of the name property is done using lodash unescape function.\r\n *\r\n * @param {Object} term The term object to unescape.\r\n *\r\n * @return {Object} Term object with name property unescaped.\r\n */\n\n\nvar RBTagsManager_unescapeTerm = function unescapeTerm(term) {\n  return RBTagsManager_objectSpread(RBTagsManager_objectSpread({}, term), {}, {\n    name: RBTagsManager_unescapeString(term.name)\n  });\n};\n/**\r\n * Returns an array of term objects with names unescaped.\r\n * The unescape of each term is performed using the unescapeTerm function.\r\n *\r\n * @param {Object[]} terms Array of term objects to unescape.\r\n *\r\n * @return {Object[]} Array of term objects unescaped.\r\n */\n\n\nvar RBTagsManager_unescapeTerms = function unescapeTerms(terms) {\n  return (0,external_lodash_namespaceObject.map)(terms, RBTagsManager_unescapeTerm);\n};\n\nvar RBTagsManager = function RBTagsManager(props) {\n  var _props$terms = props.terms,\n      terms = _props$terms === void 0 ? [] : _props$terms,\n      _props$exclude = props.exclude,\n      exclude = _props$exclude === void 0 ? null : _props$exclude,\n      _props$onUpdateTerms = props.onUpdateTerms,\n      onUpdateTerms = _props$onUpdateTerms === void 0 ? null : _props$onUpdateTerms,\n      taxonomy = props.taxonomy;\n\n  var _useState = (0,external_React_.useState)([]),\n      _useState2 = RBTagsManager_slicedToArray(_useState, 2),\n      suggestions = _useState2[0],\n      setSuggestions = _useState2[1];\n\n  var _useState3 = (0,external_React_.useState)(false),\n      _useState4 = RBTagsManager_slicedToArray(_useState3, 2),\n      loadingSuggestions = _useState4[0],\n      setLoadingSuggestions = _useState4[1];\n\n  var lastFetchedValue = (0,external_React_.useRef)(null);\n  var addRequest = (0,external_React_.useRef)(null);\n\n  var getTermValue = function getTermValue(term) {\n    var name = term.name,\n        id = term.id,\n        term_id = term.term_id;\n    return RBTagsManager_objectSpread(RBTagsManager_objectSpread({}, term), {}, {\n      term_id: term_id ? term_id : id,\n      value: name\n    });\n  };\n\n  var getValues = function getValues() {\n    return terms ? terms.map(function (term) {\n      return getTermValue(term).name;\n    }) : [];\n  };\n\n  var onChange = function onChange(termNames) {\n    console.log(\'termNames\', termNames);\n    var uniqueTermsNames = (0,external_lodash_namespaceObject.uniqBy)(termNames, function (term) {\n      return term.toLowerCase();\n    }); // this.setState( { selectedTerms: uniqueTerms } );\n\n    console.log(\'uniqueTermsNames\', uniqueTermsNames); // Stores the terms that are not in the props.terms array\n\n    var newTermNames = uniqueTermsNames.filter(function (termName) {\n      return !(0,external_lodash_namespaceObject.find)(terms, function (term) {\n        return isSameTermName(term.name, termName);\n      });\n    });\n    console.log(\'newTermNames\', newTermNames);\n\n    var termNamesToObjects = function termNamesToObjects(names, availableTerms) {\n      return names.map(function (termName) {\n        return (0,external_lodash_namespaceObject.find)(availableTerms, function (term) {\n          return isSameTermName(term.name, termName);\n        });\n      });\n    };\n\n    if (newTermNames.length === 0) {\n      console.log(terms);\n      return onUpdateTerms(termNamesToObjects(uniqueTermsNames, terms), taxonomy.rest_base);\n    }\n\n    console.log(\'newTermNames\', newTermNames);\n    Promise.all(newTermNames.map(findOrCreateTerm)).then(function (newTerms) {\n      // Old terms + new terms (WP_Terms data)\n      var newAvailableTerms = terms.concat(newTerms);\n      console.log(newAvailableTerms, newTerms); // this.setState( { availableTerms: newAvailableTerms } );\n\n      return onUpdateTerms(termNamesToObjects(uniqueTermsNames, newAvailableTerms), taxonomy.rest_base);\n    });\n  };\n\n  var isInSuggestions = function isInSuggestions(name) {\n    return suggestions ? suggestions.find(function (suggestion) {\n      return name == suggestion.name;\n    }) : false;\n  };\n\n  var loadSuggestions = function loadSuggestions(value) {\n    // Cancel the previous request (falta codigo)\n    // const value = inputValue;\n    setLoadingSuggestions(true);\n    lastFetchedValue.current = value;\n    wp.apiFetch({\n      path: RBTagsManager_addQueryArgs("/wp/v2/".concat(taxonomy.rest_base), RBTagsManager_objectSpread(RBTagsManager_objectSpread({}, RBTagsManager_DEFAULT_QUERY), {}, {\n        search: value\n      }))\n    }).then(function (data) {\n      if (lastFetchedValue.current == value) {\n        var newSuggestions = data.map(function (term) {\n          return term.name;\n        });\n        setLoadingSuggestions(false);\n        setSuggestions(newSuggestions);\n      }\n    });\n  };\n\n  var onSuggestionsFetchRequested = function onSuggestionsFetchRequested(value) {\n    loadSuggestions(value);\n  };\n\n  var isSameTermName = function isSameTermName(termA, termB) {\n    return RBTagsManager_unescapeString(termA).toLowerCase() === RBTagsManager_unescapeString(termB).toLowerCase();\n  };\n\n  var findOrCreateTerm = function findOrCreateTerm(termName) {\n    var termNameEscaped = (0,external_lodash_namespaceObject.escape)(termName); // Tries to create a term or fetch it if it already exists.\n\n    return wp.apiFetch({\n      path: "/wp/v2/".concat(taxonomy.rest_base),\n      method: \'POST\',\n      data: {\n        name: termNameEscaped\n      }\n    })["catch"](function (error) {\n      var errorCode = error.code;\n\n      if (errorCode === \'term_exists\') {\n        console.log(\'term_exists\'); // If the terms exist, fetch it instead of creating a new one.\n\n        addRequest.current = wp.apiFetch({\n          path: RBTagsManager_addQueryArgs("/wp/v2/".concat(taxonomy.rest_base), RBTagsManager_objectSpread(RBTagsManager_objectSpread({}, RBTagsManager_DEFAULT_QUERY), {}, {\n            search: termNameEscaped\n          }))\n        }).then(RBTagsManager_unescapeTerms);\n        return addRequest.current.then(function (searchResult) {\n          return (0,external_lodash_namespaceObject.find)(searchResult, function (result) {\n            return isSameTermName(result.name, termName);\n          });\n        });\n      }\n\n      console.log(\'RETURN REJECT\');\n      return Promise.reject(error);\n    }).then(function (finalData) {\n      console.log(\'finalData\', finalData);\n      return RBTagsManager_unescapeTerm(finalData);\n    });\n  };\n\n  return /*#__PURE__*/external_React_default().createElement(external_wp_components_namespaceObject.FormTokenField, {\n    value: getValues(),\n    suggestions: suggestions,\n    onChange: onChange,\n    onInputChange: onSuggestionsFetchRequested\n  });\n};\n\n/* harmony default export */ const RBTagsManager_RBTagsManager = (RBTagsManager);\n;// CONCATENATED MODULE: ../../../../gutenberg/src/helpers/rb-fetch-hoc/rb-fetch-hoc.js\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction rb_fetch_hoc_slicedToArray(arr, i) { return rb_fetch_hoc_arrayWithHoles(arr) || rb_fetch_hoc_iterableToArrayLimit(arr, i) || rb_fetch_hoc_unsupportedIterableToArray(arr, i) || rb_fetch_hoc_nonIterableRest(); }\n\nfunction rb_fetch_hoc_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction rb_fetch_hoc_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return rb_fetch_hoc_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return rb_fetch_hoc_arrayLikeToArray(o, minLen); }\n\nfunction rb_fetch_hoc_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction rb_fetch_hoc_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction rb_fetch_hoc_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction rb_fetch_hoc_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction rb_fetch_hoc_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { rb_fetch_hoc_ownKeys(Object(source), true).forEach(function (key) { rb_fetch_hoc_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { rb_fetch_hoc_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction rb_fetch_hoc_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar _wp$element = wp.element,\n    Component = _wp$element.Component,\n    useState = _wp$element.useState,\n    useEffect = _wp$element.useEffect,\n    useRef = _wp$element.useRef,\n    useReducer = _wp$element.useReducer;\nvar _wp = wp,\n    apiFetch = _wp.apiFetch;\nvar rb_fetch_hoc_addQueryArgs = wp.url.addQueryArgs; //import PropTypes from \'prop-types\';\n\nfunction useRbFetch(path, props) {\n  props = props ? props : {};\n  props = rb_fetch_hoc_objectSpread({\n    queryArgs: null,\n    data: null,\n    method: \'get\',\n    updateOnArgsChange: true,\n    filterData: null,\n    onThen: null,\n    onCatch: null,\n    needsUpdateCheck: null\n  }, props);\n  var isMountFetch = useRef(true);\n\n  var _useReducer = useReducer(function (prevState, action) {\n    /*console.log(\'state change\');*/\n    return rb_fetch_hoc_objectSpread(rb_fetch_hoc_objectSpread({}, prevState), action);\n  }, {\n    response: null,\n    responseData: null,\n    loading: false,\n    error: false,\n    shouldFetch: true\n  }),\n      _useReducer2 = rb_fetch_hoc_slicedToArray(_useReducer, 2),\n      state = _useReducer2[0],\n      setState = _useReducer2[1];\n\n  var prevProps = usePrevious(props);\n  var prevPath = usePrevious(path);\n\n  var triggerFetch = function triggerFetch() {\n    setState({\n      shouldFetch: true\n    });\n  };\n\n  useEffect(function () {\n    // if(!props.updateOnArgsChange || (props.needsUpdateCheck && props.needsUpdateCheck()))\n    //     return;\n    if (!isMountFetch.current && (!props.updateOnArgsChange || prevPath == path && JSON.stringify(prevProps) == JSON.stringify(props))) return;\n    if (!path) return;\n    isMountFetch.current = false; // if(!state.shouldFetch)\n    //     return;\n\n    setState({\n      loading: true,\n      shouldFetch: false\n    });\n    path = props.queryArgs ? rb_fetch_hoc_addQueryArgs(path, props.queryArgs) : path;\n    apiFetch({\n      data: props.data,\n      method: props.method,\n      path: path,\n      parse: false\n    }).then(function (response) {\n      response.json().then(function (responseData) {\n        //console.log(state);\n        setState({\n          response: response,\n          responseData: responseData,\n          loading: false,\n          error: false\n        });\n        if (props.onThen) props.onThen({\n          response: response,\n          responseData: responseData\n        });\n      });\n    })["catch"](function (response) {\n      setState({\n        response: response,\n        loading: false,\n        error: true\n      });\n      if (props.onCatch) props.onCatch({\n        response: response\n      });\n    });\n  });\n  return {\n    response: state.response,\n    responseData: state.responseData,\n    status: {\n      loading: state.loading,\n      error: state.error\n    },\n    triggerFetch: triggerFetch\n  };\n}\n\nfunction usePrevious(value) {\n  // The ref object is a generic container whose current property is mutable ...\n  // ... and can hold any value, similar to an instance property on a class\n  var ref = useRef(); // Store current value in ref\n\n  useEffect(function () {\n    ref.current = value;\n  }, [value]); // Only re-run if value changes\n  // Return previous value (happens before update in useEffect above)\n\n  return ref.current;\n}\n\nfunction rbDoFetch(restPath, args) {\n  if (!restPath) return false;\n  var defaultArgs = {\n    parse: false,\n    queryArgs: null,\n    data: null,\n    method: \'get\'\n  };\n  args = args ? Object.assign({}, defaultArgs, args) : defaultArgs;\n  restPath = args.queryArgs ? rb_fetch_hoc_addQueryArgs(restPath, args.queryArgs) : restPath;\n  return apiFetch(rb_fetch_hoc_objectSpread({\n    path: restPath\n  }, args));\n}\n/**\r\n*   @param {string}    fetchDataPropIdentifier\r\n*   Identifier used to distinguish the data send from the HOC to the WrappedComponent, from other HOCs that my used the same default prop name\r\n*/\n\nfunction rb_fetch_hoc_RBFetchHOC(fetchDataPropIdentifier) {\n  var fetchDataPropName = typeof fetchDataPropIdentifier === \'string\' ? fetchDataPropIdentifier : \'fetchData\';\n  return function (WrappedComponent) {\n    var _class, _temp;\n\n    return _temp = _class = /*#__PURE__*/function (_Component) {\n      _inherits(RBFetchHOCClass, _Component);\n\n      var _super = _createSuper(RBFetchHOCClass);\n\n      function RBFetchHOCClass(props) {\n        var _this;\n\n        _classCallCheck(this, RBFetchHOCClass);\n\n        _this = _super.call(this, props);\n        _this.initialState = {\n          data: null,\n          fetchOngoing: false,\n          fetchError: false\n        };\n        _this.state = _this.initialState;\n        return _this;\n      }\n\n      _createClass(RBFetchHOCClass, [{\n        key: "componentDidMount",\n        value: function componentDidMount() {\n          if (this.props.fetchOnMount) this.fetchData();\n        }\n      }, {\n        key: "componentDidUpdate",\n        value: function componentDidUpdate(prevProps, prevState) {\n          if (this.props.needsUpdateCheck && this.props.needsUpdateCheck(prevProps, prevState)) {\n            //console.log(\'needsUpdate: true => updating\');\n            this.abortLastRequest();\n            this.fetchData();\n          }\n        }\n      }, {\n        key: "abortLastRequest",\n        value: function abortLastRequest() {\n          this.requests[Object.keys(this.requests).length - 1].aborted = true;\n        }\n      }, {\n        key: "isAborted",\n        value: function isAborted(requestID) {\n          return this.requests[requestID] && this.requests[requestID].aborted;\n        }\n      }, {\n        key: "storeNewRequest",\n        value: function storeNewRequest(request) {\n          this.requests = this.requests ? this.requests : {};\n          var requestID = Object.keys(this.requests).length;\n          this.requests[requestID] = {\n            request: request,\n            aborted: false,\n            id: requestID\n          };\n          return this.requests[requestID];\n        }\n      }, {\n        key: "fetchData",\n        value: function fetchData() {\n          var _this2 = this;\n\n          this.setState({\n            fetchOngoing: true\n          });\n\n          if (!this.props.restPath) {\n            this.setState({\n              fetchOngoing: false\n            });\n            return false;\n          }\n\n          var request = rbDoFetch(this.props.restPath, {\n            queryArgs: this.props.queryArgs,\n            method: this.props.fetchMethod,\n            data: this.props.requestData,\n            parse: this.props.parse\n          });\n          var requestData = this.storeNewRequest(request);\n          request.then(function (response) {\n            if (_this2.props.abortPreviousRequestOnNew && _this2.isAborted(requestData.id)) return false;\n            response.json().then(function (data) {\n              _this2.setState({\n                data: data,\n                fetchOngoing: false,\n                fetchError: false\n              }, function () {\n                if (_this2.props.onFetchSuccess) {\n                  _this2.props.onFetchSuccess(response, data);\n                }\n              });\n            });\n          })["catch"](function (response) {\n            if (_this2.props.abortPreviousRequestOnNew && _this2.isAborted(requestData.id)) return false;\n\n            _this2.setState({\n              fetchOngoing: false,\n              fetchError: {\n                response: response\n              }\n            });\n          });\n        }\n      }, {\n        key: "getPassThoughProps",\n        value: function getPassThoughProps() {\n          var passThroughProps = Object.assign({}, this.props);\n\n          for (var hocPropName in RBFetchHOCClass.defaultProps) {\n            if (passThroughProps.hasOwnProperty(hocPropName)) delete passThroughProps[hocPropName];\n          }\n\n          return passThroughProps;\n        }\n      }, {\n        key: "getFetchData",\n        value: function getFetchData() {\n          var _this3 = this;\n\n          var fetchData = {};\n          fetchData[fetchDataPropName] = {\n            data: this.state.data,\n            fetchStatus: {\n              ongoing: this.state.fetchOngoing,\n              error: this.state.fetchError\n            },\n            doFetch: function doFetch() {\n              return _this3.fetchData();\n            }\n          };\n          if (this.props.fetchDataFilter) fetchData[fetchDataPropName] = this.props.fetchDataFilter(fetchData[fetchDataPropName]);\n          return fetchData;\n        }\n      }, {\n        key: "render",\n        value: function render() {\n          var fetchData = this.getFetchData();\n          var passThroughProps = this.getPassThoughProps();\n          return /*#__PURE__*/React.createElement(WrappedComponent, _extends({}, passThroughProps, fetchData));\n        }\n      }]);\n\n      return RBFetchHOCClass;\n    }(Component), _class.defaultProps = {\n      queryArgs: {},\n      fetchOnMount: true,\n      abortPreviousRequestOnNew: true,\n      parse: false,\n      fetchMethod: \'get\',\n      requestData: null,\n      restPath: \'\',\n      needsUpdateCheck: null,\n      onFetchSuccess: null,\n      //Allows to mutate the sent through the fetchData prop\n      fetchDataFilter: null\n    }, _temp;\n  };\n}\n;// CONCATENATED MODULE: ../../../../gutenberg/src/helpers/rb-terms-fetch-hoc/rb-terms-fetch-hoc.js\nfunction rb_terms_fetch_hoc_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rb_terms_fetch_hoc_typeof = function _typeof(obj) { return typeof obj; }; } else { rb_terms_fetch_hoc_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rb_terms_fetch_hoc_typeof(obj); }\n\nfunction rb_terms_fetch_hoc_extends() { rb_terms_fetch_hoc_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return rb_terms_fetch_hoc_extends.apply(this, arguments); }\n\nfunction rb_terms_fetch_hoc_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rb_terms_fetch_hoc_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rb_terms_fetch_hoc_createClass(Constructor, protoProps, staticProps) { if (protoProps) rb_terms_fetch_hoc_defineProperties(Constructor.prototype, protoProps); if (staticProps) rb_terms_fetch_hoc_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rb_terms_fetch_hoc_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rb_terms_fetch_hoc_setPrototypeOf(subClass, superClass); }\n\nfunction rb_terms_fetch_hoc_setPrototypeOf(o, p) { rb_terms_fetch_hoc_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rb_terms_fetch_hoc_setPrototypeOf(o, p); }\n\nfunction rb_terms_fetch_hoc_createSuper(Derived) { var hasNativeReflectConstruct = rb_terms_fetch_hoc_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rb_terms_fetch_hoc_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rb_terms_fetch_hoc_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rb_terms_fetch_hoc_possibleConstructorReturn(this, result); }; }\n\nfunction rb_terms_fetch_hoc_possibleConstructorReturn(self, call) { if (call && (rb_terms_fetch_hoc_typeof(call) === "object" || typeof call === "function")) { return call; } return rb_terms_fetch_hoc_assertThisInitialized(self); }\n\nfunction rb_terms_fetch_hoc_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction rb_terms_fetch_hoc_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction rb_terms_fetch_hoc_getPrototypeOf(o) { rb_terms_fetch_hoc_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rb_terms_fetch_hoc_getPrototypeOf(o); }\n\nfunction rb_terms_fetch_hoc_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction rb_terms_fetch_hoc_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { rb_terms_fetch_hoc_ownKeys(Object(source), true).forEach(function (key) { rb_terms_fetch_hoc_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { rb_terms_fetch_hoc_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction rb_terms_fetch_hoc_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar rb_terms_fetch_hoc_wp$element = wp.element,\n    rb_terms_fetch_hoc_Component = rb_terms_fetch_hoc_wp$element.Component,\n    rb_terms_fetch_hoc_useState = rb_terms_fetch_hoc_wp$element.useState,\n    rb_terms_fetch_hoc_useEffect = rb_terms_fetch_hoc_wp$element.useEffect;\n\nfunction useTermsFetch() {\n  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _args$termsQueryArgs = args.termsQueryArgs,\n      termsQueryArgs = _args$termsQueryArgs === void 0 ? {} : _args$termsQueryArgs,\n      _args$fetchArgs = args.fetchArgs,\n      fetchArgs = _args$fetchArgs === void 0 ? {} : _args$fetchArgs; //Terms query\n\n  var termsQuery = rb_terms_fetch_hoc_objectSpread({}, termsQueryArgs); //Fetch Args\n\n\n  var finalFetchArgs = rb_terms_fetch_hoc_objectSpread({\n    updateOnArgsChange: false\n  }, fetchArgs); //Terms Fetch\n\n\n  var _useRbFetch = useRbFetch(\'/rb/v1/terms\', rb_terms_fetch_hoc_objectSpread(rb_terms_fetch_hoc_objectSpread({}, finalFetchArgs), {}, {\n    queryArgs: termsQuery\n  })),\n      response = _useRbFetch.response,\n      terms = _useRbFetch.responseData,\n      status = _useRbFetch.status;\n\n  var totalPages = response && response.headers ? parseInt(response.headers.get(\'X-WP-TotalPages\')) : 0;\n  return {\n    terms: terms,\n    totalPages: totalPages,\n    status: status,\n    response: response\n  };\n}\nfunction RBTermsFetch() {\n  return function (HocComponent) {\n    var _class, _temp;\n\n    return _temp = _class = /*#__PURE__*/function (_Component) {\n      rb_terms_fetch_hoc_inherits(_class, _Component);\n\n      var _super = rb_terms_fetch_hoc_createSuper(_class);\n\n      function _class(props) {\n        var _this;\n\n        rb_terms_fetch_hoc_classCallCheck(this, _class);\n\n        _this = _super.call(this, props);\n        _this.initialState = {\n          terms: []\n        };\n        _this.state = _this.initialState;\n        _this.RBFetch = RBFetchHOC(\'termsFetchData\')(HocComponent);\n        return _this;\n      }\n\n      rb_terms_fetch_hoc_createClass(_class, [{\n        key: "checkNeedsUpdate",\n        value: function checkNeedsUpdate(prevProps, prevState) {\n          if (this.props.updateTermsOnArgsChange && this.restArgsChanged(prevProps)) {\n            //console.log(\'Terms fetch arguments changed => needsUpdate\');\n            return true;\n          }\n\n          return false;\n        }\n      }, {\n        key: "restArgsChanged",\n        value: function restArgsChanged(prevProps) {\n          var newArgs = this.props.termsFetchArgs;\n          var prevArgs = prevProps.termsFetchArgs;\n          if (newArgs && !prevArgs || !newArgs && prevArgs) return true;\n          if (newArgs == prevArgs) return false;\n\n          for (var argKey in newArgs) {\n            if (newArgs.hasOwnProperty(argKey)) {\n              if (!prevArgs.hasOwnProperty(argKey) || newArgs[argKey] != prevArgs[argKey]) return true;\n            }\n          }\n\n          return false;\n        }\n      }, {\n        key: "onFetchSuccess",\n        value: function onFetchSuccess(response, data) {\n          var _this2 = this;\n\n          //console.log(\'FETCH SUCCESS\');\n          this.setState({\n            totalPages: response.headers ? parseInt(response.headers.get(\'X-WP-TotalPages\')) : 0,\n            terms: data\n          }, function () {\n            if (_this2.props.onFetchSuccess) _this2.props.onFetchSuccess(response, data);\n          });\n        }\n      }, {\n        key: "fetchDataFilter",\n        value: function fetchDataFilter(data) {\n          return rb_terms_fetch_hoc_objectSpread(rb_terms_fetch_hoc_objectSpread({}, data), {}, {\n            terms: this.state.terms,\n            totalPages: this.state.totalPages\n          });\n        }\n      }, {\n        key: "render",\n        value: function render() {\n          var _this3 = this;\n\n          //const {...passThroughProps} = this.props;\n          return /*#__PURE__*/React.createElement(this.RBFetch, rb_terms_fetch_hoc_extends({}, this.props, {\n            queryArgs: this.props.termsFetchArgs,\n            restPath: "/rb/v1/terms",\n            needsUpdateCheck: function needsUpdateCheck(prevProps, prevState) {\n              return _this3.checkNeedsUpdate(prevProps, prevState);\n            },\n            onFetchSuccess: function onFetchSuccess(response, data) {\n              return _this3.onFetchSuccess(response, data);\n            },\n            fetchDataFilter: function fetchDataFilter(data) {\n              return _this3.fetchDataFilter(data);\n            }\n          }));\n        }\n      }]);\n\n      return _class;\n    }(rb_terms_fetch_hoc_Component), _class.defaultProps = {\n      updateTermsOnArgsChange: true,\n      termsFetchArgs: {\n        taxonomy: \'post_tag\'\n      }\n    }, _temp;\n  };\n}\n;// CONCATENATED MODULE: ../../../../gutenberg/src/helpers/rb-terms/rb-terms.js\nfunction rb_terms_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction rb_terms_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { rb_terms_ownKeys(Object(source), true).forEach(function (key) { rb_terms_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { rb_terms_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction rb_terms_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction rb_terms_slicedToArray(arr, i) { return rb_terms_arrayWithHoles(arr) || rb_terms_iterableToArrayLimit(arr, i) || rb_terms_unsupportedIterableToArray(arr, i) || rb_terms_nonIterableRest(); }\n\nfunction rb_terms_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction rb_terms_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return rb_terms_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return rb_terms_arrayLikeToArray(o, minLen); }\n\nfunction rb_terms_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction rb_terms_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction rb_terms_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar rb_terms_useState = wp.element.useState;\n\n/**\r\n*   Variables and functionalities that facilitates the managment of terms data\r\n*   @property {WP_Term[]}   termsData                       Terms array\r\n*   @property {function}    setTermsData                    Functions to change the \'termsData\'\r\n*   @property {object}      termsFetchStatus                Current status of the terms fetch\r\n*       @property {bool}    loading\r\n*       @property {bool}    error\r\n*   @property {bool}        termsChanged                    If the terms had changed from the original data\r\n*                                                           provided through the \'initialTerms\' arg\r\n*   @property {object}      taxQuery                        Tax query filter in base of the tax data. To use in WP_Query\r\n*   @property {int}         totalPages                      Amount of pages for the terms query\r\n*/\n\nfunction useRbTerms(taxonomy, termsQueryableData) {\n  var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _args$termsQueryArgs = args.termsQueryArgs,\n      termsQueryArgs = _args$termsQueryArgs === void 0 ? {} : _args$termsQueryArgs,\n      _args$fetchArgs = args.fetchArgs,\n      fetchArgs = _args$fetchArgs === void 0 ? {} : _args$fetchArgs,\n      _args$field = args.field,\n      field = _args$field === void 0 ? \'term_id\' : _args$field,\n      _args$initialTerms = args.initialTerms,\n      initialTerms = _args$initialTerms === void 0 ? [] : _args$initialTerms;\n\n  var _useState = rb_terms_useState(false),\n      _useState2 = rb_terms_slicedToArray(_useState, 2),\n      termsChanged = _useState2[0],\n      setTermsChanged = _useState2[1];\n\n  var _useState3 = rb_terms_useState(initialTerms),\n      _useState4 = rb_terms_slicedToArray(_useState3, 2),\n      termsStateData = _useState4[0],\n      setTermsDataState = _useState4[1];\n\n  var setTermsData = function setTermsData(stateValue) {\n    setTermsDataState(stateValue);\n    termsChanged ? false : setTermsChanged(true);\n  }; //Terms in\n\n\n  var terms_in = {};\n  if (field == \'term_id\') terms_in.include = termsQueryableData;else terms_in[field] = termsQueryableData; //Terms query\n\n  var termsQuery = rb_terms_objectSpread(rb_terms_objectSpread({}, termsQueryArgs), terms_in); //Terms Fetch\n\n\n  var _useTermsFetch = useTermsFetch({\n    termsQueryArgs: termsQuery,\n    fetchArgs: fetchArgs\n  }),\n      termsFetchData = _useTermsFetch.terms,\n      termsFetchStatus = _useTermsFetch.status,\n      totalPages = _useTermsFetch.totalPages; //Tax query for WP_Query\n\n\n  var taxQuery = {\n    taxonomy: taxonomy,\n    field: field,\n    terms: termsQueryableData\n  }; //Return\n\n  var termsData = termsChanged ? termsStateData : termsFetchData;\n  return {\n    termsData: termsData,\n    termsFetchData: termsFetchData,\n    termsFetchStatus: termsFetchStatus,\n    termsChanged: termsChanged,\n    termsStateData: termsStateData,\n    setTermsData: setTermsData,\n    taxQuery: taxQuery,\n    totalPages: totalPages,\n    terms_in: terms_in\n  };\n}\nfunction taxQueryArgs() {\n  var relation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \'OR\';\n  var taxQueries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var finalQuery = {};\n  var count = 0;\n  taxQueries.forEach(function (taxQuery) {\n    if (taxQuery.terms && taxQuery.terms.length) {\n      finalQuery[count] = taxQuery;\n      count++;\n    }\n  });\n  if (count > 1) finalQuery.relation = relation;\n  return finalQuery;\n}\n/**\r\n*   Devuelve una taxonomies query a usar en un WP_Query de articulos, en base a los\r\n*   siguientes parametros\r\n*   @param {array[]} terms                                  Array de terms tipo [ \'tax_id\' => [124,626,34]]\r\n*                                                           Se puede optar por pasar en vez de un array de terms, un array\r\n*                                                           con mas opciones, las cuales se detallan a continuacion.\r\n*           @param {mixed[]} terms                          Terms de la taxonomia. Tienen que corresponder al valor pasado por\r\n*                                                           la opcion \'field\'\r\n*           @param {string} field                           Indica a que field del term se refieren los valores pasados por $terms\r\n*                                                           Por default es \'term_id\'\r\n*           @param {bool} required                          Indica si la query de la taxonomia es obligatoria. Esto mete a esta taxonomia\r\n*                                                           en una query con relacion \'AND\', junto a las demas taxonomias obligatorias.\r\n*   @return {mixed[]}\r\n*/\n\nfunction rbTaxQuery(terms) {\n  var finalQuery = {};\n  var disjunctQuery = {};\n  var requiredQuery = {};\n  var reqCount = 0;\n  var disCount = 0;\n\n  for (var taxName in terms) {\n    if (!terms.hasOwnProperty(taxName)) continue;\n    var taxData = terms[taxName];\n    var taxTerms = Array.isArray(taxData) ? taxData : taxData.terms;\n    if (!taxTerms || Array.isArray(taxTerms) && !taxTerms.length) continue;\n    var taxQuery = {\n      taxonomy: taxName,\n      terms: taxTerms,\n      field: taxData.hasOwnProperty("field") && taxData.field ? taxData.field : \'term_id\'\n    };\n\n    if (taxData.hasOwnProperty("required") && taxData.required) {\n      requiredQuery[reqCount] = taxQuery;\n      reqCount++;\n    } else {\n      disjunctQuery[disCount] = taxQuery;\n      disCount++;\n    }\n  }\n\n  if (requiredQuery[reqCount - 1]) {\n    //If there are required terms\n    finalQuery = requiredQuery;\n    finalQuery.relation = \'AND\';\n  }\n\n  if (disjunctQuery[disCount - 1]) {\n    disjunctQuery.relation = \'OR\';\n    if (finalQuery.relation != \'AND\') //if the query is empty (no required terms)\n      finalQuery = disjunctQuery;else finalQuery[\'disjuntQuery\'] = disjunctQuery;\n  }\n\n  return finalQuery;\n}\n;// CONCATENATED MODULE: ../../../../gutenberg/src/blocks/ta-index/etiquetador.js\nfunction etiquetador_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction etiquetador_extends() { etiquetador_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return etiquetador_extends.apply(this, arguments); }\n\n\n\n\n\n\nvar etiquetador_wp$data = wp.data,\n    withSelect = etiquetador_wp$data.withSelect,\n    withDispatch = etiquetador_wp$data.withDispatch;\nvar compose = wp.compose.compose;\n\nfunction postScreenTermsSelector(OriginalComponent) {\n  return function () {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var taxonomy = props.slug,\n        taxonomyData = props.taxonomy,\n        terms = props.terms,\n        onUpdateTerms = props.onUpdateTerms;\n    if (taxonomy !== \'ta_article_tag\') return /*#__PURE__*/external_React_default().createElement(OriginalComponent, props);\n    return /*#__PURE__*/external_React_default().createElement((external_React_default()).Fragment, null, /*#__PURE__*/external_React_default().createElement(TATagsManager, etiquetador_extends({}, props, {\n      taxonomy: taxonomyData,\n      slug: taxonomy\n    })));\n  };\n}\n\nwp.hooks.addFilter(\'editor.PostTaxonomyType\', \'ta-etiquetador\', postScreenTermsSelector);\nvar TATagsManager = compose(withSelect(function (select, _ref) {\n  var slug = _ref.slug;\n\n  var _select = select(\'core/editor\'),\n      getCurrentPost = _select.getCurrentPost;\n\n  var _select2 = select(\'core\'),\n      getTaxonomy = _select2.getTaxonomy;\n\n  var taxonomy = getTaxonomy(slug);\n  return {\n    hasCreateAction: taxonomy ? (0,external_lodash_namespaceObject.get)(getCurrentPost(), [\'_links\', \'wp:action-create-\' + taxonomy.rest_base], false) : false,\n    hasAssignAction: taxonomy ? (0,external_lodash_namespaceObject.get)(getCurrentPost(), [\'_links\', \'wp:action-assign-\' + taxonomy.rest_base], false) : false,\n    taxonomy: taxonomy\n  };\n}), withDispatch(function (dispatch) {\n  return {\n    onUpdateTerms: function onUpdateTerms(termsIds, restBase) {\n      console.log(\'TERMS UPDATE\', termsIds);\n      var dispatchPromise = dispatch(\'core/editor\').editPost(etiquetador_defineProperty({}, restBase, termsIds));\n      console.log(dispatchPromise);\n      return dispatchPromise;\n    }\n  };\n}) // withFilters( \'editor.PostTaxonomyType\' )\n)(\n/*****************\r\n*\tCOMPONENT\r\n*****************/\nfunction (props) {\n  var taxonomy = props.slug,\n      taxonomyData = props.taxonomy,\n      terms = props.terms,\n      onUpdateTerms = props.onUpdateTerms;\n\n  var _useRbTerms = useRbTerms(taxonomy, terms, {\n    termsQueryArgs: {\n      include: terms,\n      only_include: true,\n      taxonomy: taxonomy,\n      hide_empty: false\n    } // fetchArgs: {\n    // \tupdateOnArgsChange: false,\n    // },\n\n  }),\n      termsData = _useRbTerms.termsData,\n      setTermsData = _useRbTerms.setTermsData;\n\n  var onTermsChange = function onTermsChange(selectedTerms) {\n    var postTerms = selectedTerms;\n    var termsIds = postTerms ? postTerms.map(function (term) {\n      return term.term_id ? term.term_id : term.id;\n    }) : [];\n    setTermsData(postTerms);\n    return onUpdateTerms(termsIds, taxonomyData.rest_base);\n  };\n\n  return /*#__PURE__*/external_React_default().createElement((external_React_default()).Fragment, null, /*#__PURE__*/external_React_default().createElement(RBTagsManager_RBTagsManager, etiquetador_extends({}, props, {\n    onUpdateTerms: onTermsChange,\n    terms: termsData,\n    taxonomy: taxonomyData,\n    slug: taxonomy\n  })), /*#__PURE__*/external_React_default().createElement(TAEtiquetador_TAEtiquetador, {\n    terms: termsData,\n    slug: taxonomy,\n    taxonomy: taxonomyData,\n    onUpdateTerms: onTermsChange\n  }));\n});\n// EXTERNAL MODULE: ../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js!../../../../gutenberg/src/components/RBAutocomplete/css/style.css\nvar css_style = __webpack_require__(975);\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/RBAutocomplete/css/style.css\n\n            \n\nvar style_options = {};\n\nstyle_options.insert = "head";\nstyle_options.singleton = false;\n\nvar style_update = injectStylesIntoStyleTag_default()(css_style/* default */.Z, style_options);\n\n\n\n/* harmony default export */ const RBAutocomplete_css_style = (css_style/* default.locals */.Z.locals || {});\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/RBAutocomplete/RBAutocomplete.js\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction RBAutocomplete_slicedToArray(arr, i) { return RBAutocomplete_arrayWithHoles(arr) || RBAutocomplete_iterableToArrayLimit(arr, i) || RBAutocomplete_unsupportedIterableToArray(arr, i) || RBAutocomplete_nonIterableRest(); }\n\nfunction RBAutocomplete_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction RBAutocomplete_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return RBAutocomplete_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return RBAutocomplete_arrayLikeToArray(o, minLen); }\n\nfunction RBAutocomplete_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction RBAutocomplete_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction RBAutocomplete_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\nvar RBAutocomplete_wp = wp,\n    RBAutocomplete_apiFetch = RBAutocomplete_wp.apiFetch;\n\nfunction useAutocomplete(_ref) {\n  var search = _ref.search,\n      _ref$timeout = _ref.timeout,\n      timeout = _ref$timeout === void 0 ? 200 : _ref$timeout,\n      _ref$minLength = _ref.minLength,\n      minLength = _ref$minLength === void 0 ? 3 : _ref$minLength,\n      requestURL = _ref.requestURL,\n      filterFetchArgs = _ref.filterFetchArgs,\n      fetchSuggestions = _ref.fetchSuggestions;\n\n  var _useState = (0,external_React_.useState)([]),\n      _useState2 = RBAutocomplete_slicedToArray(_useState, 2),\n      suggestions = _useState2[0],\n      setSuggestions = _useState2[1];\n\n  var _useState3 = (0,external_React_.useState)(false),\n      _useState4 = RBAutocomplete_slicedToArray(_useState3, 2),\n      waitingInputEnd = _useState4[0],\n      setWaitingInputEnd = _useState4[1];\n\n  var _useState5 = (0,external_React_.useState)(false),\n      _useState6 = RBAutocomplete_slicedToArray(_useState5, 2),\n      fetching = _useState6[0],\n      setFetching = _useState6[1];\n\n  var fetchTimeout = (0,external_React_.useRef)(null);\n  var lastSearchedRef = (0,external_React_.useRef)(\'\');\n  (0,external_React_.useEffect)(function () {\n    lastSearchedRef.current = search;\n    clearTimeout(fetchTimeout.current);\n\n    if (search.length < minLength) {\n      setWaitingInputEnd(false);\n      setFetching(false);\n      setSuggestions([]);\n      return;\n    }\n\n    setWaitingInputEnd(true);\n    fetchTimeout.current = setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n      var newSuggestions;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              setWaitingInputEnd(false);\n              setFetching(true);\n              _context.next = 4;\n              return fetchSuggestions({\n                search: search,\n                suggestions: suggestions\n              });\n\n            case 4:\n              newSuggestions = _context.sent;\n\n              if (!(search !== lastSearchedRef.current)) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.abrupt("return");\n\n            case 7:\n              setFetching(false);\n              setSuggestions(newSuggestions);\n\n            case 9:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    })), timeout);\n  }, [search]);\n  return {\n    suggestions: suggestions,\n    waitingInputEnd: waitingInputEnd,\n    fetching: fetching,\n    setSuggestions: setSuggestions\n  };\n}\n/**\r\n*   Input with autocomplete functionality.\r\n*   @param {callback} onSelect                                                  Function to excecute when an item from the autocomplete dropdown has\r\n*                                                                               been selected. Recieves an object with `item` key\r\n*\r\n*   @param {callback} onSubmit                                                  Function to excecute when an the user submits the current search. Recieves\r\n*                                                                               an object with the following keys\r\n*       @param {string} search                                                          The submited search string\r\n*       @param {bool} waitingInputEnd                                                   Indicates if the component is waiting for the user to stop typing to generate suggestions\r\n*       @param {bool} fetching                                                          Indicates if a fetch is beeing perfomed\r\n*       @param {mixed[]} suggestions                                                        Array with current suggestions\r\n*\r\n*   @param {callback} getItemLabel                                              Returns the label to show in the suggestions dropdown for the items. Recieves an object with `item` key\r\n*   @param {callback} fetchSuggestions                                              A function that returns a promise that resolves into the suggestions. Recieves:\r\n*       @param {string} search                                                          The current searched string\r\n*       @param {mixed[]} suggestions                                                        Array with current suggestions\r\n*\r\n*   @param {string} placeholder                                                 The input placeholder text\r\n*/\n\n\nvar RBAutocomplete = function RBAutocomplete(props) {\n  var onSelect = props.onSelect,\n      onSubmit = props.onSubmit,\n      getItemLabel = props.getItemLabel,\n      fetchSuggestions = props.fetchSuggestions,\n      _props$placeholder = props.placeholder,\n      placeholder = _props$placeholder === void 0 ? \'\' : _props$placeholder,\n      _props$disabled = props.disabled,\n      disabled = _props$disabled === void 0 ? false : _props$disabled;\n\n  var _useState7 = (0,external_React_.useState)(\'\'),\n      _useState8 = RBAutocomplete_slicedToArray(_useState7, 2),\n      search = _useState8[0],\n      setSearch = _useState8[1];\n\n  var _useState9 = (0,external_React_.useState)(false),\n      _useState10 = RBAutocomplete_slicedToArray(_useState9, 2),\n      isFocused = _useState10[0],\n      setIsFocused = _useState10[1];\n\n  var inputRef = (0,external_React_.useRef)(null);\n\n  var _useAutocomplete = useAutocomplete({\n    search: search,\n    fetchSuggestions: fetchSuggestions\n  }),\n      suggestions = _useAutocomplete.suggestions,\n      waitingInputEnd = _useAutocomplete.waitingInputEnd,\n      fetching = _useAutocomplete.fetching,\n      setSuggestions = _useAutocomplete.setSuggestions;\n\n  var hasSuggestions = suggestions && suggestions.length > 0;\n  (0,external_React_.useEffect)(function () {\n    if (!inputRef.current) return;\n    inputRef.current.addEventListener(\'focus\', onInputFocus);\n    inputRef.current.addEventListener(\'blur\', onInputBlur);\n    return function () {\n      inputRef.current.removeEventListener(\'focus\', onInputFocus);\n      inputRef.current.removeEventListener(\'blur\', onInputBlur);\n    };\n  }, [inputRef.current]);\n\n  var onSubmitSearch = function onSubmitSearch() {\n    if (onSubmit) {\n      onSubmit({\n        search: search,\n        waitingInputEnd: waitingInputEnd,\n        fetching: fetching,\n        suggestions: suggestions\n      });\n    }\n  };\n\n  var onKeyDown = function onKeyDown(e) {\n    if (e.key === \'Enter\') {\n      onSubmitSearch();\n    }\n  };\n\n  var onInputFocus = function onInputFocus() {\n    setIsFocused(true);\n  };\n\n  var onInputBlur = function onInputBlur() {\n    setTimeout(function () {\n      setIsFocused(false);\n    }, 100);\n  };\n\n  var onItemSelect = function onItemSelect(_ref3) {\n    var item = _ref3.item;\n    if (onSelect) onSelect({\n      item: item,\n      setSearch: setSearch\n    });\n    setSearch(\'\');\n  };\n\n  var getSuggestionsList = function getSuggestionsList() {\n    var suggestionsItems = hasSuggestions ? suggestions.map(function (item) {\n      var label = getItemLabel ? getItemLabel({\n        item: item\n      }) : \'\';\n      return /*#__PURE__*/external_React_default().createElement("div", {\n        className: "result-item",\n        onClick: function onClick() {\n          return onItemSelect({\n            item: item\n          });\n        }\n      }, /*#__PURE__*/external_React_default().createElement("p", {\n        className: "title"\n      }, label));\n    }) : [];\n    return /*#__PURE__*/external_React_default().createElement("div", {\n      className: "results-list"\n    }, suggestionsItems);\n  };\n\n  return /*#__PURE__*/external_React_default().createElement("div", {\n    className: "rb-autocomplete"\n  }, /*#__PURE__*/external_React_default().createElement("input", {\n    ref: inputRef,\n    type: "text",\n    placeholder: placeholder,\n    disabled: disabled,\n    className: "search-input",\n    onChange: function onChange(e) {\n      return setSearch(e.target.value);\n    },\n    onKeyDown: onKeyDown\n  }), isFocused && (waitingInputEnd || fetching || hasSuggestions) && /*#__PURE__*/external_React_default().createElement("div", {\n    className: "dropdown"\n  }, /*#__PURE__*/external_React_default().createElement("div", {\n    className: "status"\n  }, waitingInputEnd && /*#__PURE__*/external_React_default().createElement("span", null, "..."), fetching && /*#__PURE__*/external_React_default().createElement("span", null, "Cargando...")), getSuggestionsList()));\n};\n\n/* harmony default export */ const RBAutocomplete_RBAutocomplete = (RBAutocomplete);\n// EXTERNAL MODULE: ../../../../../node_modules/react-sortablejs/dist/index.js\nvar dist = __webpack_require__(320);\n// EXTERNAL MODULE: ../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js!../../../../gutenberg/src/components/RBAutocompleteList/css/style.css\nvar RBAutocompleteList_css_style = __webpack_require__(599);\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/RBAutocompleteList/css/style.css\n\n            \n\nvar css_style_options = {};\n\ncss_style_options.insert = "head";\ncss_style_options.singleton = false;\n\nvar css_style_update = injectStylesIntoStyleTag_default()(RBAutocompleteList_css_style/* default */.Z, css_style_options);\n\n\n\n/* harmony default export */ const components_RBAutocompleteList_css_style = (RBAutocompleteList_css_style/* default.locals */.Z.locals || {});\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/RBAutocompleteList/RBAutocompleteList.js\nfunction RBAutocompleteList_extends() { RBAutocompleteList_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return RBAutocompleteList_extends.apply(this, arguments); }\n\nfunction RBAutocompleteList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction RBAutocompleteList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { RBAutocompleteList_ownKeys(Object(source), true).forEach(function (key) { RBAutocompleteList_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { RBAutocompleteList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction RBAutocompleteList_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction RBAutocompleteList_toConsumableArray(arr) { return RBAutocompleteList_arrayWithoutHoles(arr) || RBAutocompleteList_iterableToArray(arr) || RBAutocompleteList_unsupportedIterableToArray(arr) || RBAutocompleteList_nonIterableSpread(); }\n\nfunction RBAutocompleteList_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction RBAutocompleteList_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return RBAutocompleteList_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return RBAutocompleteList_arrayLikeToArray(o, minLen); }\n\nfunction RBAutocompleteList_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction RBAutocompleteList_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return RBAutocompleteList_arrayLikeToArray(arr); }\n\nfunction RBAutocompleteList_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n\n\nvar Dashicon = wp.components.Dashicon;\n\n/**\r\n*   @param {mixed} items                                                        The items array\r\n*   @param {callback} onChange                                                  Function to excecute when the list gets changed (items removed/added/sorted).\r\n*                                                                               Recieves an object with key `item`\r\n*   @param {callback} itemRender                                                Function that renders an item in the items list. Recieves:\r\n*       @param {mixed} item                                                         The item to render\r\n*       @param {callback} removeItem                                                A function used to remove the item from the list\r\n*   @param {object} autocompleteProps                                           See RBAutocomplete\r\n*/\n\nvar RBAutocompleteList = function RBAutocompleteList(props) {\n  var items = props.items,\n      onChange = props.onChange,\n      itemRender = props.itemRender,\n      filterNewItem = props.filterNewItem,\n      getItemLabel = props.getItemLabel,\n      _props$autocompletePr = props.autocompleteProps,\n      autocompleteProps = _props$autocompletePr === void 0 ? {} : _props$autocompletePr,\n      getItemKey = props.getItemKey,\n      _props$sortable = props.sortable,\n      sortable = _props$sortable === void 0 ? false : _props$sortable,\n      _props$handle = props.handle,\n      handle = _props$handle === void 0 ? null : _props$handle,\n      _props$max = props.max,\n      max = _props$max === void 0 ? 0 : _props$max,\n      _props$labels = props.labels,\n      labels = _props$labels === void 0 ? {} : _props$labels,\n      _props$disabled = props.disabled,\n      disabled = _props$disabled === void 0 ? false : _props$disabled,\n      onSubmit = props.onSubmit;\n  var fetchSuggestions = autocompleteProps.fetchSuggestions;\n  var _labels$maxReached = labels.maxReached,\n      maxReachedLabel = _labels$maxReached === void 0 ? \'Max amount reached!\' : _labels$maxReached;\n  var listRef = (0,external_React_.useRef)();\n  var hasItems = items && items.length;\n  var hasMaxLimit = max > 0;\n  var hasMaxItems = hasMaxLimit && items.length >= max;\n\n  var getItemsList = function getItemsList() {\n    var list = null;\n    var itemsComponents = [];\n\n    if (hasItems) {\n      var amountToShow = hasMaxItems ? max : items.length;\n\n      var _loop = function _loop(index) {\n        var item = items[index];\n        var label = getItemLabel ? getItemLabel({\n          item: item\n        }) : \'\';\n\n        var remove = function remove() {\n          return removeItem({\n            item: item,\n            index: index\n          });\n        };\n\n        var key = getItemKey({\n          item: item\n        });\n        var itemComponent = itemRender ? itemRender({\n          item: item,\n          key: key,\n          index: index,\n          removeItem: remove\n        }) : /*#__PURE__*/external_React_default().createElement("div", {\n          className: "item",\n          key: key\n        }, /*#__PURE__*/external_React_default().createElement("div", {\n          className: "title"\n        }, label), /*#__PURE__*/external_React_default().createElement("div", {\n          className: "rmv-btn"\n        }, /*#__PURE__*/external_React_default().createElement(Dashicon, {\n          className: "icon",\n          icon: "no-alt",\n          onClick: remove\n        })));\n        itemsComponents.push(itemComponent);\n      };\n\n      for (var index = 0; index < amountToShow; index++) {\n        _loop(index);\n      }\n    }\n\n    if (sortable && itemsComponents.length > 1) {\n      list = /*#__PURE__*/external_React_default().createElement(dist/* ReactSortable */._O, {\n        className: "items-list",\n        list: items,\n        setList: sortItems,\n        handle: handle\n      }, itemsComponents);\n    } else {\n      list = /*#__PURE__*/external_React_default().createElement("div", {\n        className: "items-list"\n      }, itemsComponents);\n    }\n\n    return list;\n  };\n\n  var doOnChange = function doOnChange(_ref) {\n    var action = _ref.action,\n        data = _ref.data;\n\n    if (onChange) {\n      var newItems = [];\n      var needsUpdate = true;\n\n      switch (action) {\n        case \'add\':\n          if (max == 1 || !hasMaxItems) {\n            var newItem = filterNewItem ? filterNewItem({\n              item: data.item\n            }) : data.item;\n            if (max == 1) //Swap item\n              newItems = [newItem];else newItems = [].concat(RBAutocompleteList_toConsumableArray(items), [newItem]);\n          } else if (hasMaxItems) {\n            // No change\n            needsUpdate = false;\n            break;\n          }\n\n          break;\n\n        case \'remove\':\n          newItems = RBAutocompleteList_toConsumableArray(items);\n          newItems.splice(data.index, 1);\n          break;\n\n        case \'sort\':\n          newItems = data;\n          break;\n\n        case \'default\':\n          newItems = data.items;\n          break;\n      }\n\n      if (needsUpdate) {\n        onChange({\n          items: newItems,\n          action: action,\n          data: data\n        });\n      }\n    }\n  };\n\n  var addItem = function addItem(data) {\n    return doOnChange({\n      action: \'add\',\n      data: data\n    });\n  };\n\n  var removeItem = function removeItem(data) {\n    return doOnChange({\n      action: \'remove\',\n      data: data\n    });\n  };\n\n  var sortItems = function sortItems(data) {\n    return doOnChange({\n      action: \'sort\',\n      data: data\n    });\n  };\n\n  var doFetchSuggestions = function doFetchSuggestions(data) {\n    return fetchSuggestions ? fetchSuggestions(RBAutocompleteList_objectSpread(RBAutocompleteList_objectSpread({}, data), {}, {\n      items: items\n    })) : [];\n  };\n\n  var onSubmitInput = function onSubmitInput(data) {\n    if (onSubmit) onSubmit(RBAutocompleteList_objectSpread(RBAutocompleteList_objectSpread({}, data), {}, {\n      addItem: addItem\n    }));\n  };\n\n  return /*#__PURE__*/external_React_default().createElement("div", {\n    className: "rb-autocomplete-list",\n    ref: listRef\n  }, /*#__PURE__*/external_React_default().createElement(RBAutocomplete_RBAutocomplete, RBAutocompleteList_extends({}, autocompleteProps, {\n    onSubmit: onSubmitInput,\n    fetchSuggestions: doFetchSuggestions,\n    onSelect: addItem,\n    disabled: disabled || hasMaxItems && max != 1\n  })), hasMaxItems && max != 1 && /*#__PURE__*/external_React_default().createElement("p", {\n    className: "max-reached-label"\n  }, maxReachedLabel), getItemsList());\n};\n\n/* harmony default export */ const RBAutocompleteList_RBAutocompleteList = (RBAutocompleteList);\n// EXTERNAL MODULE: ../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js!../../../../gutenberg/src/components/TAArticleAuthorMetaBlock/css/style.css\nvar TAArticleAuthorMetaBlock_css_style = __webpack_require__(902);\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/TAArticleAuthorMetaBlock/css/style.css\n\n            \n\nvar TAArticleAuthorMetaBlock_css_style_options = {};\n\nTAArticleAuthorMetaBlock_css_style_options.insert = "head";\nTAArticleAuthorMetaBlock_css_style_options.singleton = false;\n\nvar TAArticleAuthorMetaBlock_css_style_update = injectStylesIntoStyleTag_default()(TAArticleAuthorMetaBlock_css_style/* default */.Z, TAArticleAuthorMetaBlock_css_style_options);\n\n\n\n/* harmony default export */ const components_TAArticleAuthorMetaBlock_css_style = (TAArticleAuthorMetaBlock_css_style/* default.locals */.Z.locals || {});\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/TAArticleAuthorMetaBlock/TAArticleAuthorMetaBlock.js\nfunction TAArticleAuthorMetaBlock_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction TAArticleAuthorMetaBlock_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TAArticleAuthorMetaBlock_ownKeys(Object(source), true).forEach(function (key) { TAArticleAuthorMetaBlock_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TAArticleAuthorMetaBlock_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TAArticleAuthorMetaBlock_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TAArticleAuthorMetaBlock_slicedToArray(arr, i) { return TAArticleAuthorMetaBlock_arrayWithHoles(arr) || TAArticleAuthorMetaBlock_iterableToArrayLimit(arr, i) || TAArticleAuthorMetaBlock_unsupportedIterableToArray(arr, i) || TAArticleAuthorMetaBlock_nonIterableRest(); }\n\nfunction TAArticleAuthorMetaBlock_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction TAArticleAuthorMetaBlock_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TAArticleAuthorMetaBlock_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TAArticleAuthorMetaBlock_arrayLikeToArray(o, minLen); }\n\nfunction TAArticleAuthorMetaBlock_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction TAArticleAuthorMetaBlock_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction TAArticleAuthorMetaBlock_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\nvar TAArticleAuthorMetaBlock_wp$components = wp.components,\n    TextControl = TAArticleAuthorMetaBlock_wp$components.TextControl,\n    PanelBody = TAArticleAuthorMetaBlock_wp$components.PanelBody,\n    TAArticleAuthorMetaBlock_Spinner = TAArticleAuthorMetaBlock_wp$components.Spinner;\nvar TAArticleAuthorMetaBlock_useSelect = wp.data.useSelect;\nvar useEntityProp = wp.coreData.useEntityProp;\n/**\r\n*   Generates a block that displays basic author information and controls to\r\n*   update metavalue related to the author in the article\r\n*/\n\nvar TAArticleAuthorMetaBlock = function TAArticleAuthorMetaBlock(props) {\n  var author = props.author,\n      onRemove = props.onRemove,\n      _props$loading = props.loading,\n      loading = _props$loading === void 0 ? false : _props$loading;\n  var postType = TAArticleAuthorMetaBlock_useSelect(function (select) {\n    return select(\'core/editor\').getCurrentPostType();\n  }, []);\n\n  var _useEntityProp = useEntityProp(\'postType\', postType, \'meta\'),\n      _useEntityProp2 = TAArticleAuthorMetaBlock_slicedToArray(_useEntityProp, 2),\n      meta = _useEntityProp2[0],\n      setMeta = _useEntityProp2[1];\n\n  var metaFieldValue = meta && meta[\'ta_article_authors_rols\'] ? meta[\'ta_article_authors_rols\'] : {};\n\n  function updateMetaValue(newRol) {\n    var mutatedValue = TAArticleAuthorMetaBlock_objectSpread({}, metaFieldValue);\n\n    mutatedValue[author.term.term_id] = newRol;\n    setMeta(TAArticleAuthorMetaBlock_objectSpread(TAArticleAuthorMetaBlock_objectSpread({}, meta), {}, {\n      \'ta_article_authors_rols\': mutatedValue\n    }));\n  }\n\n  var panelBody = function panelBody() {\n    if (!author) return null;\n    var rol = metaFieldValue[author.term.term_id];\n    var photoStyle = {\n      backgroundImage: "url(\\"".concat(author.photo, "\\")")\n    };\n    return /*#__PURE__*/external_React_default().createElement("div", {\n      className: "content"\n    }, /*#__PURE__*/external_React_default().createElement("div", {\n      className: "author-data"\n    }, /*#__PURE__*/external_React_default().createElement("div", {\n      className: "photo-container"\n    }, /*#__PURE__*/external_React_default().createElement("div", {\n      className: "photo",\n      style: photoStyle\n    }))), /*#__PURE__*/external_React_default().createElement("div", {\n      className: "meta-controls"\n    }, /*#__PURE__*/external_React_default().createElement("div", {\n      className: "input-container"\n    }, /*#__PURE__*/external_React_default().createElement(TextControl, {\n      label: "Rol",\n      value: rol ? rol : \'\',\n      onChange: updateMetaValue\n    })), /*#__PURE__*/external_React_default().createElement("div", {\n      className: "remove-author",\n      onClick: onRemove ? onRemove : false\n    }, /*#__PURE__*/external_React_default().createElement("p", {\n      className: "remove-btn"\n    }, "Remover Autor"))));\n  };\n\n  return /*#__PURE__*/external_React_default().createElement("div", {\n    className: "ta-article-author-meta"\n  }, /*#__PURE__*/external_React_default().createElement(PanelBody, {\n    title: /*#__PURE__*/external_React_default().createElement((external_React_default()).Fragment, null, loading && /*#__PURE__*/external_React_default().createElement(TAArticleAuthorMetaBlock_Spinner, null), author && author.name),\n    icon: "person",\n    initialOpen: false\n  }, panelBody()));\n};\n\n/* harmony default export */ const TAArticleAuthorMetaBlock_TAArticleAuthorMetaBlock = (TAArticleAuthorMetaBlock);\n;// CONCATENATED MODULE: ../../../../gutenberg/src/helpers/useFetchAndStore/useFetchAndStore.js\nfunction useFetchAndStore_toConsumableArray(arr) { return useFetchAndStore_arrayWithoutHoles(arr) || useFetchAndStore_iterableToArray(arr) || useFetchAndStore_unsupportedIterableToArray(arr) || useFetchAndStore_nonIterableSpread(); }\n\nfunction useFetchAndStore_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction useFetchAndStore_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction useFetchAndStore_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return useFetchAndStore_arrayLikeToArray(arr); }\n\nfunction useFetchAndStore_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction useFetchAndStore_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { useFetchAndStore_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { useFetchAndStore_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction useFetchAndStore_slicedToArray(arr, i) { return useFetchAndStore_arrayWithHoles(arr) || useFetchAndStore_iterableToArrayLimit(arr, i) || useFetchAndStore_unsupportedIterableToArray(arr, i) || useFetchAndStore_nonIterableRest(); }\n\nfunction useFetchAndStore_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction useFetchAndStore_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return useFetchAndStore_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return useFetchAndStore_arrayLikeToArray(o, minLen); }\n\nfunction useFetchAndStore_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction useFetchAndStore_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction useFetchAndStore_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\nvar useFetchAndStore_wp = wp,\n    useFetchAndStore_apiFetch = useFetchAndStore_wp.apiFetch;\nvar useFetchAndStore = function useFetchAndStore(props) {\n  var values = props.values,\n      fetchData = props.fetchData,\n      onChange = props.onChange;\n\n  var _useState = (0,external_React_.useState)([]),\n      _useState2 = useFetchAndStore_slicedToArray(_useState, 2),\n      storedData = _useState2[0],\n      _setStoredData = _useState2[1];\n\n  var _useState3 = (0,external_React_.useState)(false),\n      _useState4 = useFetchAndStore_slicedToArray(_useState3, 2),\n      loading = _useState4[0],\n      setLoading = _useState4[1];\n\n  var _useState5 = (0,external_React_.useState)(null),\n      _useState6 = useFetchAndStore_slicedToArray(_useState5, 2),\n      error = _useState6[0],\n      setError = _useState6[1];\n\n  var needsUpdateRef = (0,external_React_.useRef)(false);\n  var dataBeingFetchedRef = (0,external_React_.useRef)(false);\n\n  var getStoredData = function getStoredData(_ref) {\n    var value = _ref.value,\n        index = _ref.index;\n    // console.log(\'Searching\', value);\n    return storedData.find(function (data) {\n      return data.originalValue == value;\n    });\n  };\n\n  var generateStoredData = function generateStoredData() {\n    var newStoredData = [];\n    if (values.length != storedData.length) needsUpdateRef.current = true;\n\n    if (values && values.length) {\n      for (var index = 0; index < values.length; index++) {\n        var value = values[index];\n        var data = getStoredData({\n          value: value,\n          index: index\n        });\n        if (storedData[index] && storedData[index].originalValue != value) needsUpdateRef.current = true;\n\n        if (data) {\n          newStoredData.push(data);\n        } else {\n          newStoredData.push({\n            data: null,\n            loading: true,\n            originalValue: value\n          });\n        }\n      }\n    } // setLoading(false);\n\n\n    return newStoredData;\n  };\n\n  (0,external_React_.useEffect)(function () {\n    useFetchAndStore_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n      var mutatedStoredData, needsUpdate, i, _storedData$i, data, _loading, fetchPromise, fetchFilter;\n\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!storedData) {\n                _context.next = 26;\n                break;\n              }\n\n              mutatedStoredData = useFetchAndStore_toConsumableArray(storedData);\n              needsUpdate = false;\n              i = 0;\n\n            case 4:\n              if (!(i < storedData.length)) {\n                _context.next = 25;\n                break;\n              }\n\n              _storedData$i = storedData[i], data = _storedData$i.data, _loading = _storedData$i.loading, fetchPromise = _storedData$i.fetchPromise, fetchFilter = _storedData$i.fetchFilter;\n\n              if (!_loading) {\n                _context.next = 22;\n                break;\n              }\n\n              dataBeingFetchedRef.current = true;\n\n              if (!fetchPromise) {\n                _context.next = 14;\n                break;\n              }\n\n              _context.next = 11;\n              return fetchPromise();\n\n            case 11:\n              _context.t0 = _context.sent;\n              _context.next = 17;\n              break;\n\n            case 14:\n              _context.next = 16;\n              return fetchData({\n                value: mutatedStoredData[i].originalValue\n              });\n\n            case 16:\n              _context.t0 = _context.sent;\n\n            case 17:\n              mutatedStoredData[i].data = _context.t0;\n              dataBeingFetchedRef.current = false;\n              mutatedStoredData[i].loading = false;\n              mutatedStoredData[i] = fetchFilter ? fetchFilter(mutatedStoredData[i]) : mutatedStoredData[i];\n              needsUpdate = true; // setStoredData(mutatedStoredData);\n              // onChange ? onChange() : null;\n              // return;\n\n            case 22:\n              i++;\n              _context.next = 4;\n              break;\n\n            case 25:\n              if (needsUpdate) {\n                // setTimeout( () => {\n                needsUpdateRef.current = true;\n\n                _setStoredData(mutatedStoredData); // onChange ? onChange() : null;\n                // }, 9999999);\n\n              }\n\n            case 26:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }))();\n\n    if (needsUpdateRef.current) {\n      onChange ? onChange({\n        dataBeingFetched: dataBeingFetchedRef.current\n      }) : null;\n      needsUpdateRef.current = false;\n    }\n  }, [storedData]);\n  (0,external_React_.useEffect)(function () {\n    var newStoredData = generateStoredData();\n\n    if (needsUpdateRef.current) {\n      _setStoredData(newStoredData && newStoredData.length ? newStoredData : []);\n    }\n  }, [values]);\n  return {\n    storedData: storedData,\n    setStoredData: function setStoredData(data) {\n      needsUpdateRef.current = true;\n\n      _setStoredData(data);\n    },\n    loading: loading,\n    error: error\n  };\n};\n;// CONCATENATED MODULE: ../../../../gutenberg/src/helpers/terms/terms.js\nfunction terms_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction terms_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { terms_ownKeys(Object(source), true).forEach(function (key) { terms_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { terms_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction terms_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction terms_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction terms_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { terms_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { terms_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\n\nvar terms_addQueryArgs = wp.url.addQueryArgs;\nvar terms_wp = wp,\n    terms_apiFetch = terms_wp.apiFetch;\nfunction fetchTerms(args) {\n  var taxonomy = args.taxonomy,\n      queryArgs = args.queryArgs;\n  var path = "/wp/v2/".concat(taxonomy);\n  path = queryArgs ? terms_addQueryArgs(path, queryArgs) : path;\n  return terms_apiFetch({\n    method: \'GET\',\n    path: path,\n    parse: false\n  }).then(function (data) {\n    return data.json();\n  });\n}\n;\nfunction fetchTerm(_x) {\n  return _fetchTerm.apply(this, arguments);\n}\n\nfunction _fetchTerm() {\n  _fetchTerm = terms_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref) {\n    var name, taxonomy, path, terms, term;\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            name = _ref.name, taxonomy = _ref.taxonomy;\n            path = "/wp/v2/".concat(taxonomy);\n            _context2.next = 4;\n            return fetchTerms({\n              taxonomy: taxonomy,\n              queryArgs: {\n                search: name\n              }\n            });\n\n          case 4:\n            terms = _context2.sent;\n            term = terms && terms.length && terms[0].name.trim().toLowerCase() == name.trim().toLowerCase() ? terms[0] : null;\n            return _context2.abrupt("return", term);\n\n          case 7:\n          case "end":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _fetchTerm.apply(this, arguments);\n}\n\nfunction createTerm(_ref2) {\n  var name = _ref2.name,\n      taxonomy = _ref2.taxonomy,\n      _ref2$args = _ref2.args,\n      args = _ref2$args === void 0 ? {} : _ref2$args;\n  return terms_apiFetch({\n    method: \'POST\',\n    data: terms_objectSpread(terms_objectSpread({}, args), {}, {\n      name: name\n    }),\n    path: "/wp/v2/".concat(taxonomy),\n    parse: false\n  }).then(function (data) {\n    return data.json();\n  });\n}\n;\nfunction fetchOrCreateTerm(_x2) {\n  return _fetchOrCreateTerm.apply(this, arguments);\n}\n\nfunction _fetchOrCreateTerm() {\n  _fetchOrCreateTerm = terms_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref3) {\n    var name, taxonomy, term;\n    return regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            name = _ref3.name, taxonomy = _ref3.taxonomy;\n            _context3.next = 3;\n            return fetchTerm({\n              name: name,\n              taxonomy: taxonomy\n            });\n\n          case 3:\n            term = _context3.sent;\n\n            if (!term) {\n              _context3.next = 8;\n              break;\n            }\n\n            _context3.t0 = term;\n            _context3.next = 11;\n            break;\n\n          case 8:\n            _context3.next = 10;\n            return createTerm({\n              name: name,\n              taxonomy: taxonomy\n            });\n\n          case 10:\n            _context3.t0 = _context3.sent;\n\n          case 11:\n            term = _context3.t0;\n            return _context3.abrupt("return", term);\n\n          case 13:\n          case "end":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _fetchOrCreateTerm.apply(this, arguments);\n}\n\nvar useTerms = function useTerms(props) {\n  var taxonomy = props.taxonomy,\n      terms = props.terms,\n      _props$termsQueryFiel = props.termsQueryField,\n      termsQueryField = _props$termsQueryFiel === void 0 ? \'include\' : _props$termsQueryFiel,\n      onChange = props.onChange;\n\n  var fetchTerm = /*#__PURE__*/function () {\n    var _ref5 = terms_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref4) {\n      var index, termFieldValue, fetchResult;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              index = _ref4.index, termFieldValue = _ref4.value;\n              _context.next = 3;\n              return fetchTerms({\n                taxonomy: taxonomy,\n                queryArgs: terms_defineProperty({}, termsQueryField, termFieldValue)\n              });\n\n            case 3:\n              fetchResult = _context.sent;\n              return _context.abrupt("return", fetchResult && fetchResult.length == 1 ? fetchResult[0] : null);\n\n            case 5:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function fetchTerm(_x3) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n\n  var _useFetchAndStore = useFetchAndStore({\n    values: terms,\n    fetchData: fetchTerm,\n    onChange: onChange\n  }),\n      termsData = _useFetchAndStore.storedData,\n      setTermsData = _useFetchAndStore.setStoredData,\n      loading = _useFetchAndStore.loading,\n      error = _useFetchAndStore.error;\n\n  return {\n    termsData: termsData,\n    setTermsData: setTermsData,\n    loading: loading,\n    error: error\n  };\n};\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/RBTermsSelector/RBTermsSelector.js\nfunction RBTermsSelector_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction RBTermsSelector_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { RBTermsSelector_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { RBTermsSelector_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction RBTermsSelector_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction RBTermsSelector_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { RBTermsSelector_ownKeys(Object(source), true).forEach(function (key) { RBTermsSelector_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { RBTermsSelector_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction RBTermsSelector_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nvar RBTermsSelector_useDispatch = wp.data.useDispatch;\nvar RBTermsSelector_wp = wp,\n    RBTermsSelector_apiFetch = RBTermsSelector_wp.apiFetch;\nvar RBTermsSelector_Spinner = wp.components.Spinner;\n\nfunction autocompleteFetchTerms(_ref) {\n  var taxonomy = _ref.taxonomy,\n      search = _ref.search,\n      termsData = _ref.termsData;\n  return fetchTerms({\n    taxonomy: taxonomy,\n    queryArgs: {\n      search: search,\n      orderby: \'name\',\n      order: \'asc\',\n      hide_empty: false,\n      exclude: termsData ? termsData.map(function (term) {\n        return term.data.id;\n      }) : []\n    }\n  });\n}\n\nvar RBTermsSelector = function RBTermsSelector(props) {\n  var taxonomy = props.taxonomy,\n      terms = props.terms,\n      _props$termsQueryFiel = props.termsQueryField,\n      termsQueryField = _props$termsQueryFiel === void 0 ? \'include\' : _props$termsQueryFiel,\n      renderItem = props.renderItem,\n      onUpdate = props.onUpdate,\n      onSubmit = props.onSubmit,\n      _props$max = props.max,\n      max = _props$max === void 0 ? 0 : _props$max,\n      _props$sortable = props.sortable,\n      sortable = _props$sortable === void 0 ? false : _props$sortable,\n      _props$disabled = props.disabled,\n      disabled = _props$disabled === void 0 ? false : _props$disabled,\n      _props$labels = props.labels,\n      labels = _props$labels === void 0 ? {} : _props$labels;\n\n  var _useTerms = useTerms({\n    taxonomy: taxonomy,\n    terms: terms,\n    termsQueryField: termsQueryField,\n    onChange: function onChange(data) {\n      var dataBeingFetched = data.dataBeingFetched;\n\n      if (!dataBeingFetched && onUpdate) {\n        onUpdate(RBTermsSelector_objectSpread(RBTermsSelector_objectSpread({}, data), {}, {\n          termsData: termsData\n        }));\n      }\n    }\n  }),\n      termsData = _useTerms.termsData,\n      setTermsData = _useTerms.setTermsData,\n      loading = _useTerms.loading;\n\n  var termFieldName = termsQueryField == \'include\' ? \'id\' : termsQueryField;\n  var _labels$inputPlacehol = labels.inputPlaceholder,\n      inputPlaceholder = _labels$inputPlacehol === void 0 ? "Buscar..." : _labels$inputPlacehol,\n      _labels$loading = labels.loading,\n      loadingLabel = _labels$loading === void 0 ? "Cargando..." : _labels$loading,\n      _labels$maxReached = labels.maxReached,\n      maxReachedLabel = _labels$maxReached === void 0 ? "No se pueden agregar mas terms" : _labels$maxReached;\n\n  var onChange = function onChange(_ref2) {\n    var items = _ref2.items;\n    setTermsData(items);\n  };\n\n  (0,external_React_.useEffect)(function () {}, [termsData]);\n\n  var fetchSuggestions = function fetchSuggestions(data) {\n    return autocompleteFetchTerms(RBTermsSelector_objectSpread(RBTermsSelector_objectSpread({}, data), {}, {\n      taxonomy: taxonomy,\n      termsData: termsData\n    }));\n  };\n\n  var getItemLabel = function getItemLabel(_ref3) {\n    var item = _ref3.item;\n    if (item.loading) return /*#__PURE__*/external_React_default().createElement(RBTermsSelector_Spinner, null);\n    if (item.data && item.data.name) return item.data.name;\n    return null;\n  };\n\n  return /*#__PURE__*/external_React_default().createElement("div", {\n    className: "ta-authors-selector"\n  }, loading && /*#__PURE__*/external_React_default().createElement("div", {\n    className: "loading"\n  }, /*#__PURE__*/external_React_default().createElement(RBTermsSelector_Spinner, null), loadingLabel), !loading && /*#__PURE__*/external_React_default().createElement(RBAutocompleteList_RBAutocompleteList, {\n    items: termsData,\n    autocompleteProps: {\n      placeholder: inputPlaceholder,\n      fetchSuggestions: fetchSuggestions,\n      getItemLabel: function getItemLabel(_ref4) {\n        var item = _ref4.item;\n        return item.name;\n      },\n      onSubmit: function () {\n        var _onSubmit = RBTermsSelector_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(data) {\n          return regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                case "end":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n\n        function onSubmit(_x) {\n          return _onSubmit.apply(this, arguments);\n        }\n\n        return onSubmit;\n      }()\n    },\n    onSubmit: /*#__PURE__*/function () {\n      var _ref5 = RBTermsSelector_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(data) {\n        var search, addItem, comparableSearch;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                search = data.search, addItem = data.addItem;\n                comparableSearch = search.trim().toLowerCase();\n\n                if (!termsData.find(function (term) {\n                  return term.data.name.toLowerCase() == comparableSearch;\n                })) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                return _context3.abrupt("return");\n\n              case 4:\n                addItem({\n                  item: {\n                    data: {\n                      name: search\n                    },\n                    loading: true,\n                    originalValue: search,\n                    fetchPromise: function () {\n                      var _fetchPromise = RBTermsSelector_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n                        var term;\n                        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                          while (1) {\n                            switch (_context2.prev = _context2.next) {\n                              case 0:\n                                _context2.next = 2;\n                                return fetchOrCreateTerm({\n                                  name: search,\n                                  taxonomy: taxonomy\n                                });\n\n                              case 2:\n                                term = _context2.sent;\n                                return _context2.abrupt("return", term);\n\n                              case 4:\n                              case "end":\n                                return _context2.stop();\n                            }\n                          }\n                        }, _callee2);\n                      }));\n\n                      function fetchPromise() {\n                        return _fetchPromise.apply(this, arguments);\n                      }\n\n                      return fetchPromise;\n                    }(),\n                    fetchFilter: function fetchFilter(storedData) {\n                      return RBTermsSelector_objectSpread(RBTermsSelector_objectSpread({}, storedData), {}, {\n                        originalValue: storedData.data[termFieldName]\n                      });\n                    }\n                  }\n                });\n\n              case 5:\n              case "end":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      return function (_x2) {\n        return _ref5.apply(this, arguments);\n      };\n    }(),\n    labels: {\n      maxReached: maxReachedLabel\n    },\n    itemRender: renderItem,\n    onChange: onChange,\n    getItemKey: function getItemKey(_ref6) {\n      var item = _ref6.item;\n      return item[termFieldName];\n    },\n    filterNewItem: function filterNewItem(_ref7) {\n      var item = _ref7.item;\n      return item.data ? item : {\n        data: item,\n        loading: false,\n        originalValue: item[termFieldName]\n      };\n    },\n    getItemLabel: getItemLabel,\n    sortable: sortable,\n    max: max,\n    disabled: disabled\n  }));\n};\n\n/* harmony default export */ const RBTermsSelector_RBTermsSelector = (RBTermsSelector);\n;// CONCATENATED MODULE: ../../../../gutenberg/src/helpers/useTAAuthors/useTAAuthors.js\nfunction useTAAuthors_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction useTAAuthors_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { useTAAuthors_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { useTAAuthors_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction useTAAuthors_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nvar useTAAuthors_wp = wp,\n    useTAAuthors_apiFetch = useTAAuthors_wp.apiFetch;\nfunction fetchAuthors(_ref) {\n  var args = _ref.args;\n  return useTAAuthors_apiFetch({\n    method: \'POST\',\n    data: {\n      args: args\n    },\n    path: "/ta/v1/authors",\n    parse: false\n  }).then(function (data) {\n    return data.json();\n  });\n}\n;\nfunction fetchAuthorsBy(_ref2) {\n  var terms = _ref2.terms,\n      _ref2$field = _ref2.field,\n      field = _ref2$field === void 0 ? \'include\' : _ref2$field;\n  return fetchAuthors({\n    args: useTAAuthors_defineProperty({\n      orderby: \'include\',\n      order: \'ASC\',\n      hide_empty: false\n    }, field, terms && terms.length ? terms : [])\n  });\n}\nvar useTAAuthors = function useTAAuthors(props) {\n  var terms = props.terms,\n      _props$termsQueryFiel = props.termsQueryField,\n      termsQueryField = _props$termsQueryFiel === void 0 ? \'include\' : _props$termsQueryFiel;\n  var termFieldName = termsQueryField == \'include\' ? \'term_id\' : termsQueryField;\n\n  var fetchAuthor = /*#__PURE__*/function () {\n    var _ref4 = useTAAuthors_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref3) {\n      var index, termFieldValue, fetchResult;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              index = _ref3.index, termFieldValue = _ref3.value;\n              _context.next = 3;\n              return fetchAuthorsBy({\n                terms: [termFieldValue],\n                field: termsQueryField\n              });\n\n            case 3:\n              fetchResult = _context.sent;\n              return _context.abrupt("return", fetchResult && fetchResult.length == 1 ? fetchResult[0] : null);\n\n            case 5:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function fetchAuthor(_x) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n\n  var _useFetchAndStore = useFetchAndStore({\n    values: terms,\n    fetchData: fetchAuthor\n  }),\n      authorsData = _useFetchAndStore.storedData,\n      setAuthors = _useFetchAndStore.setStoredData,\n      loading = _useFetchAndStore.loading,\n      error = _useFetchAndStore.error;\n\n  return {\n    authors: authorsData,\n    setAuthors: setAuthors,\n    loading: loading,\n    error: error\n  };\n};\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/TAAuthorsSelector/TAAuthorsSelector.js\n\n\n\n\nvar TAAuthorsSelector_addQueryArgs = wp.url.addQueryArgs;\nvar TAAuthorsSelector_Spinner = wp.components.Spinner;\nvar TAAuthorsSelector_wp = wp,\n    TAAuthorsSelector_apiFetch = TAAuthorsSelector_wp.apiFetch;\n\nvar TAAuthorsSelector = function TAAuthorsSelector(props) {\n  var terms = props.terms,\n      _props$termsQueryFiel = props.termsQueryField,\n      termsQueryField = _props$termsQueryFiel === void 0 ? \'include\' : _props$termsQueryFiel,\n      onUpdate = props.onUpdate,\n      onSubmit = props.onSubmit,\n      onNewAuthor = props.onNewAuthor,\n      _props$max = props.max,\n      max = _props$max === void 0 ? 0 : _props$max,\n      _props$sortable = props.sortable,\n      sortable = _props$sortable === void 0 ? false : _props$sortable,\n      _props$disabled = props.disabled,\n      disabled = _props$disabled === void 0 ? false : _props$disabled;\n\n  var _useTAAuthors = useTAAuthors({\n    terms: terms,\n    termsQueryField: termsQueryField\n  }),\n      authors = _useTAAuthors.authors,\n      setAuthors = _useTAAuthors.setAuthors,\n      loading = _useTAAuthors.loading;\n\n  var onChange = function onChange(_ref) {\n    var termsData = _ref.termsData,\n        dataBeingFetched = _ref.dataBeingFetched;\n\n    // setAuthors( items );\n    if (onUpdate) {\n      onUpdate({\n        authors: termsData,\n        dataBeingFetched: dataBeingFetched\n      });\n    }\n  };\n\n  var renderAuthorItem = function renderAuthorItem(_ref2) {\n    var item = _ref2.item,\n        key = _ref2.key,\n        index = _ref2.index,\n        removeItem = _ref2.removeItem;\n\n    var _ref3 = authors[index] ? authors[index] : {},\n        author = _ref3.data,\n        loading = _ref3.loading;\n\n    return /*#__PURE__*/React.createElement(TAArticleAuthorMetaBlock_TAArticleAuthorMetaBlock, {\n      key: key,\n      author: author,\n      onRemove: removeItem,\n      loading: loading\n    });\n  };\n\n  return /*#__PURE__*/React.createElement(RBTermsSelector_RBTermsSelector, {\n    taxonomy: "ta_article_author",\n    terms: terms,\n    termsQueryField: termsQueryField,\n    onUpdate: onChange,\n    renderItem: renderAuthorItem\n  });\n};\n\n/* harmony default export */ const TAAuthorsSelector_TAAuthorsSelector = (TAAuthorsSelector);\n;// CONCATENATED MODULE: ../../../../gutenberg/src/blocks/ta-index/authors-selector.js\nfunction authors_selector_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction authors_selector_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { authors_selector_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { authors_selector_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction authors_selector_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\r\n*   Replaces the terms selector for the ta_article_author taxonomy in gutenberg editor\r\n*/\n\nvar authors_selector_wp$data = wp.data,\n    authors_selector_useSelect = authors_selector_wp$data.useSelect,\n    authors_selector_useDispatch = authors_selector_wp$data.useDispatch;\nvar authorTaxonomy = wp.data.select(\'core\').getTaxonomy(\'ta_article_author\');\nvar authorTaxonomySetUnsubscribe = wp.data.subscribe(function () {\n  authorTaxonomy = wp.data.select(\'core\').getTaxonomy(\'ta_article_author\');\n  if (!authorTaxonomy) return;\n  authorTaxonomySetUnsubscribe();\n});\n\nfunction authorsEditorControl(OriginalComponent) {\n  return function () {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var taxonomy = props.slug,\n        taxonomyData = props.taxonomy,\n        terms = props.terms,\n        onUpdateTerms = props.onUpdateTerms;\n    if (taxonomy !== \'ta_article_author\') return /*#__PURE__*/React.createElement(OriginalComponent, props);\n    var authorsIds = authors_selector_useSelect(function (select) {\n      return select(\'core/editor\').getEditedPostAttribute(\'ta_article_author\');\n    }, []);\n\n    var _useDispatch = authors_selector_useDispatch(\'core/editor\'),\n        editPost = _useDispatch.editPost;\n\n    var getEntityRecords = authors_selector_useSelect(function (select) {\n      return select(\'core\').getEntityRecords;\n    }, []);\n    console.log(\'authorsIds\', authorsIds);\n    return /*#__PURE__*/React.createElement(TAAuthorsSelector_TAAuthorsSelector, {\n      terms: authorsIds,\n      sortable: false,\n      max: 0,\n      onUpdate: function onUpdate(_ref) {\n        var authors = _ref.authors,\n            dataBeingFetched = _ref.dataBeingFetched;\n        if (dataBeingFetched) return;\n        editPost(authors_selector_defineProperty({}, authorTaxonomy.rest_base, authors.filter(function (author) {\n          return author.data && !author.loading;\n        }).map(function (author) {\n          return author.data.id;\n        })));\n      },\n      onSubmit: /*#__PURE__*/function () {\n        var _ref3 = authors_selector_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref2) {\n          var search, terms;\n          return regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  search = _ref2.search;\n                  _context.next = 3;\n                  return getEntityRecords(\'taxonomy\', \'ta_article_author\', {\n                    search: search\n                  });\n\n                case 3:\n                  terms = _context.sent;\n                  console.log(search, terms);\n\n                case 5:\n                case "end":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n\n        return function (_x) {\n          return _ref3.apply(this, arguments);\n        };\n      }()\n    });\n  };\n}\n\nwp.hooks.addFilter(\'editor.PostTaxonomyType\', \'ta-author\', authorsEditorControl);\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/RBAttachmentControl/RBAttachmentControl.js\n\nvar _wp$editor = wp.editor,\n    MediaUpload = _wp$editor.MediaUpload,\n    MediaUploadCheck = _wp$editor.MediaUploadCheck;\nvar __ = wp.i18n.__;\nvar RBAttachmentControl_useSelect = wp.data.useSelect;\nvar RBAttachmentControl_wp$components = wp.components,\n    RBAttachmentControl_Button = RBAttachmentControl_wp$components.Button,\n    RBAttachmentControl_Spinner = RBAttachmentControl_wp$components.Spinner,\n    ResponsiveWrapper = RBAttachmentControl_wp$components.ResponsiveWrapper;\n/**\r\n*   @param {int[]} attachmentsIDs                                               Array of attachments ids. If its not a gallery, only the first index is used\r\n*   @param {bool} gallery\r\n*   @param {string[]} allowedMediaTypes                                         Array of allowed media types\r\n*   @param {callback} onChange                                                  Function to excecute when the attachments change. Recieves an object with `attachments` key.\r\n*   @param {object} labels                                                      Object that defined the labels to use in the component\r\n*/\n\nvar RBAttachmentControl = function RBAttachmentControl(props) {\n  var _props$attachmentsIDs = props.attachmentsIDs,\n      attachmentsIDs = _props$attachmentsIDs === void 0 ? [] : _props$attachmentsIDs,\n      _props$gallery = props.gallery,\n      gallery = _props$gallery === void 0 ? false : _props$gallery,\n      _props$allowedMediaTy = props.allowedMediaTypes,\n      allowedMediaTypes = _props$allowedMediaTy === void 0 ? [\'image\'] : _props$allowedMediaTy,\n      onChange = props.onChange,\n      labels = props.labels;\n  var _labels$title = labels.title,\n      titleLabel = _labels$title === void 0 ? \'Select Image\' : _labels$title,\n      _labels$imageAlt = labels.imageAlt,\n      imageAltLabel = _labels$imageAlt === void 0 ? \'Selected Image\' : _labels$imageAlt,\n      _labels$setImage = labels.setImage,\n      setImageLabel = _labels$setImage === void 0 ? \'Set Image\' : _labels$setImage,\n      _labels$remove = labels.remove,\n      removeLabel = _labels$remove === void 0 ? \'Remove\' : _labels$remove,\n      _labels$modifyGallery = labels.modifyGallery,\n      modifyGalleryLabel = _labels$modifyGallery === void 0 ? \'Modify Gallery\' : _labels$modifyGallery;\n  var instructions = /*#__PURE__*/external_React_default().createElement("p", null, __(\'To edit the background image, you need permission to upload media.\', \'ta-theme\'));\n  var attachments = RBAttachmentControl_useSelect(function (select, props) {\n    var _select = select(\'core\'),\n        getMedia = _select.getMedia;\n\n    var result = [];\n\n    if (attachmentsIDs) {\n      attachmentsIDs.forEach(function (attachmentID, i) {\n        var media = attachmentID ? getMedia(attachmentID) : null;\n        if (media) result.push(media);\n      });\n    }\n\n    return result;\n  });\n  var haveAttachments = attachmentsIDs.length > 0;\n  var attachmentsDataLoaded = attachments && attachments.length > 0 || attachmentsIDs.length == 0;\n  var mediaComponentValue = gallery ? attachmentsIDs : attachmentsIDs[0];\n\n  var doOnChange = function doOnChange(attachments) {\n    if (onChange) onChange({\n      attachments: gallery ? attachments : [attachments]\n    });\n  };\n\n  return /*#__PURE__*/external_React_default().createElement((external_React_default()).Fragment, null, /*#__PURE__*/external_React_default().createElement(MediaUploadCheck, {\n    fallback: instructions\n  }, /*#__PURE__*/external_React_default().createElement(MediaUpload, {\n    title: titleLabel,\n    onSelect: doOnChange,\n    allowedTypes: allowedMediaTypes,\n    value: mediaComponentValue,\n    multiple: gallery,\n    gallery: gallery,\n    render: function render(_ref) {\n      var open = _ref.open;\n      return /*#__PURE__*/external_React_default().createElement(RBAttachmentControl_Button, {\n        className: !haveAttachments ? \'editor-post-featured-image__toggle\' : \'editor-post-featured-image__preview\',\n        onClick: open\n      }, !haveAttachments && attachmentsDataLoaded && setImageLabel, !attachmentsDataLoaded && /*#__PURE__*/external_React_default().createElement(RBAttachmentControl_Spinner, null), haveAttachments && attachmentsDataLoaded && /*#__PURE__*/external_React_default().createElement("div", null, gallery && modifyGalleryLabel, !gallery && /*#__PURE__*/external_React_default().createElement("img", {\n        src: attachments[0].source_url,\n        alt: imageAltLabel\n      })));\n    }\n  })), !!attachmentsIDs && /*#__PURE__*/external_React_default().createElement(MediaUploadCheck, null, /*#__PURE__*/external_React_default().createElement(RBAttachmentControl_Button, {\n    onClick: function onClick() {\n      return doOnChange(null);\n    },\n    isLink: true,\n    isDestructive: true\n  }, removeLabel)));\n};\n\n/* harmony default export */ const RBAttachmentControl_RBAttachmentControl = (RBAttachmentControl);\n;// CONCATENATED MODULE: ../../../../gutenberg/src/blocks/ta-index/article-alt-img-meta.js\nfunction article_alt_img_meta_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction article_alt_img_meta_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { article_alt_img_meta_ownKeys(Object(source), true).forEach(function (key) { article_alt_img_meta_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { article_alt_img_meta_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction article_alt_img_meta_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction article_alt_img_meta_slicedToArray(arr, i) { return article_alt_img_meta_arrayWithHoles(arr) || article_alt_img_meta_iterableToArrayLimit(arr, i) || article_alt_img_meta_unsupportedIterableToArray(arr, i) || article_alt_img_meta_nonIterableRest(); }\n\nfunction article_alt_img_meta_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction article_alt_img_meta_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return article_alt_img_meta_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return article_alt_img_meta_arrayLikeToArray(o, minLen); }\n\nfunction article_alt_img_meta_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction article_alt_img_meta_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction article_alt_img_meta_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/**\r\n*   Adds a panel with a control to manage the article alternative image (cover)\r\n*/\n\n\nvar registerPlugin = wp.plugins.registerPlugin;\nvar PluginDocumentSettingPanel = wp.editPost.PluginDocumentSettingPanel;\nvar article_alt_img_meta_ = wp.i18n.__;\nvar article_alt_img_meta_useEntityProp = wp.coreData.useEntityProp;\n\nvar TAArticleAltThumbnailPanel = function TAArticleAltThumbnailPanel() {\n  var postType = wp.data.select(\'core/editor\').getCurrentPostType();\n  if (postType !== \'ta_article\') return null;\n\n  var _useEntityProp = article_alt_img_meta_useEntityProp(\'postType\', postType, \'meta\'),\n      _useEntityProp2 = article_alt_img_meta_slicedToArray(_useEntityProp, 2),\n      meta = _useEntityProp2[0],\n      setMeta = _useEntityProp2[1];\n\n  var metaImageId = meta && meta[\'ta_article_thumbnail_alt\'] ? meta[\'ta_article_thumbnail_alt\'] : null;\n\n  function updateMetaValue(_ref) {\n    var attachments = _ref.attachments;\n    var attachment = attachments ? attachments[0] : null;\n    setMeta(article_alt_img_meta_objectSpread(article_alt_img_meta_objectSpread({}, meta), {}, {\n      \'ta_article_thumbnail_alt\': attachment ? attachment.id : null\n    }));\n  }\n\n  return /*#__PURE__*/external_React_default().createElement(PluginDocumentSettingPanel, {\n    name: "ta-alt-img",\n    title: "Imagen Portada",\n    className: "custom-panel"\n  }, /*#__PURE__*/external_React_default().createElement(RBAttachmentControl_RBAttachmentControl, {\n    attachmentsIDs: metaImageId ? [metaImageId] : [],\n    allowedMediaTypes: [\'image\'],\n    onChange: updateMetaValue,\n    labels: {\n      title: \'Imagen Portada\',\n      imageAlt: \'Imagen Portada\',\n      setImage: \'Establecer Imagen Portada\',\n      remove: \'Quitar\'\n    }\n  }));\n};\n\nregisterPlugin(\'ta-article-alt-thumbnail-panel\', {\n  render: TAArticleAltThumbnailPanel,\n  icon: \'format-image\'\n});\n// EXTERNAL MODULE: ../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js!../../../../gutenberg/src/components/rb-selector-from-fetch/style.css\nvar rb_selector_from_fetch_style = __webpack_require__(685);\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/rb-selector-from-fetch/style.css\n\n            \n\nvar rb_selector_from_fetch_style_options = {};\n\nrb_selector_from_fetch_style_options.insert = "head";\nrb_selector_from_fetch_style_options.singleton = false;\n\nvar rb_selector_from_fetch_style_update = injectStylesIntoStyleTag_default()(rb_selector_from_fetch_style/* default */.Z, rb_selector_from_fetch_style_options);\n\n\n\n/* harmony default export */ const components_rb_selector_from_fetch_style = (rb_selector_from_fetch_style/* default.locals */.Z.locals || {});\n// EXTERNAL MODULE: ../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js!../../../../gutenberg/src/components/rb-list/style.css\nvar rb_list_style = __webpack_require__(53);\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/rb-list/style.css\n\n            \n\nvar rb_list_style_options = {};\n\nrb_list_style_options.insert = "head";\nrb_list_style_options.singleton = false;\n\nvar rb_list_style_update = injectStylesIntoStyleTag_default()(rb_list_style/* default */.Z, rb_list_style_options);\n\n\n\n/* harmony default export */ const components_rb_list_style = (rb_list_style/* default.locals */.Z.locals || {});\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/rb-list/rb-list.js\nfunction rb_list_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rb_list_typeof = function _typeof(obj) { return typeof obj; }; } else { rb_list_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rb_list_typeof(obj); }\n\nfunction rb_list_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rb_list_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rb_list_createClass(Constructor, protoProps, staticProps) { if (protoProps) rb_list_defineProperties(Constructor.prototype, protoProps); if (staticProps) rb_list_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rb_list_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rb_list_setPrototypeOf(subClass, superClass); }\n\nfunction rb_list_setPrototypeOf(o, p) { rb_list_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rb_list_setPrototypeOf(o, p); }\n\nfunction rb_list_createSuper(Derived) { var hasNativeReflectConstruct = rb_list_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rb_list_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rb_list_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rb_list_possibleConstructorReturn(this, result); }; }\n\nfunction rb_list_possibleConstructorReturn(self, call) { if (call && (rb_list_typeof(call) === "object" || typeof call === "function")) { return call; } return rb_list_assertThisInitialized(self); }\n\nfunction rb_list_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction rb_list_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction rb_list_getPrototypeOf(o) { rb_list_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rb_list_getPrototypeOf(o); }\n\nvar rb_list_Component = wp.element.Component;\n //A simple list of items that can be extended using the content filters provided through the props\n\nvar RBList = /*#__PURE__*/function (_Component) {\n  rb_list_inherits(RBList, _Component);\n\n  var _super = rb_list_createSuper(RBList);\n\n  function RBList(props) {\n    rb_list_classCallCheck(this, RBList);\n\n    return _super.call(this, props);\n  }\n  /*\r\n  *   Generates the item data using the \'getItemData\' prop.\r\n  *   If \'getItemData\' is not provided, a simple object, that indicates that the\r\n  *   item will be taken as the content to be shown in the row, will be return\r\n  */\n\n\n  rb_list_createClass(RBList, [{\n    key: "getItemData",\n    value: function getItemData(item) {\n      if (this.props.getItemData) return this.props.getItemData(item);\n      return {\n        detail: item\n      };\n    } //Returns an item row\n\n  }, {\n    key: "getRow",\n    value: function getRow(_ref) {\n      var item = _ref.item,\n          index = _ref.index;\n      var itemData = this.getItemData(item);\n      var itemContentElement = /*#__PURE__*/React.createElement("div", {\n        className: "item-content"\n      }, itemData.detail);\n      if (this.props.filterItemContent) itemContentElement = this.props.filterItemContent({\n        item: item,\n        itemData: itemData,\n        itemContentElement: itemContentElement,\n        index: index\n      });\n      var rowClass = itemData["class"] ? itemData["class"] : \'\';\n      var rowElement = /*#__PURE__*/React.createElement("div", {\n        className: "row item ".concat(rowClass)\n      }, itemContentElement);\n      if (this.props.filterRow) rowElement = this.props.filterRow({\n        item: item,\n        itemData: itemData,\n        rowElement: rowElement,\n        index: index\n      });\n      return rowElement;\n    } //Returns all the rows for the list\n\n  }, {\n    key: "getRows",\n    value: function getRows() {\n      var _this = this;\n\n      return !this.props.items ? [] : this.props.items.map(function (item, index) {\n        return _this.getRow({\n          item: item,\n          index: index\n        });\n      });\n    } //Returns the comple list\n\n  }, {\n    key: "getList",\n    value: function getList() {\n      var list = /*#__PURE__*/React.createElement("div", {\n        "class": "rb-list"\n      }, this.getRows());\n      if (this.props.filterList) list = this.props.filterList({\n        list: list\n      });\n      return list;\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var rows = this.getRows();\n      return /*#__PURE__*/React.createElement("div", {\n        className: "rb-list-container ".concat(this.props.className),\n        ref: this.props.containerRef\n      }, this.getList());\n    }\n  }]);\n\n  return RBList;\n}(rb_list_Component);\n\nRBList.defaultProps = {\n  /**\r\n  *   @property {mixed[]} items\r\n  *   @required\r\n  *   Array of items. There will be a row with action buttons for each one. The content of each item\r\n  *   is not restricted to any format or type. The extra data for the item will be retrieved using the\r\n  *   \'getItemData\' method provided through the props.\r\n  */\n  items: [],\n\n  /**\r\n  *   @property {function}    getItemData\r\n  *   Function that returns an items data\r\n  *   @required\r\n  *   @param {mixed}          item                    Item from items array\r\n  *   @returns {object}\r\n  *       @property {string}    id                          Item identifier\r\n  *       @property {mixed}     detail                      Content to show in the html element\r\n  *       @property {string}    class                       Class to add to the item element\r\n  */\n  getItemData: null,\n\n  /**\r\n  *   @property {string} rowClassName\r\n  *   Extra class to use in the list element\r\n  */\n  className: \'\',\n\n  /**\r\n  *   @property {function} filterItemContent\r\n  *   A function that filters an item content to be shown in the list row.\r\n  *   @param {object}   data                    Data\r\n  *       @property {mixed}   item                            Item from wich the content comes from\r\n  *       @property {object}    itemData                        Item data from \'getItemData\'\r\n  *       @property {jsx}     itemContentElement              The jsx for the item content element\r\n  *       @property {int}     index                           Item index\r\n  */\n  filterItemContent: null,\n\n  /**\r\n  *   @property {function} filterRow\r\n  *   A function to filter an item row.\r\n  *   @param {object}   data                    Data\r\n  *       @property {mixed}   item                            Row item\r\n  *       @property {object}    itemData                        Item data from \'getItemData\'\r\n  *       @property {jsx}     rowElement                      The jsx for the row\r\n  *       @property {int}     index                           Item index\r\n  */\n  filterRow: null,\n\n  /**\r\n  *   @property {function} filterList\r\n  *   A function to filter the list element.\r\n  *   @param {object}   data                    Data\r\n  *       @property {jsx}     list                            The jsx for the list\r\n  */\n  filterList: null,\n\n  /**\r\n  *   @property {object} containerRef\r\n  *   A ref that is associated with the list container\r\n  */\n  containerRef: null\n};\n\n// EXTERNAL MODULE: ../../../../../node_modules/array-move/index.js\nvar array_move = __webpack_require__(74);\nvar array_move_default = /*#__PURE__*/__webpack_require__.n(array_move);\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/extends.js\nfunction extends_extends() {\n  extends_extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return extends_extends.apply(this, arguments);\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js\nfunction arrayWithHoles_arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js\nfunction iterableToArrayLimit_iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i["return"] != null) _i["return"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js\nfunction arrayLikeToArray_arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js\n\nfunction unsupportedIterableToArray_unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === "string") return arrayLikeToArray_arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === "Object" && o.constructor) n = o.constructor.name;\n  if (n === "Map" || n === "Set") return Array.from(o);\n  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray_arrayLikeToArray(o, minLen);\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js\nfunction nonIterableRest_nonIterableRest() {\n  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js\n\n\n\n\nfunction slicedToArray_slicedToArray(arr, i) {\n  return arrayWithHoles_arrayWithHoles(arr) || iterableToArrayLimit_iterableToArrayLimit(arr, i) || unsupportedIterableToArray_unsupportedIterableToArray(arr, i) || nonIterableRest_nonIterableRest();\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js\nfunction defineProperty_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/objectSpread.js\n\nfunction objectSpread_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? Object(arguments[i]) : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === \'function\') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty_defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js\nfunction classCallCheck_classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/createClass.js\nfunction createClass_defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if ("value" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction createClass_createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) createClass_defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) createClass_defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/typeof.js\nfunction typeof_typeof(obj) {\n  "@babel/helpers - typeof";\n\n  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {\n    typeof_typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    typeof_typeof = function _typeof(obj) {\n      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;\n    };\n  }\n\n  return typeof_typeof(obj);\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\nfunction assertThisInitialized_assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return self;\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\n\n\nfunction possibleConstructorReturn_possibleConstructorReturn(self, call) {\n  if (call && (typeof_typeof(call) === "object" || typeof call === "function")) {\n    return call;\n  }\n\n  return assertThisInitialized_assertThisInitialized(self);\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\nfunction getPrototypeOf_getPrototypeOf(o) {\n  getPrototypeOf_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return getPrototypeOf_getPrototypeOf(o);\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\nfunction setPrototypeOf_setPrototypeOf(o, p) {\n  setPrototypeOf_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return setPrototypeOf_setPrototypeOf(o, p);\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/inherits.js\n\nfunction inherits_inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf_setPrototypeOf(subClass, superClass);\n}\n// EXTERNAL MODULE: ../../../../../node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(891);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n;// CONCATENATED MODULE: external "ReactDOM"\nconst external_ReactDOM_namespaceObject = ReactDOM;\n// EXTERNAL MODULE: ../../../../../node_modules/invariant/browser.js\nvar browser = __webpack_require__(386);\nvar browser_default = /*#__PURE__*/__webpack_require__.n(browser);\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js\n\nfunction arrayWithoutHoles_arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray_arrayLikeToArray(arr);\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js\nfunction iterableToArray_iterableToArray(iter) {\n  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js\nfunction nonIterableSpread_nonIterableSpread() {\n  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\n\n\n\n\nfunction toConsumableArray_toConsumableArray(arr) {\n  return arrayWithoutHoles_arrayWithoutHoles(arr) || iterableToArray_iterableToArray(arr) || unsupportedIterableToArray_unsupportedIterableToArray(arr) || nonIterableSpread_nonIterableSpread();\n}\n;// CONCATENATED MODULE: ../../../../../node_modules/react-sortable-hoc/dist/react-sortable-hoc.esm.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar Manager = function () {\n  function Manager() {\n    classCallCheck_classCallCheck(this, Manager);\n\n    defineProperty_defineProperty(this, "refs", {});\n  }\n\n  createClass_createClass(Manager, [{\n    key: "add",\n    value: function add(collection, ref) {\n      if (!this.refs[collection]) {\n        this.refs[collection] = [];\n      }\n\n      this.refs[collection].push(ref);\n    }\n  }, {\n    key: "remove",\n    value: function remove(collection, ref) {\n      var index = this.getIndex(collection, ref);\n\n      if (index !== -1) {\n        this.refs[collection].splice(index, 1);\n      }\n    }\n  }, {\n    key: "isActive",\n    value: function isActive() {\n      return this.active;\n    }\n  }, {\n    key: "getActive",\n    value: function getActive() {\n      var _this = this;\n\n      return this.refs[this.active.collection].find(function (_ref) {\n        var node = _ref.node;\n        return node.sortableInfo.index == _this.active.index;\n      });\n    }\n  }, {\n    key: "getIndex",\n    value: function getIndex(collection, ref) {\n      return this.refs[collection].indexOf(ref);\n    }\n  }, {\n    key: "getOrderedRefs",\n    value: function getOrderedRefs() {\n      var collection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.active.collection;\n      return this.refs[collection].sort(sortByIndex);\n    }\n  }]);\n\n  return Manager;\n}();\n\nfunction sortByIndex(_ref2, _ref3) {\n  var index1 = _ref2.node.sortableInfo.index;\n  var index2 = _ref3.node.sortableInfo.index;\n  return index1 - index2;\n}\n\nfunction arrayMove(array, from, to) {\n  if (false) {}\n\n  array = array.slice();\n  array.splice(to < 0 ? array.length + to : to, 0, array.splice(from, 1)[0]);\n  return array;\n}\nfunction omit(obj, keysToOmit) {\n  return Object.keys(obj).reduce(function (acc, key) {\n    if (keysToOmit.indexOf(key) === -1) {\n      acc[key] = obj[key];\n    }\n\n    return acc;\n  }, {});\n}\nvar events = {\n  end: [\'touchend\', \'touchcancel\', \'mouseup\'],\n  move: [\'touchmove\', \'mousemove\'],\n  start: [\'touchstart\', \'mousedown\']\n};\nvar vendorPrefix = function () {\n  if (typeof window === \'undefined\' || typeof document === \'undefined\') {\n    return \'\';\n  }\n\n  var styles = window.getComputedStyle(document.documentElement, \'\') || [\'-moz-hidden-iframe\'];\n  var pre = (Array.prototype.slice.call(styles).join(\'\').match(/-(moz|webkit|ms)-/) || styles.OLink === \'\' && [\'\', \'o\'])[1];\n\n  switch (pre) {\n    case \'ms\':\n      return \'ms\';\n\n    default:\n      return pre && pre.length ? pre[0].toUpperCase() + pre.substr(1) : \'\';\n  }\n}();\nfunction setInlineStyles(node, styles) {\n  Object.keys(styles).forEach(function (key) {\n    node.style[key] = styles[key];\n  });\n}\nfunction setTranslate3d(node, translate) {\n  node.style["".concat(vendorPrefix, "Transform")] = translate == null ? \'\' : "translate3d(".concat(translate.x, "px,").concat(translate.y, "px,0)");\n}\nfunction setTransitionDuration(node, duration) {\n  node.style["".concat(vendorPrefix, "TransitionDuration")] = duration == null ? \'\' : "".concat(duration, "ms");\n}\nfunction closest(el, fn) {\n  while (el) {\n    if (fn(el)) {\n      return el;\n    }\n\n    el = el.parentNode;\n  }\n\n  return null;\n}\nfunction limit(min, max, value) {\n  return Math.max(min, Math.min(value, max));\n}\n\nfunction getPixelValue(stringValue) {\n  if (stringValue.substr(-2) === \'px\') {\n    return parseFloat(stringValue);\n  }\n\n  return 0;\n}\n\nfunction getElementMargin(element) {\n  var style = window.getComputedStyle(element);\n  return {\n    bottom: getPixelValue(style.marginBottom),\n    left: getPixelValue(style.marginLeft),\n    right: getPixelValue(style.marginRight),\n    top: getPixelValue(style.marginTop)\n  };\n}\nfunction provideDisplayName(prefix, Component$$1) {\n  var componentName = Component$$1.displayName || Component$$1.name;\n  return componentName ? "".concat(prefix, "(").concat(componentName, ")") : prefix;\n}\nfunction getScrollAdjustedBoundingClientRect(node, scrollDelta) {\n  var boundingClientRect = node.getBoundingClientRect();\n  return {\n    top: boundingClientRect.top + scrollDelta.top,\n    left: boundingClientRect.left + scrollDelta.left\n  };\n}\nfunction getPosition(event) {\n  if (event.touches && event.touches.length) {\n    return {\n      x: event.touches[0].pageX,\n      y: event.touches[0].pageY\n    };\n  } else if (event.changedTouches && event.changedTouches.length) {\n    return {\n      x: event.changedTouches[0].pageX,\n      y: event.changedTouches[0].pageY\n    };\n  } else {\n    return {\n      x: event.pageX,\n      y: event.pageY\n    };\n  }\n}\nfunction isTouchEvent(event) {\n  return event.touches && event.touches.length || event.changedTouches && event.changedTouches.length;\n}\nfunction getEdgeOffset(node, parent) {\n  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    left: 0,\n    top: 0\n  };\n\n  if (!node) {\n    return undefined;\n  }\n\n  var nodeOffset = {\n    left: offset.left + node.offsetLeft,\n    top: offset.top + node.offsetTop\n  };\n\n  if (node.parentNode === parent) {\n    return nodeOffset;\n  }\n\n  return getEdgeOffset(node.parentNode, parent, nodeOffset);\n}\nfunction getTargetIndex(newIndex, prevIndex, oldIndex) {\n  if (newIndex < oldIndex && newIndex > prevIndex) {\n    return newIndex - 1;\n  } else if (newIndex > oldIndex && newIndex < prevIndex) {\n    return newIndex + 1;\n  } else {\n    return newIndex;\n  }\n}\nfunction getLockPixelOffset(_ref) {\n  var lockOffset = _ref.lockOffset,\n      width = _ref.width,\n      height = _ref.height;\n  var offsetX = lockOffset;\n  var offsetY = lockOffset;\n  var unit = \'px\';\n\n  if (typeof lockOffset === \'string\') {\n    var match = /^[+-]?\\d*(?:\\.\\d*)?(px|%)$/.exec(lockOffset);\n    browser_default()(match !== null, \'lockOffset value should be a number or a string of a \' + \'number followed by "px" or "%". Given %s\', lockOffset);\n    offsetX = parseFloat(lockOffset);\n    offsetY = parseFloat(lockOffset);\n    unit = match[1];\n  }\n\n  browser_default()(isFinite(offsetX) && isFinite(offsetY), \'lockOffset value should be a finite. Given %s\', lockOffset);\n\n  if (unit === \'%\') {\n    offsetX = offsetX * width / 100;\n    offsetY = offsetY * height / 100;\n  }\n\n  return {\n    x: offsetX,\n    y: offsetY\n  };\n}\nfunction getLockPixelOffsets(_ref2) {\n  var height = _ref2.height,\n      width = _ref2.width,\n      lockOffset = _ref2.lockOffset;\n  var offsets = Array.isArray(lockOffset) ? lockOffset : [lockOffset, lockOffset];\n  browser_default()(offsets.length === 2, \'lockOffset prop of SortableContainer should be a single \' + \'value or an array of exactly two values. Given %s\', lockOffset);\n\n  var _offsets = slicedToArray_slicedToArray(offsets, 2),\n      minLockOffset = _offsets[0],\n      maxLockOffset = _offsets[1];\n\n  return [getLockPixelOffset({\n    height: height,\n    lockOffset: minLockOffset,\n    width: width\n  }), getLockPixelOffset({\n    height: height,\n    lockOffset: maxLockOffset,\n    width: width\n  })];\n}\n\nfunction isScrollable(el) {\n  var computedStyle = window.getComputedStyle(el);\n  var overflowRegex = /(auto|scroll)/;\n  var properties = [\'overflow\', \'overflowX\', \'overflowY\'];\n  return properties.find(function (property) {\n    return overflowRegex.test(computedStyle[property]);\n  });\n}\n\nfunction getScrollingParent(el) {\n  if (!(el instanceof HTMLElement)) {\n    return null;\n  } else if (isScrollable(el)) {\n    return el;\n  } else {\n    return getScrollingParent(el.parentNode);\n  }\n}\nfunction getContainerGridGap(element) {\n  var style = window.getComputedStyle(element);\n\n  if (style.display === \'grid\') {\n    return {\n      x: getPixelValue(style.gridColumnGap),\n      y: getPixelValue(style.gridRowGap)\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0\n  };\n}\nvar KEYCODE = {\n  TAB: 9,\n  ESC: 27,\n  SPACE: 32,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40\n};\nvar NodeType = {\n  Anchor: \'A\',\n  Button: \'BUTTON\',\n  Canvas: \'CANVAS\',\n  Input: \'INPUT\',\n  Option: \'OPTION\',\n  Textarea: \'TEXTAREA\',\n  Select: \'SELECT\'\n};\nfunction cloneNode(node) {\n  var selector = \'input, textarea, select, canvas, [contenteditable]\';\n  var fields = node.querySelectorAll(selector);\n  var clonedNode = node.cloneNode(true);\n\n  var clonedFields = toConsumableArray_toConsumableArray(clonedNode.querySelectorAll(selector));\n\n  clonedFields.forEach(function (field, i) {\n    if (field.type !== \'file\') {\n      field.value = fields[i].value;\n    }\n\n    if (field.type === \'radio\' && field.name) {\n      field.name = "__sortableClone__".concat(field.name);\n    }\n\n    if (field.tagName === NodeType.Canvas && fields[i].width > 0 && fields[i].height > 0) {\n      var destCtx = field.getContext(\'2d\');\n      destCtx.drawImage(fields[i], 0, 0);\n    }\n  });\n  return clonedNode;\n}\n\nfunction sortableHandle(WrappedComponent) {\n  var _class, _temp;\n\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    withRef: false\n  };\n  return _temp = _class = function (_React$Component) {\n    inherits_inherits(WithSortableHandle, _React$Component);\n\n    function WithSortableHandle() {\n      classCallCheck_classCallCheck(this, WithSortableHandle);\n\n      return possibleConstructorReturn_possibleConstructorReturn(this, getPrototypeOf_getPrototypeOf(WithSortableHandle).apply(this, arguments));\n    }\n\n    createClass_createClass(WithSortableHandle, [{\n      key: "componentDidMount",\n      value: function componentDidMount() {\n        var node = (0,external_ReactDOM_namespaceObject.findDOMNode)(this);\n        node.sortableHandle = true;\n      }\n    }, {\n      key: "getWrappedInstance",\n      value: function getWrappedInstance() {\n        browser_default()(config.withRef, \'To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableHandle() call\');\n        return this.refs.wrappedInstance;\n      }\n    }, {\n      key: "render",\n      value: function render() {\n        var ref = config.withRef ? \'wrappedInstance\' : null;\n        return (0,external_React_.createElement)(WrappedComponent, extends_extends({\n          ref: ref\n        }, this.props));\n      }\n    }]);\n\n    return WithSortableHandle;\n  }(external_React_.Component), defineProperty_defineProperty(_class, "displayName", provideDisplayName(\'sortableHandle\', WrappedComponent)), _temp;\n}\nfunction isSortableHandle(node) {\n  return node.sortableHandle != null;\n}\n\nvar AutoScroller = function () {\n  function AutoScroller(container, onScrollCallback) {\n    classCallCheck_classCallCheck(this, AutoScroller);\n\n    this.container = container;\n    this.onScrollCallback = onScrollCallback;\n  }\n\n  createClass_createClass(AutoScroller, [{\n    key: "clear",\n    value: function clear() {\n      if (this.interval == null) {\n        return;\n      }\n\n      clearInterval(this.interval);\n      this.interval = null;\n    }\n  }, {\n    key: "update",\n    value: function update(_ref) {\n      var _this = this;\n\n      var translate = _ref.translate,\n          minTranslate = _ref.minTranslate,\n          maxTranslate = _ref.maxTranslate,\n          width = _ref.width,\n          height = _ref.height;\n      var direction = {\n        x: 0,\n        y: 0\n      };\n      var speed = {\n        x: 1,\n        y: 1\n      };\n      var acceleration = {\n        x: 10,\n        y: 10\n      };\n      var _this$container = this.container,\n          scrollTop = _this$container.scrollTop,\n          scrollLeft = _this$container.scrollLeft,\n          scrollHeight = _this$container.scrollHeight,\n          scrollWidth = _this$container.scrollWidth,\n          clientHeight = _this$container.clientHeight,\n          clientWidth = _this$container.clientWidth;\n      var isTop = scrollTop === 0;\n      var isBottom = scrollHeight - scrollTop - clientHeight === 0;\n      var isLeft = scrollLeft === 0;\n      var isRight = scrollWidth - scrollLeft - clientWidth === 0;\n\n      if (translate.y >= maxTranslate.y - height / 2 && !isBottom) {\n        direction.y = 1;\n        speed.y = acceleration.y * Math.abs((maxTranslate.y - height / 2 - translate.y) / height);\n      } else if (translate.x >= maxTranslate.x - width / 2 && !isRight) {\n        direction.x = 1;\n        speed.x = acceleration.x * Math.abs((maxTranslate.x - width / 2 - translate.x) / width);\n      } else if (translate.y <= minTranslate.y + height / 2 && !isTop) {\n        direction.y = -1;\n        speed.y = acceleration.y * Math.abs((translate.y - height / 2 - minTranslate.y) / height);\n      } else if (translate.x <= minTranslate.x + width / 2 && !isLeft) {\n        direction.x = -1;\n        speed.x = acceleration.x * Math.abs((translate.x - width / 2 - minTranslate.x) / width);\n      }\n\n      if (this.interval) {\n        this.clear();\n        this.isAutoScrolling = false;\n      }\n\n      if (direction.x !== 0 || direction.y !== 0) {\n        this.interval = setInterval(function () {\n          _this.isAutoScrolling = true;\n          var offset = {\n            left: speed.x * direction.x,\n            top: speed.y * direction.y\n          };\n          _this.container.scrollTop += offset.top;\n          _this.container.scrollLeft += offset.left;\n\n          _this.onScrollCallback(offset);\n        }, 5);\n      }\n    }\n  }]);\n\n  return AutoScroller;\n}();\n\nfunction defaultGetHelperDimensions(_ref) {\n  var node = _ref.node;\n  return {\n    height: node.offsetHeight,\n    width: node.offsetWidth\n  };\n}\n\nfunction defaultShouldCancelStart(event) {\n  var interactiveElements = [NodeType.Input, NodeType.Textarea, NodeType.Select, NodeType.Option, NodeType.Button];\n\n  if (interactiveElements.indexOf(event.target.tagName) !== -1) {\n    return true;\n  }\n\n  if (closest(event.target, function (el) {\n    return el.contentEditable === \'true\';\n  })) {\n    return true;\n  }\n\n  return false;\n}\n\nvar propTypes = {\n  axis: prop_types_default().oneOf([\'x\', \'y\', \'xy\']),\n  contentWindow: (prop_types_default()).any,\n  disableAutoscroll: (prop_types_default()).bool,\n  distance: (prop_types_default()).number,\n  getContainer: (prop_types_default()).func,\n  getHelperDimensions: (prop_types_default()).func,\n  helperClass: (prop_types_default()).string,\n  helperContainer: prop_types_default().oneOfType([(prop_types_default()).func, typeof HTMLElement === \'undefined\' ? (prop_types_default()).any : prop_types_default().instanceOf(HTMLElement)]),\n  hideSortableGhost: (prop_types_default()).bool,\n  keyboardSortingTransitionDuration: (prop_types_default()).number,\n  lockAxis: (prop_types_default()).string,\n  lockOffset: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string, prop_types_default().arrayOf(prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]))]),\n  lockToContainerEdges: (prop_types_default()).bool,\n  onSortEnd: (prop_types_default()).func,\n  onSortMove: (prop_types_default()).func,\n  onSortOver: (prop_types_default()).func,\n  onSortStart: (prop_types_default()).func,\n  pressDelay: (prop_types_default()).number,\n  pressThreshold: (prop_types_default()).number,\n  keyCodes: prop_types_default().shape({\n    lift: prop_types_default().arrayOf((prop_types_default()).number),\n    drop: prop_types_default().arrayOf((prop_types_default()).number),\n    cancel: prop_types_default().arrayOf((prop_types_default()).number),\n    up: prop_types_default().arrayOf((prop_types_default()).number),\n    down: prop_types_default().arrayOf((prop_types_default()).number)\n  }),\n  shouldCancelStart: (prop_types_default()).func,\n  transitionDuration: (prop_types_default()).number,\n  updateBeforeSortStart: (prop_types_default()).func,\n  useDragHandle: (prop_types_default()).bool,\n  useWindowAsScrollContainer: (prop_types_default()).bool\n};\nvar defaultKeyCodes = {\n  lift: [KEYCODE.SPACE],\n  drop: [KEYCODE.SPACE],\n  cancel: [KEYCODE.ESC],\n  up: [KEYCODE.UP, KEYCODE.LEFT],\n  down: [KEYCODE.DOWN, KEYCODE.RIGHT]\n};\nvar defaultProps = {\n  axis: \'y\',\n  disableAutoscroll: false,\n  distance: 0,\n  getHelperDimensions: defaultGetHelperDimensions,\n  hideSortableGhost: true,\n  lockOffset: \'50%\',\n  lockToContainerEdges: false,\n  pressDelay: 0,\n  pressThreshold: 5,\n  keyCodes: defaultKeyCodes,\n  shouldCancelStart: defaultShouldCancelStart,\n  transitionDuration: 300,\n  useWindowAsScrollContainer: false\n};\nvar omittedProps = Object.keys(propTypes);\nfunction validateProps(props) {\n  browser_default()(!(props.distance && props.pressDelay), \'Attempted to set both `pressDelay` and `distance` on SortableContainer, you may only use one or the other, not both at the same time.\');\n}\n\nfunction _finallyRethrows(body, finalizer) {\n  try {\n    var result = body();\n  } catch (e) {\n    return finalizer(true, e);\n  }\n\n  if (result && result.then) {\n    return result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n  }\n\n  return finalizer(false, value);\n}\nfunction sortableContainer(WrappedComponent) {\n  var _class, _temp;\n\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    withRef: false\n  };\n  return _temp = _class = function (_React$Component) {\n    inherits_inherits(WithSortableContainer, _React$Component);\n\n    function WithSortableContainer(props) {\n      var _this;\n\n      classCallCheck_classCallCheck(this, WithSortableContainer);\n\n      _this = possibleConstructorReturn_possibleConstructorReturn(this, getPrototypeOf_getPrototypeOf(WithSortableContainer).call(this, props));\n\n      defineProperty_defineProperty(assertThisInitialized_assertThisInitialized(assertThisInitialized_assertThisInitialized(_this)), "state", {});\n\n      defineProperty_defineProperty(assertThisInitialized_assertThisInitialized(assertThisInitialized_assertThisInitialized(_this)), "handleStart", function (event) {\n        var _this$props = _this.props,\n            distance = _this$props.distance,\n            shouldCancelStart = _this$props.shouldCancelStart;\n\n        if (event.button === 2 || shouldCancelStart(event)) {\n          return;\n        }\n\n        _this.touched = true;\n        _this.position = getPosition(event);\n        var node = closest(event.target, function (el) {\n          return el.sortableInfo != null;\n        });\n\n        if (node && node.sortableInfo && _this.nodeIsChild(node) && !_this.state.sorting) {\n          var useDragHandle = _this.props.useDragHandle;\n          var _node$sortableInfo = node.sortableInfo,\n              index = _node$sortableInfo.index,\n              collection = _node$sortableInfo.collection,\n              disabled = _node$sortableInfo.disabled;\n\n          if (disabled) {\n            return;\n          }\n\n          if (useDragHandle && !closest(event.target, isSortableHandle)) {\n            return;\n          }\n\n          _this.manager.active = {\n            collection: collection,\n            index: index\n          };\n\n          if (!isTouchEvent(event) && event.target.tagName === NodeType.Anchor) {\n            event.preventDefault();\n          }\n\n          if (!distance) {\n            if (_this.props.pressDelay === 0) {\n              _this.handlePress(event);\n            } else {\n              _this.pressTimer = setTimeout(function () {\n                return _this.handlePress(event);\n              }, _this.props.pressDelay);\n            }\n          }\n        }\n      });\n\n      defineProperty_defineProperty(assertThisInitialized_assertThisInitialized(assertThisInitialized_assertThisInitialized(_this)), "nodeIsChild", function (node) {\n        return node.sortableInfo.manager === _this.manager;\n      });\n\n      defineProperty_defineProperty(assertThisInitialized_assertThisInitialized(assertThisInitialized_assertThisInitialized(_this)), "handleMove", function (event) {\n        var _this$props2 = _this.props,\n            distance = _this$props2.distance,\n            pressThreshold = _this$props2.pressThreshold;\n\n        if (!_this.state.sorting && _this.touched && !_this._awaitingUpdateBeforeSortStart) {\n          var position = getPosition(event);\n          var delta = {\n            x: _this.position.x - position.x,\n            y: _this.position.y - position.y\n          };\n          var combinedDelta = Math.abs(delta.x) + Math.abs(delta.y);\n          _this.delta = delta;\n\n          if (!distance && (!pressThreshold || combinedDelta >= pressThreshold)) {\n            clearTimeout(_this.cancelTimer);\n            _this.cancelTimer = setTimeout(_this.cancel, 0);\n          } else if (distance && combinedDelta >= distance && _this.manager.isActive()) {\n            _this.handlePress(event);\n          }\n        }\n      });\n\n      defineProperty_defineProperty(assertThisInitialized_assertThisInitialized(assertThisInitialized_assertThisInitialized(_this)), "handleEnd", function () {\n        _this.touched = false;\n\n        _this.cancel();\n      });\n\n      defineProperty_defineProperty(assertThisInitialized_assertThisInitialized(assertThisInitialized_assertThisInitialized(_this)), "cancel", function () {\n        var distance = _this.props.distance;\n        var sorting = _this.state.sorting;\n\n        if (!sorting) {\n          if (!distance) {\n            clearTimeout(_this.pressTimer);\n          }\n\n          _this.manager.active = null;\n        }\n      });\n\n      defineProperty_defineProperty(assertThisInitialized_assertThisInitialized(assertThisInitialized_assertThisInitialized(_this)), "handlePress", function (event) {\n        try {\n          var active = _this.manager.getActive();\n\n          var _temp6 = function () {\n            if (active) {\n              var _temp7 = function _temp7() {\n                var index = _node.sortableInfo.index;\n                var margin = getElementMargin(_node);\n                var gridGap = getContainerGridGap(_this.container);\n\n                var containerBoundingRect = _this.scrollContainer.getBoundingClientRect();\n\n                var dimensions = _getHelperDimensions({\n                  index: index,\n                  node: _node,\n                  collection: _collection\n                });\n\n                _this.node = _node;\n                _this.margin = margin;\n                _this.gridGap = gridGap;\n                _this.width = dimensions.width;\n                _this.height = dimensions.height;\n                _this.marginOffset = {\n                  x: _this.margin.left + _this.margin.right + _this.gridGap.x,\n                  y: Math.max(_this.margin.top, _this.margin.bottom, _this.gridGap.y)\n                };\n                _this.boundingClientRect = _node.getBoundingClientRect();\n                _this.containerBoundingRect = containerBoundingRect;\n                _this.index = index;\n                _this.newIndex = index;\n                _this.axis = {\n                  x: _axis.indexOf(\'x\') >= 0,\n                  y: _axis.indexOf(\'y\') >= 0\n                };\n                _this.offsetEdge = getEdgeOffset(_node, _this.container);\n\n                if (_isKeySorting) {\n                  _this.initialOffset = getPosition(objectSpread_objectSpread({}, event, {\n                    pageX: _this.boundingClientRect.left,\n                    pageY: _this.boundingClientRect.top\n                  }));\n                } else {\n                  _this.initialOffset = getPosition(event);\n                }\n\n                _this.initialScroll = {\n                  left: _this.scrollContainer.scrollLeft,\n                  top: _this.scrollContainer.scrollTop\n                };\n                _this.initialWindowScroll = {\n                  left: window.pageXOffset,\n                  top: window.pageYOffset\n                };\n                _this.helper = _this.helperContainer.appendChild(cloneNode(_node));\n                setInlineStyles(_this.helper, {\n                  boxSizing: \'border-box\',\n                  height: "".concat(_this.height, "px"),\n                  left: "".concat(_this.boundingClientRect.left - margin.left, "px"),\n                  pointerEvents: \'none\',\n                  position: \'fixed\',\n                  top: "".concat(_this.boundingClientRect.top - margin.top, "px"),\n                  width: "".concat(_this.width, "px")\n                });\n\n                if (_isKeySorting) {\n                  _this.helper.focus();\n                }\n\n                if (_hideSortableGhost) {\n                  _this.sortableGhost = _node;\n                  setInlineStyles(_node, {\n                    opacity: 0,\n                    visibility: \'hidden\'\n                  });\n                }\n\n                _this.minTranslate = {};\n                _this.maxTranslate = {};\n\n                if (_isKeySorting) {\n                  var _ref = _useWindowAsScrollContainer ? {\n                    top: 0,\n                    left: 0,\n                    width: _this.contentWindow.innerWidth,\n                    height: _this.contentWindow.innerHeight\n                  } : _this.containerBoundingRect,\n                      containerTop = _ref.top,\n                      containerLeft = _ref.left,\n                      containerWidth = _ref.width,\n                      containerHeight = _ref.height;\n\n                  var containerBottom = containerTop + containerHeight;\n                  var containerRight = containerLeft + containerWidth;\n\n                  if (_this.axis.x) {\n                    _this.minTranslate.x = containerLeft - _this.boundingClientRect.left;\n                    _this.maxTranslate.x = containerRight - (_this.boundingClientRect.left + _this.width);\n                  }\n\n                  if (_this.axis.y) {\n                    _this.minTranslate.y = containerTop - _this.boundingClientRect.top;\n                    _this.maxTranslate.y = containerBottom - (_this.boundingClientRect.top + _this.height);\n                  }\n                } else {\n                  if (_this.axis.x) {\n                    _this.minTranslate.x = (_useWindowAsScrollContainer ? 0 : containerBoundingRect.left) - _this.boundingClientRect.left - _this.width / 2;\n                    _this.maxTranslate.x = (_useWindowAsScrollContainer ? _this.contentWindow.innerWidth : containerBoundingRect.left + containerBoundingRect.width) - _this.boundingClientRect.left - _this.width / 2;\n                  }\n\n                  if (_this.axis.y) {\n                    _this.minTranslate.y = (_useWindowAsScrollContainer ? 0 : containerBoundingRect.top) - _this.boundingClientRect.top - _this.height / 2;\n                    _this.maxTranslate.y = (_useWindowAsScrollContainer ? _this.contentWindow.innerHeight : containerBoundingRect.top + containerBoundingRect.height) - _this.boundingClientRect.top - _this.height / 2;\n                  }\n                }\n\n                if (_helperClass) {\n                  _helperClass.split(\' \').forEach(function (className) {\n                    return _this.helper.classList.add(className);\n                  });\n                }\n\n                _this.listenerNode = event.touches ? _node : _this.contentWindow;\n\n                if (_isKeySorting) {\n                  _this.listenerNode.addEventListener(\'wheel\', _this.handleKeyEnd, true);\n\n                  _this.listenerNode.addEventListener(\'mousedown\', _this.handleKeyEnd, true);\n\n                  _this.listenerNode.addEventListener(\'keydown\', _this.handleKeyDown);\n                } else {\n                  events.move.forEach(function (eventName) {\n                    return _this.listenerNode.addEventListener(eventName, _this.handleSortMove, false);\n                  });\n                  events.end.forEach(function (eventName) {\n                    return _this.listenerNode.addEventListener(eventName, _this.handleSortEnd, false);\n                  });\n                }\n\n                _this.setState({\n                  sorting: true,\n                  sortingIndex: index\n                });\n\n                if (_onSortStart) {\n                  _onSortStart({\n                    node: _node,\n                    index: index,\n                    collection: _collection,\n                    isKeySorting: _isKeySorting,\n                    nodes: _this.manager.getOrderedRefs(),\n                    helper: _this.helper\n                  }, event);\n                }\n\n                if (_isKeySorting) {\n                  _this.keyMove(0);\n                }\n              };\n\n              var _this$props3 = _this.props,\n                  _axis = _this$props3.axis,\n                  _getHelperDimensions = _this$props3.getHelperDimensions,\n                  _helperClass = _this$props3.helperClass,\n                  _hideSortableGhost = _this$props3.hideSortableGhost,\n                  updateBeforeSortStart = _this$props3.updateBeforeSortStart,\n                  _onSortStart = _this$props3.onSortStart,\n                  _useWindowAsScrollContainer = _this$props3.useWindowAsScrollContainer;\n              var _node = active.node,\n                  _collection = active.collection;\n              var _isKeySorting = _this.manager.isKeySorting;\n\n              var _temp8 = function () {\n                if (typeof updateBeforeSortStart === \'function\') {\n                  _this._awaitingUpdateBeforeSortStart = true;\n\n                  var _temp9 = _finallyRethrows(function () {\n                    var index = _node.sortableInfo.index;\n                    return Promise.resolve(updateBeforeSortStart({\n                      collection: _collection,\n                      index: index,\n                      node: _node,\n                      isKeySorting: _isKeySorting\n                    }, event)).then(function () {});\n                  }, function (_wasThrown, _result) {\n                    _this._awaitingUpdateBeforeSortStart = false;\n                    if (_wasThrown) throw _result;\n                    return _result;\n                  });\n\n                  if (_temp9 && _temp9.then) return _temp9.then(function () {});\n                }\n              }();\n\n              return _temp8 && _temp8.then ? _temp8.then(_temp7) : _temp7(_temp8);\n            }\n          }();\n\n          return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(function () {}) : void 0);\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      });\n\n      defineProperty_defineProperty(assertThisInitialized_assertThisInitialized(assertThisInitialized_assertThisInitialized(_this)), "handleSortMove", function (event) {\n        var onSortMove = _this.props.onSortMove;\n\n        if (typeof event.preventDefault === \'function\') {\n          event.preventDefault();\n        }\n\n        _this.updateHelperPosition(event);\n\n        _this.animateNodes();\n\n        _this.autoscroll();\n\n        if (onSortMove) {\n          onSortMove(event);\n        }\n      });\n\n      defineProperty_defineProperty(assertThisInitialized_assertThisInitialized(assertThisInitialized_assertThisInitialized(_this)), "handleSortEnd", function (event) {\n        var _this$props4 = _this.props,\n            hideSortableGhost = _this$props4.hideSortableGhost,\n            onSortEnd = _this$props4.onSortEnd;\n        var _this$manager = _this.manager,\n            collection = _this$manager.active.collection,\n            isKeySorting = _this$manager.isKeySorting;\n\n        var nodes = _this.manager.getOrderedRefs();\n\n        if (_this.listenerNode) {\n          if (isKeySorting) {\n            _this.listenerNode.removeEventListener(\'wheel\', _this.handleKeyEnd, true);\n\n            _this.listenerNode.removeEventListener(\'mousedown\', _this.handleKeyEnd, true);\n\n            _this.listenerNode.removeEventListener(\'keydown\', _this.handleKeyDown);\n          } else {\n            events.move.forEach(function (eventName) {\n              return _this.listenerNode.removeEventListener(eventName, _this.handleSortMove);\n            });\n            events.end.forEach(function (eventName) {\n              return _this.listenerNode.removeEventListener(eventName, _this.handleSortEnd);\n            });\n          }\n        }\n\n        _this.helper.parentNode.removeChild(_this.helper);\n\n        if (hideSortableGhost && _this.sortableGhost) {\n          setInlineStyles(_this.sortableGhost, {\n            opacity: \'\',\n            visibility: \'\'\n          });\n        }\n\n        for (var i = 0, len = nodes.length; i < len; i++) {\n          var _node2 = nodes[i];\n          var el = _node2.node;\n          _node2.edgeOffset = null;\n          _node2.boundingClientRect = null;\n          setTranslate3d(el, null);\n          setTransitionDuration(el, null);\n          _node2.translate = null;\n        }\n\n        _this.autoScroller.clear();\n\n        _this.manager.active = null;\n        _this.manager.isKeySorting = false;\n\n        _this.setState({\n          sorting: false,\n          sortingIndex: null\n        });\n\n        if (typeof onSortEnd === \'function\') {\n          onSortEnd({\n            collection: collection,\n            newIndex: _this.newIndex,\n            oldIndex: _this.index,\n            isKeySorting: isKeySorting,\n            nodes: nodes\n          }, event);\n        }\n\n        _this.touched = false;\n      });\n\n      defineProperty_defineProperty(assertThisInitialized_assertThisInitialized(assertThisInitialized_assertThisInitialized(_this)), "autoscroll", function () {\n        var disableAutoscroll = _this.props.disableAutoscroll;\n        var isKeySorting = _this.manager.isKeySorting;\n\n        if (disableAutoscroll) {\n          _this.autoScroller.clear();\n\n          return;\n        }\n\n        if (isKeySorting) {\n          var translate = objectSpread_objectSpread({}, _this.translate);\n\n          var scrollX = 0;\n          var scrollY = 0;\n\n          if (_this.axis.x) {\n            translate.x = Math.min(_this.maxTranslate.x, Math.max(_this.minTranslate.x, _this.translate.x));\n            scrollX = _this.translate.x - translate.x;\n          }\n\n          if (_this.axis.y) {\n            translate.y = Math.min(_this.maxTranslate.y, Math.max(_this.minTranslate.y, _this.translate.y));\n            scrollY = _this.translate.y - translate.y;\n          }\n\n          _this.translate = translate;\n          setTranslate3d(_this.helper, _this.translate);\n          _this.scrollContainer.scrollLeft += scrollX;\n          _this.scrollContainer.scrollTop += scrollY;\n          return;\n        }\n\n        _this.autoScroller.update({\n          height: _this.height,\n          maxTranslate: _this.maxTranslate,\n          minTranslate: _this.minTranslate,\n          translate: _this.translate,\n          width: _this.width\n        });\n      });\n\n      defineProperty_defineProperty(assertThisInitialized_assertThisInitialized(assertThisInitialized_assertThisInitialized(_this)), "onAutoScroll", function (offset) {\n        _this.translate.x += offset.left;\n        _this.translate.y += offset.top;\n\n        _this.animateNodes();\n      });\n\n      defineProperty_defineProperty(assertThisInitialized_assertThisInitialized(assertThisInitialized_assertThisInitialized(_this)), "handleKeyDown", function (event) {\n        var keyCode = event.keyCode;\n        var _this$props5 = _this.props,\n            shouldCancelStart = _this$props5.shouldCancelStart,\n            _this$props5$keyCodes = _this$props5.keyCodes,\n            customKeyCodes = _this$props5$keyCodes === void 0 ? {} : _this$props5$keyCodes;\n\n        var keyCodes = objectSpread_objectSpread({}, defaultKeyCodes, customKeyCodes);\n\n        if (_this.manager.active && !_this.manager.isKeySorting || !_this.manager.active && (!keyCodes.lift.includes(keyCode) || shouldCancelStart(event) || !_this.isValidSortingTarget(event))) {\n          return;\n        }\n\n        event.stopPropagation();\n        event.preventDefault();\n\n        if (keyCodes.lift.includes(keyCode) && !_this.manager.active) {\n          _this.keyLift(event);\n        } else if (keyCodes.drop.includes(keyCode) && _this.manager.active) {\n          _this.keyDrop(event);\n        } else if (keyCodes.cancel.includes(keyCode)) {\n          _this.newIndex = _this.manager.active.index;\n\n          _this.keyDrop(event);\n        } else if (keyCodes.up.includes(keyCode)) {\n          _this.keyMove(-1);\n        } else if (keyCodes.down.includes(keyCode)) {\n          _this.keyMove(1);\n        }\n      });\n\n      defineProperty_defineProperty(assertThisInitialized_assertThisInitialized(assertThisInitialized_assertThisInitialized(_this)), "keyLift", function (event) {\n        var target = event.target;\n        var node = closest(target, function (el) {\n          return el.sortableInfo != null;\n        });\n        var _node$sortableInfo2 = node.sortableInfo,\n            index = _node$sortableInfo2.index,\n            collection = _node$sortableInfo2.collection;\n        _this.initialFocusedNode = target;\n        _this.manager.isKeySorting = true;\n        _this.manager.active = {\n          index: index,\n          collection: collection\n        };\n\n        _this.handlePress(event);\n      });\n\n      defineProperty_defineProperty(assertThisInitialized_assertThisInitialized(assertThisInitialized_assertThisInitialized(_this)), "keyMove", function (shift) {\n        var nodes = _this.manager.getOrderedRefs();\n\n        var lastIndex = nodes[nodes.length - 1].node.sortableInfo.index;\n        var newIndex = _this.newIndex + shift;\n        var prevIndex = _this.newIndex;\n\n        if (newIndex < 0 || newIndex > lastIndex) {\n          return;\n        }\n\n        _this.prevIndex = prevIndex;\n        _this.newIndex = newIndex;\n        var targetIndex = getTargetIndex(_this.newIndex, _this.prevIndex, _this.index);\n        var target = nodes.find(function (_ref2) {\n          var node = _ref2.node;\n          return node.sortableInfo.index === targetIndex;\n        });\n        var targetNode = target.node;\n        var scrollDelta = _this.containerScrollDelta;\n        var targetBoundingClientRect = target.boundingClientRect || getScrollAdjustedBoundingClientRect(targetNode, scrollDelta);\n        var targetTranslate = target.translate || {\n          x: 0,\n          y: 0\n        };\n        var targetPosition = {\n          top: targetBoundingClientRect.top + targetTranslate.y - scrollDelta.top,\n          left: targetBoundingClientRect.left + targetTranslate.x - scrollDelta.left\n        };\n        var shouldAdjustForSize = prevIndex < newIndex;\n        var sizeAdjustment = {\n          x: shouldAdjustForSize && _this.axis.x ? targetNode.offsetWidth - _this.width : 0,\n          y: shouldAdjustForSize && _this.axis.y ? targetNode.offsetHeight - _this.height : 0\n        };\n\n        _this.handleSortMove({\n          pageX: targetPosition.left + sizeAdjustment.x,\n          pageY: targetPosition.top + sizeAdjustment.y,\n          ignoreTransition: shift === 0\n        });\n      });\n\n      defineProperty_defineProperty(assertThisInitialized_assertThisInitialized(assertThisInitialized_assertThisInitialized(_this)), "keyDrop", function (event) {\n        _this.handleSortEnd(event);\n\n        if (_this.initialFocusedNode) {\n          _this.initialFocusedNode.focus();\n        }\n      });\n\n      defineProperty_defineProperty(assertThisInitialized_assertThisInitialized(assertThisInitialized_assertThisInitialized(_this)), "handleKeyEnd", function (event) {\n        if (_this.manager.active) {\n          _this.keyDrop(event);\n        }\n      });\n\n      defineProperty_defineProperty(assertThisInitialized_assertThisInitialized(assertThisInitialized_assertThisInitialized(_this)), "isValidSortingTarget", function (event) {\n        var useDragHandle = _this.props.useDragHandle;\n        var target = event.target;\n        var node = closest(target, function (el) {\n          return el.sortableInfo != null;\n        });\n        return node && node.sortableInfo && !node.sortableInfo.disabled && (useDragHandle ? isSortableHandle(target) : target.sortableInfo);\n      });\n\n      validateProps(props);\n      _this.manager = new Manager();\n      _this.events = {\n        end: _this.handleEnd,\n        move: _this.handleMove,\n        start: _this.handleStart\n      };\n      return _this;\n    }\n\n    createClass_createClass(WithSortableContainer, [{\n      key: "getChildContext",\n      value: function getChildContext() {\n        return {\n          manager: this.manager\n        };\n      }\n    }, {\n      key: "componentDidMount",\n      value: function componentDidMount() {\n        var _this2 = this;\n\n        var useWindowAsScrollContainer = this.props.useWindowAsScrollContainer;\n        var container = this.getContainer();\n        Promise.resolve(container).then(function (containerNode) {\n          _this2.container = containerNode;\n          _this2.document = _this2.container.ownerDocument || document;\n          var contentWindow = _this2.props.contentWindow || _this2.document.defaultView || window;\n          _this2.contentWindow = typeof contentWindow === \'function\' ? contentWindow() : contentWindow;\n          _this2.scrollContainer = useWindowAsScrollContainer ? _this2.document.scrollingElement || _this2.document.documentElement : getScrollingParent(_this2.container) || _this2.container;\n          _this2.autoScroller = new AutoScroller(_this2.scrollContainer, _this2.onAutoScroll);\n          Object.keys(_this2.events).forEach(function (key) {\n            return events[key].forEach(function (eventName) {\n              return _this2.container.addEventListener(eventName, _this2.events[key], false);\n            });\n          });\n\n          _this2.container.addEventListener(\'keydown\', _this2.handleKeyDown);\n        });\n      }\n    }, {\n      key: "componentWillUnmount",\n      value: function componentWillUnmount() {\n        var _this3 = this;\n\n        if (this.helper && this.helper.parentNode) {\n          this.helper.parentNode.removeChild(this.helper);\n        }\n\n        if (!this.container) {\n          return;\n        }\n\n        Object.keys(this.events).forEach(function (key) {\n          return events[key].forEach(function (eventName) {\n            return _this3.container.removeEventListener(eventName, _this3.events[key]);\n          });\n        });\n        this.container.removeEventListener(\'keydown\', this.handleKeyDown);\n      }\n    }, {\n      key: "updateHelperPosition",\n      value: function updateHelperPosition(event) {\n        var _this$props6 = this.props,\n            lockAxis = _this$props6.lockAxis,\n            lockOffset = _this$props6.lockOffset,\n            lockToContainerEdges = _this$props6.lockToContainerEdges,\n            transitionDuration = _this$props6.transitionDuration,\n            _this$props6$keyboard = _this$props6.keyboardSortingTransitionDuration,\n            keyboardSortingTransitionDuration = _this$props6$keyboard === void 0 ? transitionDuration : _this$props6$keyboard;\n        var isKeySorting = this.manager.isKeySorting;\n        var ignoreTransition = event.ignoreTransition;\n        var offset = getPosition(event);\n        var translate = {\n          x: offset.x - this.initialOffset.x,\n          y: offset.y - this.initialOffset.y\n        };\n        translate.y -= window.pageYOffset - this.initialWindowScroll.top;\n        translate.x -= window.pageXOffset - this.initialWindowScroll.left;\n        this.translate = translate;\n\n        if (lockToContainerEdges) {\n          var _getLockPixelOffsets = getLockPixelOffsets({\n            height: this.height,\n            lockOffset: lockOffset,\n            width: this.width\n          }),\n              _getLockPixelOffsets2 = slicedToArray_slicedToArray(_getLockPixelOffsets, 2),\n              minLockOffset = _getLockPixelOffsets2[0],\n              maxLockOffset = _getLockPixelOffsets2[1];\n\n          var minOffset = {\n            x: this.width / 2 - minLockOffset.x,\n            y: this.height / 2 - minLockOffset.y\n          };\n          var maxOffset = {\n            x: this.width / 2 - maxLockOffset.x,\n            y: this.height / 2 - maxLockOffset.y\n          };\n          translate.x = limit(this.minTranslate.x + minOffset.x, this.maxTranslate.x - maxOffset.x, translate.x);\n          translate.y = limit(this.minTranslate.y + minOffset.y, this.maxTranslate.y - maxOffset.y, translate.y);\n        }\n\n        if (lockAxis === \'x\') {\n          translate.y = 0;\n        } else if (lockAxis === \'y\') {\n          translate.x = 0;\n        }\n\n        if (isKeySorting && keyboardSortingTransitionDuration && !ignoreTransition) {\n          setTransitionDuration(this.helper, keyboardSortingTransitionDuration);\n        }\n\n        setTranslate3d(this.helper, translate);\n      }\n    }, {\n      key: "animateNodes",\n      value: function animateNodes() {\n        var _this$props7 = this.props,\n            transitionDuration = _this$props7.transitionDuration,\n            hideSortableGhost = _this$props7.hideSortableGhost,\n            onSortOver = _this$props7.onSortOver;\n        var containerScrollDelta = this.containerScrollDelta,\n            windowScrollDelta = this.windowScrollDelta;\n        var nodes = this.manager.getOrderedRefs();\n        var sortingOffset = {\n          left: this.offsetEdge.left + this.translate.x + containerScrollDelta.left,\n          top: this.offsetEdge.top + this.translate.y + containerScrollDelta.top\n        };\n        var isKeySorting = this.manager.isKeySorting;\n        var prevIndex = this.newIndex;\n        this.newIndex = null;\n\n        for (var i = 0, len = nodes.length; i < len; i++) {\n          var _node3 = nodes[i].node;\n          var index = _node3.sortableInfo.index;\n          var width = _node3.offsetWidth;\n          var height = _node3.offsetHeight;\n          var offset = {\n            height: this.height > height ? height / 2 : this.height / 2,\n            width: this.width > width ? width / 2 : this.width / 2\n          };\n          var mustShiftBackward = isKeySorting && index > this.index && index <= prevIndex;\n          var mustShiftForward = isKeySorting && index < this.index && index >= prevIndex;\n          var translate = {\n            x: 0,\n            y: 0\n          };\n          var edgeOffset = nodes[i].edgeOffset;\n\n          if (!edgeOffset) {\n            edgeOffset = getEdgeOffset(_node3, this.container);\n            nodes[i].edgeOffset = edgeOffset;\n\n            if (isKeySorting) {\n              nodes[i].boundingClientRect = getScrollAdjustedBoundingClientRect(_node3, containerScrollDelta);\n            }\n          }\n\n          var nextNode = i < nodes.length - 1 && nodes[i + 1];\n          var prevNode = i > 0 && nodes[i - 1];\n\n          if (nextNode && !nextNode.edgeOffset) {\n            nextNode.edgeOffset = getEdgeOffset(nextNode.node, this.container);\n\n            if (isKeySorting) {\n              nextNode.boundingClientRect = getScrollAdjustedBoundingClientRect(nextNode.node, containerScrollDelta);\n            }\n          }\n\n          if (index === this.index) {\n            if (hideSortableGhost) {\n              this.sortableGhost = _node3;\n              setInlineStyles(_node3, {\n                opacity: 0,\n                visibility: \'hidden\'\n              });\n            }\n\n            continue;\n          }\n\n          if (transitionDuration) {\n            setTransitionDuration(_node3, transitionDuration);\n          }\n\n          if (this.axis.x) {\n            if (this.axis.y) {\n              if (mustShiftForward || index < this.index && (sortingOffset.left + windowScrollDelta.left - offset.width <= edgeOffset.left && sortingOffset.top + windowScrollDelta.top <= edgeOffset.top + offset.height || sortingOffset.top + windowScrollDelta.top + offset.height <= edgeOffset.top)) {\n                translate.x = this.width + this.marginOffset.x;\n\n                if (edgeOffset.left + translate.x > this.containerBoundingRect.width - offset.width) {\n                  if (nextNode) {\n                    translate.x = nextNode.edgeOffset.left - edgeOffset.left;\n                    translate.y = nextNode.edgeOffset.top - edgeOffset.top;\n                  }\n                }\n\n                if (this.newIndex === null) {\n                  this.newIndex = index;\n                }\n              } else if (mustShiftBackward || index > this.index && (sortingOffset.left + windowScrollDelta.left + offset.width >= edgeOffset.left && sortingOffset.top + windowScrollDelta.top + offset.height >= edgeOffset.top || sortingOffset.top + windowScrollDelta.top + offset.height >= edgeOffset.top + height)) {\n                translate.x = -(this.width + this.marginOffset.x);\n\n                if (edgeOffset.left + translate.x < this.containerBoundingRect.left + offset.width) {\n                  if (prevNode) {\n                    translate.x = prevNode.edgeOffset.left - edgeOffset.left;\n                    translate.y = prevNode.edgeOffset.top - edgeOffset.top;\n                  }\n                }\n\n                this.newIndex = index;\n              }\n            } else {\n              if (mustShiftBackward || index > this.index && sortingOffset.left + windowScrollDelta.left + offset.width >= edgeOffset.left) {\n                translate.x = -(this.width + this.marginOffset.x);\n                this.newIndex = index;\n              } else if (mustShiftForward || index < this.index && sortingOffset.left + windowScrollDelta.left <= edgeOffset.left + offset.width) {\n                translate.x = this.width + this.marginOffset.x;\n\n                if (this.newIndex == null) {\n                  this.newIndex = index;\n                }\n              }\n            }\n          } else if (this.axis.y) {\n            if (mustShiftBackward || index > this.index && sortingOffset.top + windowScrollDelta.top + offset.height >= edgeOffset.top) {\n              translate.y = -(this.height + this.marginOffset.y);\n              this.newIndex = index;\n            } else if (mustShiftForward || index < this.index && sortingOffset.top + windowScrollDelta.top <= edgeOffset.top + offset.height) {\n              translate.y = this.height + this.marginOffset.y;\n\n              if (this.newIndex == null) {\n                this.newIndex = index;\n              }\n            }\n          }\n\n          setTranslate3d(_node3, translate);\n          nodes[i].translate = translate;\n        }\n\n        if (this.newIndex == null) {\n          this.newIndex = this.index;\n        }\n\n        if (isKeySorting) {\n          this.newIndex = prevIndex;\n        }\n\n        var oldIndex = isKeySorting ? this.prevIndex : prevIndex;\n\n        if (onSortOver && this.newIndex !== oldIndex) {\n          onSortOver({\n            collection: this.manager.active.collection,\n            index: this.index,\n            newIndex: this.newIndex,\n            oldIndex: oldIndex,\n            isKeySorting: isKeySorting,\n            nodes: nodes,\n            helper: this.helper\n          });\n        }\n      }\n    }, {\n      key: "getWrappedInstance",\n      value: function getWrappedInstance() {\n        browser_default()(config.withRef, \'To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableContainer() call\');\n        return this.refs.wrappedInstance;\n      }\n    }, {\n      key: "getContainer",\n      value: function getContainer() {\n        var getContainer = this.props.getContainer;\n\n        if (typeof getContainer !== \'function\') {\n          return (0,external_ReactDOM_namespaceObject.findDOMNode)(this);\n        }\n\n        return getContainer(config.withRef ? this.getWrappedInstance() : undefined);\n      }\n    }, {\n      key: "render",\n      value: function render() {\n        var ref = config.withRef ? \'wrappedInstance\' : null;\n        return (0,external_React_.createElement)(WrappedComponent, extends_extends({\n          ref: ref\n        }, omit(this.props, omittedProps)));\n      }\n    }, {\n      key: "helperContainer",\n      get: function get() {\n        var helperContainer = this.props.helperContainer;\n\n        if (typeof helperContainer === \'function\') {\n          return helperContainer();\n        }\n\n        return this.props.helperContainer || this.document.body;\n      }\n    }, {\n      key: "containerScrollDelta",\n      get: function get() {\n        var useWindowAsScrollContainer = this.props.useWindowAsScrollContainer;\n\n        if (useWindowAsScrollContainer) {\n          return {\n            left: 0,\n            top: 0\n          };\n        }\n\n        return {\n          left: this.scrollContainer.scrollLeft - this.initialScroll.left,\n          top: this.scrollContainer.scrollTop - this.initialScroll.top\n        };\n      }\n    }, {\n      key: "windowScrollDelta",\n      get: function get() {\n        return {\n          left: this.contentWindow.pageXOffset - this.initialWindowScroll.left,\n          top: this.contentWindow.pageYOffset - this.initialWindowScroll.top\n        };\n      }\n    }]);\n\n    return WithSortableContainer;\n  }(external_React_.Component), defineProperty_defineProperty(_class, "displayName", provideDisplayName(\'sortableList\', WrappedComponent)), defineProperty_defineProperty(_class, "defaultProps", defaultProps), defineProperty_defineProperty(_class, "propTypes", propTypes), defineProperty_defineProperty(_class, "childContextTypes", {\n    manager: (prop_types_default()).object.isRequired\n  }), _temp;\n}\n\nvar propTypes$1 = {\n  index: (prop_types_default()).number.isRequired,\n  collection: prop_types_default().oneOfType([(prop_types_default()).number, (prop_types_default()).string]),\n  disabled: (prop_types_default()).bool\n};\nvar omittedProps$1 = Object.keys(propTypes$1);\nfunction sortableElement(WrappedComponent) {\n  var _class, _temp;\n\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    withRef: false\n  };\n  return _temp = _class = function (_React$Component) {\n    inherits_inherits(WithSortableElement, _React$Component);\n\n    function WithSortableElement() {\n      classCallCheck_classCallCheck(this, WithSortableElement);\n\n      return possibleConstructorReturn_possibleConstructorReturn(this, getPrototypeOf_getPrototypeOf(WithSortableElement).apply(this, arguments));\n    }\n\n    createClass_createClass(WithSortableElement, [{\n      key: "componentDidMount",\n      value: function componentDidMount() {\n        this.register();\n      }\n    }, {\n      key: "componentDidUpdate",\n      value: function componentDidUpdate(prevProps) {\n        if (this.node) {\n          if (prevProps.index !== this.props.index) {\n            this.node.sortableInfo.index = this.props.index;\n          }\n\n          if (prevProps.disabled !== this.props.disabled) {\n            this.node.sortableInfo.disabled = this.props.disabled;\n          }\n        }\n\n        if (prevProps.collection !== this.props.collection) {\n          this.unregister(prevProps.collection);\n          this.register();\n        }\n      }\n    }, {\n      key: "componentWillUnmount",\n      value: function componentWillUnmount() {\n        this.unregister();\n      }\n    }, {\n      key: "register",\n      value: function register() {\n        var _this$props = this.props,\n            collection = _this$props.collection,\n            disabled = _this$props.disabled,\n            index = _this$props.index;\n        var node = (0,external_ReactDOM_namespaceObject.findDOMNode)(this);\n        node.sortableInfo = {\n          collection: collection,\n          disabled: disabled,\n          index: index,\n          manager: this.context.manager\n        };\n        this.node = node;\n        this.ref = {\n          node: node\n        };\n        this.context.manager.add(collection, this.ref);\n      }\n    }, {\n      key: "unregister",\n      value: function unregister() {\n        var collection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.collection;\n        this.context.manager.remove(collection, this.ref);\n      }\n    }, {\n      key: "getWrappedInstance",\n      value: function getWrappedInstance() {\n        browser_default()(config.withRef, \'To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableElement() call\');\n        return this.refs.wrappedInstance;\n      }\n    }, {\n      key: "render",\n      value: function render() {\n        var ref = config.withRef ? \'wrappedInstance\' : null;\n        return (0,external_React_.createElement)(WrappedComponent, extends_extends({\n          ref: ref\n        }, omit(this.props, omittedProps$1)));\n      }\n    }]);\n\n    return WithSortableElement;\n  }(external_React_.Component), defineProperty_defineProperty(_class, "displayName", provideDisplayName(\'sortableElement\', WrappedComponent)), defineProperty_defineProperty(_class, "contextTypes", {\n    manager: (prop_types_default()).object.isRequired\n  }), defineProperty_defineProperty(_class, "propTypes", propTypes$1), defineProperty_defineProperty(_class, "defaultProps", {\n    collection: 0\n  }), _temp;\n}\n\n\n\n// EXTERNAL MODULE: ../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js!../../../../gutenberg/src/components/rb-sortable-list/style.css\nvar rb_sortable_list_style = __webpack_require__(825);\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/rb-sortable-list/style.css\n\n            \n\nvar rb_sortable_list_style_options = {};\n\nrb_sortable_list_style_options.insert = "head";\nrb_sortable_list_style_options.singleton = false;\n\nvar rb_sortable_list_style_update = injectStylesIntoStyleTag_default()(rb_sortable_list_style/* default */.Z, rb_sortable_list_style_options);\n\n\n\n/* harmony default export */ const components_rb_sortable_list_style = (rb_sortable_list_style/* default.locals */.Z.locals || {});\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/rb-sortable-list/rb-sortable-list.js\nfunction rb_sortable_list_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rb_sortable_list_typeof = function _typeof(obj) { return typeof obj; }; } else { rb_sortable_list_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rb_sortable_list_typeof(obj); }\n\nfunction rb_sortable_list_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rb_sortable_list_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rb_sortable_list_createClass(Constructor, protoProps, staticProps) { if (protoProps) rb_sortable_list_defineProperties(Constructor.prototype, protoProps); if (staticProps) rb_sortable_list_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rb_sortable_list_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rb_sortable_list_setPrototypeOf(subClass, superClass); }\n\nfunction rb_sortable_list_setPrototypeOf(o, p) { rb_sortable_list_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rb_sortable_list_setPrototypeOf(o, p); }\n\nfunction rb_sortable_list_createSuper(Derived) { var hasNativeReflectConstruct = rb_sortable_list_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rb_sortable_list_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rb_sortable_list_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rb_sortable_list_possibleConstructorReturn(this, result); }; }\n\nfunction rb_sortable_list_possibleConstructorReturn(self, call) { if (call && (rb_sortable_list_typeof(call) === "object" || typeof call === "function")) { return call; } return rb_sortable_list_assertThisInitialized(self); }\n\nfunction rb_sortable_list_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction rb_sortable_list_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction rb_sortable_list_getPrototypeOf(o) { rb_sortable_list_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rb_sortable_list_getPrototypeOf(o); }\n\nvar rb_sortable_list_ = wp.i18n.__; // Import __() from wp.i18n\n\nvar rb_sortable_list_wp$element = wp.element,\n    rb_sortable_list_Component = rb_sortable_list_wp$element.Component,\n    Fragment = rb_sortable_list_wp$element.Fragment,\n    createRef = rb_sortable_list_wp$element.createRef;\nvar rb_sortable_list_Dashicon = wp.components.Dashicon;\n\n\n\n\nvar Handle = sortableHandle(function () {\n  return /*#__PURE__*/React.createElement("div", {\n    className: "item-handle"\n  }, /*#__PURE__*/React.createElement("div", {\n    className: "icon"\n  }, /*#__PURE__*/React.createElement(rb_sortable_list_Dashicon, {\n    icon: "move",\n    label: "Move"\n  })));\n}); //Sortable list of items\n\nvar RBSortableList = /*#__PURE__*/function (_Component) {\n  rb_sortable_list_inherits(RBSortableList, _Component);\n\n  var _super = rb_sortable_list_createSuper(RBSortableList);\n\n  function RBSortableList(props) {\n    var _this;\n\n    rb_sortable_list_classCallCheck(this, RBSortableList);\n\n    _this = _super.call(this, props);\n    _this.containerRef = createRef();\n    return _this;\n  }\n  /**\r\n  *   Runs the \'onSortEnd\' prop, providing data on the new items order\r\n  *   @param {int} oldIndex                               Old index of the item that was moved\r\n  *   @param {int} newIndex                               New index of the item that was moved\r\n  */\n\n\n  rb_sortable_list_createClass(RBSortableList, [{\n    key: "onSortEnd",\n    value: function onSortEnd(_ref) {\n      var oldIndex = _ref.oldIndex,\n          newIndex = _ref.newIndex;\n\n      if (this.props.onSortEnd) {\n        this.props.onSortEnd({\n          oldIndex: oldIndex,\n          newIndex: newIndex,\n          newList: array_move_default()(this.props.items, oldIndex, newIndex)\n        });\n      }\n    }\n    /**\r\n    *   Function that transform the list into a sortable list\r\n    *   @param {jsx} list                                   The list jsx\r\n    */\n\n  }, {\n    key: "composeListWithSortableContainer",\n    value: function composeListWithSortableContainer(_ref2) {\n      var _this2 = this;\n\n      var list = _ref2.list;\n      var SortableList = sortableContainer(function (_ref3) {\n        var items = _ref3.items;\n        return list;\n      });\n      return /*#__PURE__*/React.createElement(SortableList, {\n        onSortEnd: function onSortEnd(data) {\n          return _this2.onSortEnd(data);\n        },\n        helperContainer: this.containerRef.current,\n        helperClass: "helper-item",\n        useDragHandle: this.props.useDragHandle\n      });\n    }\n    /**\r\n    *   Function that transforms an item row element into a sortable element\r\n    *   @param {mixed} item                                 Item data\r\n    *   @param {jsx} rowElement                             Item row element\r\n    *   @param {int} index                                  Item index\r\n    */\n\n  }, {\n    key: "composeRowWithSortableElement",\n    value: function composeRowWithSortableElement(_ref4) {\n      var item = _ref4.item,\n          rowElement = _ref4.rowElement,\n          index = _ref4.index;\n      var SortableItem = sortableElement(function (_ref5) {\n        var value = _ref5.value;\n        return rowElement;\n      });\n      return /*#__PURE__*/React.createElement(SortableItem, {\n        key: item.id,\n        index: index\n      });\n    }\n    /**\r\n    *   Adds a sortable handle to the list item content element\r\n    *   @param {mixed} item                                 Item data\r\n    *   @param {jsx} itemContentElement                     Item element\r\n    */\n\n  }, {\n    key: "addSortableHandle",\n    value: function addSortableHandle(_ref6) {\n      var item = _ref6.item,\n          itemContentElement = _ref6.itemContentElement;\n      return /*#__PURE__*/React.createElement(Fragment, null, this.props.useDragHandle && /*#__PURE__*/React.createElement(Handle, null), itemContentElement);\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _this3 = this;\n\n      return /*#__PURE__*/React.createElement(RBList, {\n        containerRef: this.containerRef,\n        className: "rb-sortable-list-container ".concat(this.props.className),\n        items: this.props.items,\n        getItemData: function getItemData(item) {\n          return _this3.props.getItemData(item);\n        },\n        filterList: function filterList(args) {\n          return _this3.composeListWithSortableContainer(args);\n        },\n        filterRow: function filterRow(args) {\n          return _this3.composeRowWithSortableElement(args);\n        },\n        filterItemContent: function filterItemContent(args) {\n          return _this3.addSortableHandle(args);\n        }\n      });\n    }\n  }]);\n\n  return RBSortableList;\n}(rb_sortable_list_Component);\n\nRBSortableList.defaultProps = {\n  // Check RBList for this property documentation\n  items: [],\n  // Check RBList for this property documentation\n  getItemData: null,\n\n  /**\r\n  *   @property {bool}    useDragHandle\r\n  *   Indicates if there should be a handler from wich the items will be moved.\r\n  *   If not, the whole item container will be draggable\r\n  */\n  useDragHandle: true,\n\n  /**\r\n  *   @property {function}    onSortEnd\r\n  *   Function to be runned when sorting ends\r\n  *       @param {object}           data                Information about the new items order\r\n  *           @property {int}         oldIndex            Old index of the item that was moved\r\n  *           @property {int}         newIndex            New index of the item that was moved\r\n  *           @property {int}         newList             A new array with the items reordered\r\n  */\n  onSortEnd: null,\n  // Check RBList for this property documentation\n  className: \'\'\n};\n\n// EXTERNAL MODULE: ../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js!../../../../gutenberg/src/components/rb-row-actions/style.css\nvar rb_row_actions_style = __webpack_require__(250);\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/rb-row-actions/style.css\n\n            \n\nvar rb_row_actions_style_options = {};\n\nrb_row_actions_style_options.insert = "head";\nrb_row_actions_style_options.singleton = false;\n\nvar rb_row_actions_style_update = injectStylesIntoStyleTag_default()(rb_row_actions_style/* default */.Z, rb_row_actions_style_options);\n\n\n\n/* harmony default export */ const components_rb_row_actions_style = (rb_row_actions_style/* default.locals */.Z.locals || {});\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/rb-row-actions/rb-row-actions.js\nfunction rb_row_actions_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rb_row_actions_typeof = function _typeof(obj) { return typeof obj; }; } else { rb_row_actions_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rb_row_actions_typeof(obj); }\n\nfunction rb_row_actions_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rb_row_actions_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rb_row_actions_createClass(Constructor, protoProps, staticProps) { if (protoProps) rb_row_actions_defineProperties(Constructor.prototype, protoProps); if (staticProps) rb_row_actions_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rb_row_actions_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rb_row_actions_setPrototypeOf(subClass, superClass); }\n\nfunction rb_row_actions_setPrototypeOf(o, p) { rb_row_actions_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rb_row_actions_setPrototypeOf(o, p); }\n\nfunction rb_row_actions_createSuper(Derived) { var hasNativeReflectConstruct = rb_row_actions_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rb_row_actions_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rb_row_actions_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rb_row_actions_possibleConstructorReturn(this, result); }; }\n\nfunction rb_row_actions_possibleConstructorReturn(self, call) { if (call && (rb_row_actions_typeof(call) === "object" || typeof call === "function")) { return call; } return rb_row_actions_assertThisInitialized(self); }\n\nfunction rb_row_actions_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction rb_row_actions_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction rb_row_actions_getPrototypeOf(o) { rb_row_actions_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rb_row_actions_getPrototypeOf(o); }\n\nvar rb_row_actions_Component = wp.element.Component;\nvar IconButton = wp.components.IconButton;\n\n\nvar RBRowActions = /*#__PURE__*/function (_Component) {\n  rb_row_actions_inherits(RBRowActions, _Component);\n\n  var _super = rb_row_actions_createSuper(RBRowActions);\n\n  function RBRowActions(props) {\n    rb_row_actions_classCallCheck(this, RBRowActions);\n\n    return _super.call(this, props);\n  }\n\n  rb_row_actions_createClass(RBRowActions, [{\n    key: "renderActionButtons",\n    value: function renderActionButtons() {\n      var _this = this;\n\n      var buttons = this.props.actions.map(function (action, index) {\n        return /*#__PURE__*/React.createElement(IconButton, {\n          isDefault: true,\n          className: action.className ? action.className : \'\',\n          disabled: _this.props.disableAll || action.disabled,\n          icon: action.icon ? action.icon : \'\',\n          label: action.label ? action.label : \'\',\n          onClick: function onClick() {\n            action.callback(_this.props.item);\n          }\n        });\n      });\n      return buttons;\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      return /*#__PURE__*/React.createElement("div", {\n        className: \'rb-actions-row \' + this.props.className\n      }, /*#__PURE__*/React.createElement("div", {\n        className: "data"\n      }, this.props.data), /*#__PURE__*/React.createElement("div", {\n        className: "actions"\n      }, this.renderActionButtons()));\n    }\n  }]);\n\n  return RBRowActions;\n}(rb_row_actions_Component);\n\nRBRowActions.defaultProps = {\n  disableAll: false\n};\n\n// EXTERNAL MODULE: ../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js!../../../../gutenberg/src/components/rb-list-with-actions/style.css\nvar rb_list_with_actions_style = __webpack_require__(105);\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/rb-list-with-actions/style.css\n\n            \n\nvar rb_list_with_actions_style_options = {};\n\nrb_list_with_actions_style_options.insert = "head";\nrb_list_with_actions_style_options.singleton = false;\n\nvar rb_list_with_actions_style_update = injectStylesIntoStyleTag_default()(rb_list_with_actions_style/* default */.Z, rb_list_with_actions_style_options);\n\n\n\n/* harmony default export */ const components_rb_list_with_actions_style = (rb_list_with_actions_style/* default.locals */.Z.locals || {});\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/rb-list-with-actions/rb-list-with-actions.js\nfunction rb_list_with_actions_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rb_list_with_actions_typeof = function _typeof(obj) { return typeof obj; }; } else { rb_list_with_actions_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rb_list_with_actions_typeof(obj); }\n\nfunction rb_list_with_actions_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rb_list_with_actions_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rb_list_with_actions_createClass(Constructor, protoProps, staticProps) { if (protoProps) rb_list_with_actions_defineProperties(Constructor.prototype, protoProps); if (staticProps) rb_list_with_actions_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rb_list_with_actions_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rb_list_with_actions_setPrototypeOf(subClass, superClass); }\n\nfunction rb_list_with_actions_setPrototypeOf(o, p) { rb_list_with_actions_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rb_list_with_actions_setPrototypeOf(o, p); }\n\nfunction rb_list_with_actions_createSuper(Derived) { var hasNativeReflectConstruct = rb_list_with_actions_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rb_list_with_actions_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rb_list_with_actions_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rb_list_with_actions_possibleConstructorReturn(this, result); }; }\n\nfunction rb_list_with_actions_possibleConstructorReturn(self, call) { if (call && (rb_list_with_actions_typeof(call) === "object" || typeof call === "function")) { return call; } return rb_list_with_actions_assertThisInitialized(self); }\n\nfunction rb_list_with_actions_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction rb_list_with_actions_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction rb_list_with_actions_getPrototypeOf(o) { rb_list_with_actions_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rb_list_with_actions_getPrototypeOf(o); }\n\nvar rb_list_with_actions_Component = wp.element.Component;\n\n\n\n //Generates a list of items with action buttons\n\nvar RBListWithActions = /*#__PURE__*/function (_Component) {\n  rb_list_with_actions_inherits(RBListWithActions, _Component);\n\n  var _super = rb_list_with_actions_createSuper(RBListWithActions);\n\n  function RBListWithActions(props) {\n    rb_list_with_actions_classCallCheck(this, RBListWithActions);\n\n    return _super.call(this, props);\n  }\n  /**\r\n  *   Returns the class to be used in an item row element\r\n  *   @param {object} itemData                        Item from wich the data will be generated\r\n  *   @return {string}\r\n  */\n\n\n  rb_list_with_actions_createClass(RBListWithActions, [{\n    key: "getRowClass",\n    value: function getRowClass(itemData) {\n      var disabledClass = itemData.disabled ? \'disabled\' : \'\';\n      var itemClass = itemData["class"] ? itemData["class"] : \'\';\n      return "".concat(this.props.rowClassName, " ").concat(disabledClass, " ").concat(itemClass);\n    }\n    /**\r\n    *   Given an item, it returns the data to be used by the list component\r\n    *   @param {mixed} item                             Item from wich the data will be generated\r\n    *   @return {object}\r\n    */\n\n  }, {\n    key: "getListItemData",\n    value: function getListItemData(item) {\n      var itemData = this.props.getItemData(item);\n      var actions = itemData.actions ? itemData.actions : this.props.actions;\n      return {\n        id: itemData.id,\n        "class": this.getRowClass(itemData),\n        detail: /*#__PURE__*/React.createElement(RBRowActions, {\n          className: "",\n          key: itemData.id,\n          item: item,\n          data: itemData.detail,\n          actions: actions,\n          disableAll: itemData.disabled\n        })\n      };\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _this = this;\n\n      var List = this.props.sortable ? RBSortableList : RBList;\n      return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(List, {\n        items: this.props.items,\n        className: "rb-list-with-actions " + this.props.listClassName,\n        onSortEnd: function onSortEnd(data) {\n          return _this.props.onSortEnd(data);\n        },\n        getItemData: function getItemData(item) {\n          return _this.getListItemData(item);\n        }\n      }));\n    }\n  }]);\n\n  return RBListWithActions;\n}(rb_list_with_actions_Component);\n\nRBListWithActions.defaultProps = {\n  // Check RBList for this property documentation\n  items: [],\n\n  /** Check RBList for this property documentation. Some extra properties are taken in account\r\n  *   @property {object[]}  actions                     See the \'items\' prop\r\n  *   @property {bool}    disabled                    Indicates if the item action buttons are to be disabled\r\n  */\n  getItemData: null,\n\n  /**\r\n  *   @property {object[]} items\r\n  *   Set of action buttons to be used in each of the rows. It can be overriden by the \'actions\' property\r\n  *   of the \'getItemData\' of each item\r\n  */\n  actions: [],\n\n  /**\r\n  *   @property {string} rowClassName\r\n  *   Extra class to use in the item row element\r\n  */\n  rowClassName: \'\',\n\n  /**\r\n  *   @property {string} listClassName\r\n  *   Extra class to use in the list element\r\n  */\n  listClassName: \'\',\n\n  /**\r\n  *   @property {bool} sortable\r\n  *   Indicates if the list has to be sortable\r\n  */\n  sortable: false,\n\n  /**\r\n  *   @property {function} onSortEnd\r\n  *   Function to be run when the sort ends. It is required if \'sortable\' is set to true\r\n  */\n  onSortEnd: null\n};\n\n// EXTERNAL MODULE: ../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js!../../../../gutenberg/src/components/rb-item-selector/style.css\nvar rb_item_selector_style = __webpack_require__(291);\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/rb-item-selector/style.css\n\n            \n\nvar rb_item_selector_style_options = {};\n\nrb_item_selector_style_options.insert = "head";\nrb_item_selector_style_options.singleton = false;\n\nvar rb_item_selector_style_update = injectStylesIntoStyleTag_default()(rb_item_selector_style/* default */.Z, rb_item_selector_style_options);\n\n\n\n/* harmony default export */ const components_rb_item_selector_style = (rb_item_selector_style/* default.locals */.Z.locals || {});\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/rb-item-selector/rb-item-selector.js\nfunction rb_item_selector_toConsumableArray(arr) { return rb_item_selector_arrayWithoutHoles(arr) || rb_item_selector_iterableToArray(arr) || rb_item_selector_unsupportedIterableToArray(arr) || rb_item_selector_nonIterableSpread(); }\n\nfunction rb_item_selector_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction rb_item_selector_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return rb_item_selector_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return rb_item_selector_arrayLikeToArray(o, minLen); }\n\nfunction rb_item_selector_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction rb_item_selector_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return rb_item_selector_arrayLikeToArray(arr); }\n\nfunction rb_item_selector_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction rb_item_selector_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rb_item_selector_typeof = function _typeof(obj) { return typeof obj; }; } else { rb_item_selector_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rb_item_selector_typeof(obj); }\n\nfunction rb_item_selector_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rb_item_selector_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rb_item_selector_createClass(Constructor, protoProps, staticProps) { if (protoProps) rb_item_selector_defineProperties(Constructor.prototype, protoProps); if (staticProps) rb_item_selector_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rb_item_selector_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rb_item_selector_setPrototypeOf(subClass, superClass); }\n\nfunction rb_item_selector_setPrototypeOf(o, p) { rb_item_selector_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rb_item_selector_setPrototypeOf(o, p); }\n\nfunction rb_item_selector_createSuper(Derived) { var hasNativeReflectConstruct = rb_item_selector_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rb_item_selector_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rb_item_selector_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rb_item_selector_possibleConstructorReturn(this, result); }; }\n\nfunction rb_item_selector_possibleConstructorReturn(self, call) { if (call && (rb_item_selector_typeof(call) === "object" || typeof call === "function")) { return call; } return rb_item_selector_assertThisInitialized(self); }\n\nfunction rb_item_selector_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction rb_item_selector_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction rb_item_selector_getPrototypeOf(o) { rb_item_selector_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rb_item_selector_getPrototypeOf(o); }\n\nvar rb_item_selector_Component = wp.element.Component;\n\n\n\nvar RBItemSelector = /*#__PURE__*/function (_Component) {\n  rb_item_selector_inherits(RBItemSelector, _Component);\n\n  var _super = rb_item_selector_createSuper(RBItemSelector);\n\n  function RBItemSelector(props) {\n    rb_item_selector_classCallCheck(this, RBItemSelector);\n\n    return _super.call(this, props);\n  }\n  /**\r\n  *   Gets the \'add button\' action data\r\n  *   @param {bool} disabled                              If the button should be disabled or not\r\n  *   @return {object}\r\n  */\n\n\n  rb_item_selector_createClass(RBItemSelector, [{\n    key: "getAddAction",\n    value: function getAddAction(disabled) {\n      var _this = this;\n\n      return {\n        disabled: disabled,\n        icon: \'plus\',\n        label: \'Add\',\n        callback: function callback(item) {\n          return _this.onSelectionChange(item, true);\n        }\n      };\n    }\n    /**\r\n    *   Get complete data for and item in the selectable items list\r\n    *   @param {mixed} item                                 Item to retrieve data from\r\n    *   @return {object}\r\n    */\n\n  }, {\n    key: "getSelectableItemData",\n    value: function getSelectableItemData(item) {\n      var itemData = this.props.getItemData(item);\n      var isSelected = this.isSelected(item);\n      var selectedClass = isSelected ? \'selected\' : \'\';\n      itemData["class"] = itemData["class"] ? itemData["class"] : \'\';\n      itemData["class"] = "".concat(itemData["class"], " ").concat(selectedClass);\n      if (isSelected) itemData.actions = [this.getAddAction(true)];\n      return itemData;\n    }\n    /**\r\n    *   Get the data for an item in the selected items list\r\n    *   @param {mixed} item                                 Item to retrieve data from\r\n    *   @return {object}\r\n    */\n\n  }, {\n    key: "getSelectedItemData",\n    value: function getSelectedItemData(item) {\n      return this.props.getItemData(item);\n    }\n    /**\r\n    *   Checks if an item is selected\r\n    *   @param {mixed} item                                 Item to check\r\n    *   @return {bool}\r\n    */\n\n  }, {\n    key: "isSelected",\n    value: function isSelected(item) {\n      var _this2 = this;\n\n      var itemData = this.props.getItemData(item);\n      return this.props.selected && rb_item_selector_typeof(this.props.selected.find(function (selectedItem) {\n        var selectedItemData = _this2.props.getItemData(selectedItem);\n\n        return selectedItemData.id == itemData.id;\n      })) != ( true ? "undefined" : 0);\n    }\n    /**\r\n    *   Modifies the items selection based on the change and runs \'onSelectionChange\' prop\r\n    *   @param {mixed} item                                 Item affected\r\n    *   @param {bool} wasSelected                           Wheter the item was added (true) or removed (false)\r\n    */\n    //wasSelected indicates if the item was added (true) or removed(false) from the selected list\n\n  }, {\n    key: "onSelectionChange",\n    value: function onSelectionChange(item, wasSelected) {\n      var _this3 = this;\n\n      var itemData = this.props.getItemData(item);\n      var newSelected;\n      if (wasSelected) newSelected = [].concat(rb_item_selector_toConsumableArray(this.props.selected), [item]);else {\n        newSelected = this.props.selected.filter(function (selectedItem) {\n          var selectedItemData = _this3.props.getItemData(selectedItem);\n\n          return selectedItemData.id != itemData.id;\n        });\n      }\n\n      if (this.props.onSelectionChange) {\n        this.props.onSelectionChange({\n          item: item,\n          selected: newSelected,\n          items: this.props.items,\n          wasSelected: wasSelected\n        });\n      }\n    }\n  }, {\n    key: "hasItems",\n    value: function hasItems() {\n      return this.props.items && this.props.items.length;\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _this4 = this;\n\n      // console.log(this.props.items, this.props.noItemsLabel, this.hasItems());\n      var actionsDisabled = this.props.disabled || this.props.max != 0 && this.props.selected && this.props.selected.length >= this.props.max;\n      return /*#__PURE__*/React.createElement("div", {\n        "class": "rb-items-selector"\n      }, this.props.topContent ? this.props.topContent : \'\', /*#__PURE__*/React.createElement("div", {\n        className: "columns-container"\n      }, /*#__PURE__*/React.createElement("div", {\n        className: "selector-column"\n      }, !!this.hasItems() && /*#__PURE__*/React.createElement(RBListWithActions, {\n        items: this.props.items,\n        getItemData: function getItemData(item) {\n          return _this4.getSelectableItemData(item);\n        },\n        actions: [this.getAddAction(actionsDisabled)],\n        rowClassName: "item",\n        listClassName: "items-selector-list"\n      }), !this.hasItems() && /*#__PURE__*/React.createElement("div", {\n        className: "no-items-container"\n      }, /*#__PURE__*/React.createElement("p", null, this.props.noItemsLabel)), this.props.middleContent ? this.props.middleContent : \'\'), /*#__PURE__*/React.createElement("div", {\n        className: "selected-column"\n      }, /*#__PURE__*/React.createElement("div", {\n        className: "selected-posts"\n      }, /*#__PURE__*/React.createElement("h2", {\n        "class": "title",\n        style: {\n          marginTop: 0\n        }\n      }, this.props.selectedLabel), /*#__PURE__*/React.createElement(RBListWithActions, {\n        items: this.props.selected,\n        getItemData: function getItemData(item) {\n          return _this4.getSelectedItemData(item);\n        },\n        actions: [{\n          icon: \'minus\',\n          label: \'Remove\',\n          isDestructive: true,\n          className: \'is-destructive\',\n          callback: function callback(item) {\n            _this4.onSelectionChange(item, false);\n          }\n        }]\n      })))));\n    }\n  }]);\n\n  return RBItemSelector;\n}(rb_item_selector_Component);\n\nRBItemSelector.defaultProps = {\n  /**\r\n  *   @property {mixed[]} items\r\n  *   @required\r\n  *   Array of items. Is not restricted to any format or type. The extra data for the item\r\n  *   will be retrieved using the \'getItemData\' method provided through the props.\r\n  */\n  items: [],\n\n  /**\r\n  *   @property {mixed[]} selected\r\n  *   Array of selected items.\r\n  */\n  selected: [],\n\n  /**\r\n  *   @property {int} max\r\n  *   Max amount of items to select. max = 0 means no limit of items\r\n  */\n  max: 1,\n\n  /**\r\n  *   @property {function} getItemData\r\n  *   Function that returns and item data. See RBList component documentation for more info\r\n  *   @required\r\n  */\n  getItemData: null,\n\n  /**\r\n  *   @property {function} onSelectionChange\r\n  *   Function to be runned every time a change happens to the selected list\r\n  *   @param {object} data                             Change data\r\n  *       @param {mixed} item                             The affected item\r\n  *       @param {mixed[]} selected                       The selected items array\r\n  *       @param {mixed[]} items                          The items array\r\n  *       @param {bool} wasSelected                       Wheter the item was added (true) or removed (false)\r\n  */\n  onSelectionChange: null,\n\n  /**\r\n  *   @property {bool} disabled\r\n  *   Indicates if the selection functionality is disabled or not\r\n  */\n  disabled: false,\n\n  /**\r\n  *   Content to show in between the selection list and the selected items list\r\n  */\n  middleContent: null,\n\n  /**\r\n  *   Content to show on top of the selection list\r\n  */\n  topContent: null,\n  selectedLabel: \'Selected Items\',\n  noItemsLabel: \'There is not a list of items to select from\'\n};\n\n// EXTERNAL MODULE: ../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js!../../../../gutenberg/src/components/rb-paginator/style.css\nvar rb_paginator_style = __webpack_require__(526);\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/rb-paginator/style.css\n\n            \n\nvar rb_paginator_style_options = {};\n\nrb_paginator_style_options.insert = "head";\nrb_paginator_style_options.singleton = false;\n\nvar rb_paginator_style_update = injectStylesIntoStyleTag_default()(rb_paginator_style/* default */.Z, rb_paginator_style_options);\n\n\n\n/* harmony default export */ const components_rb_paginator_style = (rb_paginator_style/* default.locals */.Z.locals || {});\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/rb-paginator/rb-paginator.js\nfunction rb_paginator_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rb_paginator_typeof = function _typeof(obj) { return typeof obj; }; } else { rb_paginator_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rb_paginator_typeof(obj); }\n\nfunction rb_paginator_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rb_paginator_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rb_paginator_createClass(Constructor, protoProps, staticProps) { if (protoProps) rb_paginator_defineProperties(Constructor.prototype, protoProps); if (staticProps) rb_paginator_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rb_paginator_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rb_paginator_setPrototypeOf(subClass, superClass); }\n\nfunction rb_paginator_setPrototypeOf(o, p) { rb_paginator_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rb_paginator_setPrototypeOf(o, p); }\n\nfunction rb_paginator_createSuper(Derived) { var hasNativeReflectConstruct = rb_paginator_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rb_paginator_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rb_paginator_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rb_paginator_possibleConstructorReturn(this, result); }; }\n\nfunction rb_paginator_possibleConstructorReturn(self, call) { if (call && (rb_paginator_typeof(call) === "object" || typeof call === "function")) { return call; } return rb_paginator_assertThisInitialized(self); }\n\nfunction rb_paginator_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction rb_paginator_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction rb_paginator_getPrototypeOf(o) { rb_paginator_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rb_paginator_getPrototypeOf(o); }\n\nvar rb_paginator_wp$element = wp.element,\n    rb_paginator_Component = rb_paginator_wp$element.Component,\n    rb_paginator_Fragment = rb_paginator_wp$element.Fragment;\nvar rb_paginator_wp$components = wp.components,\n    rb_paginator_Spinner = rb_paginator_wp$components.Spinner,\n    Popover = rb_paginator_wp$components.Popover,\n    rb_paginator_IconButton = rb_paginator_wp$components.IconButton,\n    rb_paginator_Button = rb_paginator_wp$components.Button,\n    Modal = rb_paginator_wp$components.Modal;\n\n\nvar Pagination = /*#__PURE__*/function (_Component) {\n  rb_paginator_inherits(Pagination, _Component);\n\n  var _super = rb_paginator_createSuper(Pagination);\n\n  function Pagination(props) {\n    rb_paginator_classCallCheck(this, Pagination);\n\n    return _super.call(this, props);\n  }\n\n  rb_paginator_createClass(Pagination, [{\n    key: "pageClick",\n    value: function pageClick(page) {\n      if (!this.props.disabled && this.props.pageClick) this.props.pageClick(page);\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _this = this;\n\n      var pages = [];\n\n      var _loop = function _loop(page) {\n        var dist = Math.abs(_this.props.current - page);\n        var espClass = dist == 0 ? "current" : "dist-" + dist;\n        var style = {\n          left: "calc(50% - ".concat(_this.props.current * 11, "px)")\n        };\n        pages.push( /*#__PURE__*/React.createElement("div", {\n          style: style,\n          onClick: function onClick() {\n            return _this.pageClick(page);\n          },\n          className: "pag ".concat(espClass)\n        }, /*#__PURE__*/React.createElement("span", null, page)));\n      };\n\n      for (var page = 1; page <= this.props.total; page++) {\n        _loop(page);\n      }\n\n      var className = this.props.disabled ? \'disabled\' : \'\';\n      return /*#__PURE__*/React.createElement("div", {\n        className: "pagination " + className\n      }, pages);\n    }\n  }]);\n\n  return Pagination;\n}(rb_paginator_Component);\n\nPagination.defaultProps = {\n  total: 1,\n  current: 1,\n  disabled: false\n};\n\nvar RBPaginator = /*#__PURE__*/function (_Component2) {\n  rb_paginator_inherits(RBPaginator, _Component2);\n\n  var _super2 = rb_paginator_createSuper(RBPaginator);\n\n  // Set default props\n  function RBPaginator(props) {\n    rb_paginator_classCallCheck(this, RBPaginator);\n\n    return _super2.call(this, props);\n  }\n\n  rb_paginator_createClass(RBPaginator, [{\n    key: "componentDidUpdate",\n    value: function componentDidUpdate(prevProps, prevState) {\n      if (prevProps.totalPages != this.props.totalPages && this.props.page > this.props.totalPages) {\n        this.changePage(this.props.totalPages);\n      }\n    }\n  }, {\n    key: "onFirstPage",\n    value: function onFirstPage() {\n      return this.props.page <= 1;\n    }\n  }, {\n    key: "onLastPage",\n    value: function onLastPage() {\n      return this.props.page >= this.props.totalPages;\n    }\n  }, {\n    key: "previousPage",\n    value: function previousPage() {\n      if (this.onFirstPage()) return false;\n      this.changePage(this.props.page - 1);\n    }\n  }, {\n    key: "nextPage",\n    value: function nextPage() {\n      if (this.onLastPage()) return false;\n      this.changePage(this.props.page + 1);\n    }\n  }, {\n    key: "changePage",\n    value: function changePage(page) {\n      if (this.props.onPageChange) this.props.onPageChange({\n        page: page\n      });\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _this2 = this;\n\n      return /*#__PURE__*/React.createElement("div", {\n        className: "rb-paginator"\n      }, /*#__PURE__*/React.createElement(rb_paginator_Button, {\n        isDefault: true,\n        disabled: this.onFirstPage() || this.props.disabled,\n        onClick: function onClick() {\n          return _this2.previousPage();\n        }\n      }, this.props.prevLabel), /*#__PURE__*/React.createElement(Pagination, {\n        total: this.props.totalPages,\n        current: this.props.page,\n        disabled: this.props.disabled,\n        pageClick: function pageClick(page) {\n          return _this2.changePage(page);\n        }\n      }), /*#__PURE__*/React.createElement(rb_paginator_Button, {\n        isDefault: true,\n        disabled: this.onLastPage() || this.props.disabled,\n        onClick: function onClick() {\n          return _this2.nextPage();\n        }\n      }, this.props.nextLabel));\n    }\n  }]);\n\n  return RBPaginator;\n}(rb_paginator_Component);\n\nRBPaginator.defaultProps = {\n  page: 1,\n  totalPages: 1,\n  nextLabel: "Next Page",\n  prevLabel: "Previous Page",\n  disabled: false\n};\n\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/rb-modal/rb-modal.js\nfunction rb_modal_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rb_modal_typeof = function _typeof(obj) { return typeof obj; }; } else { rb_modal_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rb_modal_typeof(obj); }\n\nfunction rb_modal_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rb_modal_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rb_modal_createClass(Constructor, protoProps, staticProps) { if (protoProps) rb_modal_defineProperties(Constructor.prototype, protoProps); if (staticProps) rb_modal_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rb_modal_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rb_modal_setPrototypeOf(subClass, superClass); }\n\nfunction rb_modal_setPrototypeOf(o, p) { rb_modal_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rb_modal_setPrototypeOf(o, p); }\n\nfunction rb_modal_createSuper(Derived) { var hasNativeReflectConstruct = rb_modal_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rb_modal_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rb_modal_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rb_modal_possibleConstructorReturn(this, result); }; }\n\nfunction rb_modal_possibleConstructorReturn(self, call) { if (call && (rb_modal_typeof(call) === "object" || typeof call === "function")) { return call; } return rb_modal_assertThisInitialized(self); }\n\nfunction rb_modal_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction rb_modal_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction rb_modal_getPrototypeOf(o) { rb_modal_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rb_modal_getPrototypeOf(o); }\n\n//Fragment: A component which renders its children without any wrapping element.\nvar rb_modal_ = wp.i18n.__; // Import __() from wp.i18n\n\nvar rb_modal_wp$element = wp.element,\n    rb_modal_Component = rb_modal_wp$element.Component,\n    rb_modal_Fragment = rb_modal_wp$element.Fragment;\nvar rb_modal_wp$components = wp.components,\n    rb_modal_Button = rb_modal_wp$components.Button,\n    rb_modal_Modal = rb_modal_wp$components.Modal;\n\nvar RBModal = /*#__PURE__*/function (_Component) {\n  rb_modal_inherits(RBModal, _Component);\n\n  var _super = rb_modal_createSuper(RBModal);\n\n  function RBModal(props) {\n    var _this;\n\n    rb_modal_classCallCheck(this, RBModal);\n\n    _this = _super.call(this, props);\n    _this.initialState = {\n      isOpen: false\n    };\n    _this.state = _this.initialState; //this.loadInitialPost();\n\n    return _this;\n  }\n\n  rb_modal_createClass(RBModal, [{\n    key: "close",\n    value: function close(callback) {\n      var _this2 = this;\n\n      this.setState({\n        isOpen: false\n      }, function () {\n        if (callback) callback();\n        if (_this2.props.onClose) _this2.props.onClose();\n      });\n    }\n  }, {\n    key: "open",\n    value: function open() {\n      var _this3 = this;\n\n      this.setState({\n        isOpen: true\n      }, function () {\n        if (_this3.props.onOpen) _this3.props.onOpen();\n      });\n    }\n  }, {\n    key: "submit",\n    value: function submit() {\n      var _this4 = this;\n\n      this.close(function () {\n        if (_this4.props.onSubmit) _this4.props.onSubmit();\n      });\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _this5 = this;\n\n      return /*#__PURE__*/React.createElement(rb_modal_Fragment, null, /*#__PURE__*/React.createElement(rb_modal_Button, {\n        className: "modal-opener",\n        isPrimary: true,\n        onClick: function onClick() {\n          return _this5.open();\n        }\n      }, this.props.openerLabel), this.state.isOpen && /*#__PURE__*/React.createElement(rb_modal_Modal, {\n        title: this.props.title,\n        onRequestClose: function onRequestClose() {\n          return _this5.close();\n        }\n      }, /*#__PURE__*/React.createElement("div", {\n        "class": "modal-content"\n      }, this.props.children), /*#__PURE__*/React.createElement("div", {\n        className: "end-buttons"\n      }, /*#__PURE__*/React.createElement(rb_modal_Button, {\n        isPrimary: true,\n        disabled: this.props.submitDisabled,\n        onClick: function onClick() {\n          return _this5.submit();\n        }\n      }, this.props.submitLabel))));\n    }\n  }]);\n\n  return RBModal;\n}(rb_modal_Component);\n\nRBModal.defaultProps = {\n  openerLabel: \'Open Modal\',\n  submitLabel: \'Acept\',\n  title: \'Modal\',\n  onClose: null,\n  onOpen: null,\n  onSubmit: null,\n  submitDisabled: true\n};\n\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/rb-selector-from-fetch/rb-selector-from-fetch.js\nfunction rb_selector_from_fetch_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rb_selector_from_fetch_typeof = function _typeof(obj) { return typeof obj; }; } else { rb_selector_from_fetch_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rb_selector_from_fetch_typeof(obj); }\n\nfunction rb_selector_from_fetch_extends() { rb_selector_from_fetch_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return rb_selector_from_fetch_extends.apply(this, arguments); }\n\nfunction rb_selector_from_fetch_slicedToArray(arr, i) { return rb_selector_from_fetch_arrayWithHoles(arr) || rb_selector_from_fetch_iterableToArrayLimit(arr, i) || rb_selector_from_fetch_unsupportedIterableToArray(arr, i) || rb_selector_from_fetch_nonIterableRest(); }\n\nfunction rb_selector_from_fetch_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction rb_selector_from_fetch_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return rb_selector_from_fetch_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return rb_selector_from_fetch_arrayLikeToArray(o, minLen); }\n\nfunction rb_selector_from_fetch_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction rb_selector_from_fetch_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction rb_selector_from_fetch_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction rb_selector_from_fetch_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction rb_selector_from_fetch_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { rb_selector_from_fetch_ownKeys(Object(source), true).forEach(function (key) { rb_selector_from_fetch_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { rb_selector_from_fetch_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction rb_selector_from_fetch_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction rb_selector_from_fetch_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rb_selector_from_fetch_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rb_selector_from_fetch_createClass(Constructor, protoProps, staticProps) { if (protoProps) rb_selector_from_fetch_defineProperties(Constructor.prototype, protoProps); if (staticProps) rb_selector_from_fetch_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rb_selector_from_fetch_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rb_selector_from_fetch_setPrototypeOf(subClass, superClass); }\n\nfunction rb_selector_from_fetch_setPrototypeOf(o, p) { rb_selector_from_fetch_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rb_selector_from_fetch_setPrototypeOf(o, p); }\n\nfunction rb_selector_from_fetch_createSuper(Derived) { var hasNativeReflectConstruct = rb_selector_from_fetch_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rb_selector_from_fetch_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rb_selector_from_fetch_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rb_selector_from_fetch_possibleConstructorReturn(this, result); }; }\n\nfunction rb_selector_from_fetch_possibleConstructorReturn(self, call) { if (call && (rb_selector_from_fetch_typeof(call) === "object" || typeof call === "function")) { return call; } return rb_selector_from_fetch_assertThisInitialized(self); }\n\nfunction rb_selector_from_fetch_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction rb_selector_from_fetch_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction rb_selector_from_fetch_getPrototypeOf(o) { rb_selector_from_fetch_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rb_selector_from_fetch_getPrototypeOf(o); }\n\nvar rb_selector_from_fetch_ = wp.i18n.__; // Import __() from wp.i18n\n\nvar rb_selector_from_fetch_wp$element = wp.element,\n    rb_selector_from_fetch_Component = rb_selector_from_fetch_wp$element.Component,\n    rb_selector_from_fetch_Fragment = rb_selector_from_fetch_wp$element.Fragment,\n    rb_selector_from_fetch_useState = rb_selector_from_fetch_wp$element.useState,\n    rb_selector_from_fetch_useEffect = rb_selector_from_fetch_wp$element.useEffect;\nvar rb_selector_from_fetch_Spinner = wp.components.Spinner;\n\n\n\n\n //import noImageJPGUrl from \'./assets/no-image.jpg\';\n\nvar noImageJPGUrl = \'\';\n\nvar RBSelectorFromFetch = /*#__PURE__*/function (_Component) {\n  rb_selector_from_fetch_inherits(RBSelectorFromFetch, _Component);\n\n  var _super = rb_selector_from_fetch_createSuper(RBSelectorFromFetch);\n\n  function RBSelectorFromFetch(props) {\n    var _this;\n\n    rb_selector_from_fetch_classCallCheck(this, RBSelectorFromFetch);\n\n    _this = _super.call(this, props);\n\n    _this.setLabels();\n\n    return _this;\n  } //Sets the labels\n\n\n  rb_selector_from_fetch_createClass(RBSelectorFromFetch, [{\n    key: "setLabels",\n    value: function setLabels() {\n      this.labels = rb_selector_from_fetch_objectSpread({\n        noSelectedItems: \'No item has been selected\'\n      }, this.props.labels);\n    } // Calls onSelectionChange callback\n\n  }, {\n    key: "selectionChange",\n    value: function selectionChange(newSelection) {\n      this.props.onSelectionChange ? this.props.onSelectionChange(newSelection) : false;\n    } // Removes an item from the selection and passes the new selection to selectionChange\n\n  }, {\n    key: "removeItem",\n    value: function removeItem(itemToRemove) {\n      var _this2 = this;\n\n      var itemData = this.props.getItemData(itemToRemove);\n      var newSelection = this.props.items.filter(function (selectedItem) {\n        var selectedItemData = _this2.props.getItemData(selectedItem);\n\n        return selectedItemData.id != itemData.id;\n      });\n      this.selectionChange(newSelection);\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _this3 = this;\n\n      return /*#__PURE__*/React.createElement("div", {\n        className: "rb-post-selector"\n      }, (!this.props.items || !this.props.items.length) && /*#__PURE__*/React.createElement("div", {\n        "class": "no-selected"\n      }, /*#__PURE__*/React.createElement("p", null, this.labels.noSelectedItems)), this.props.items && this.props.items.length > 0 && /*#__PURE__*/React.createElement(RBListWithActions, {\n        items: this.props.items,\n        getItemData: function getItemData(item) {\n          return _this3.props.getItemData(item);\n        },\n        actions: [{\n          icon: \'trash\',\n          label: \'Remove Post\',\n          callback: function callback(item) {\n            return _this3.removeItem(item);\n          }\n        }],\n        sortable: true,\n        onSortEnd: function onSortEnd(_ref) {\n          var newList = _ref.newList;\n          return _this3.selectionChange(newList);\n        }\n      }), /*#__PURE__*/React.createElement(ItemsSelectionModal, {\n        itemsFetch: this.props.itemsFetch,\n        max: this.props.max,\n        getItemData: this.props.getItemData,\n        disabled: this.props.disabled,\n        pagination: this.props.pagination,\n        initialPage: this.props.initialPage,\n        useSearch: this.props.useSearch,\n        initialSearch: this.props.initialSearch,\n        initialSelection: this.props.items //initial selection\n        ,\n        onSubmit: function onSubmit(newSelection) {\n          return _this3.selectionChange(newSelection);\n        },\n        labels: this.props.modalLabels,\n        itemsSelectorLabels: this.props.itemsSelectorLabels,\n        filtersContent: this.props.filtersContent\n      }));\n    }\n  }]);\n\n  return RBSelectorFromFetch;\n}(rb_selector_from_fetch_Component); //Manages the state of the current selection in the modal\n\n\nRBSelectorFromFetch.defaultProps = {\n  /**\r\n  *   @property {mixed[]} items\r\n  *   Selected Items.\r\n  */\n  items: [],\n\n  /**\r\n  *   @property {function} onSelectionChange\r\n  *   Function to call when the selection ends\r\n  *   @required\r\n  */\n  onSelectionChange: null,\n\n  /**\r\n  *   @property {function} getItemData\r\n  *   Function that returns neccesary data of an item to use in the lists\r\n  *   @required\r\n  */\n  getItemData: null,\n\n  /**\r\n  *   @property {function} itemsFetch\r\n  *   Function that returns the items to show in the selection list. It recieves\r\n  *   filters data (pagination and other filters)\r\n  *   @required\r\n  *   @param {object} {data}\r\n  *       @property {object} filters                      Filters data at the moment of fetch\r\n  *           @property {int} page                            Page that was requested\r\n  *   @returns {object}\r\n  *       @property {mixed} item                  The items to show in the selectable items list\r\n  *       @property {bool} loading                If the fetch is taking place\r\n  *       @property {bool} error                  IF the fetch failed\r\n  */\n  itemsFetch: null,\n\n  /**\r\n  *   @property {int}  max\r\n  *   Max amount of items to select\r\n  */\n  max: 0,\n\n  /**\r\n  *   @property {bool} pagination\r\n  *   Whether to use a pagination filter\r\n  */\n  pagination: true,\n\n  /**\r\n  *   @property {int} initialPage\r\n  *   The page to use the first time the pagination renders\r\n  */\n  initialPage: 1,\n\n  /**\r\n  *   Whether to use a search filter or not\r\n  *   @property {bool} useSearch\r\n  */\n  useSearch: false,\n\n  /**\r\n  *   The initial search query\r\n  *   @property {string} initialSearch\r\n  */\n  initialSearch: \'\',\n  disabled: false,\n  labels: {},\n  modalLabels: {},\n  itemsSelectorLabels: {},\n  sortable: true,\n\n  /**\r\n  *   @param {jsx} filtersContent - Content for the custom filters.\r\n  */\n  filtersContent: null\n};\n\n\nvar ItemsSelectionModal = function ItemsSelectionModal(props) {\n  var _props$initialSelecti = props.initialSelection,\n      initialSelection = _props$initialSelecti === void 0 ? null : _props$initialSelecti,\n      _props$onSubmit = props.onSubmit,\n      onSubmit = _props$onSubmit === void 0 ? null : _props$onSubmit,\n      _props$labels = props.labels,\n      labels = _props$labels === void 0 ? {} : _props$labels,\n      _props$itemsSelectorL = props.itemsSelectorLabels,\n      itemsSelectorLabels = _props$itemsSelectorL === void 0 ? {} : _props$itemsSelectorL,\n      itemsSelectorProps = _objectWithoutProperties(props, ["initialSelection", "onSubmit", "labels", "itemsSelectorLabels"]);\n\n  var _labels$submitLabel = labels.submitLabel,\n      submitLabel = _labels$submitLabel === void 0 ? \'Accept\' : _labels$submitLabel,\n      _labels$openerLabel = labels.openerLabel,\n      openerLabel = _labels$openerLabel === void 0 ? \'Select items\' : _labels$openerLabel,\n      _labels$modalTitle = labels.modalTitle,\n      modalTitle = _labels$modalTitle === void 0 ? \'Items\' : _labels$modalTitle,\n      propLabels = _objectWithoutProperties(labels, ["submitLabel", "openerLabel", "modalTitle"]); //Current selection state\n\n\n  var _useState = rb_selector_from_fetch_useState(null),\n      _useState2 = rb_selector_from_fetch_slicedToArray(_useState, 2),\n      selected = _useState2[0],\n      setSelectedItems = _useState2[1]; //Runs onSubmit callback passing the current selection as parameter\n\n\n  var submitSelection = function submitSelection() {\n    onSubmit ? onSubmit(selected) : false;\n  };\n\n  return /*#__PURE__*/React.createElement(RBModal, {\n    openerLabel: openerLabel,\n    submitLabel: submitLabel,\n    title: modalTitle,\n    submitDisabled: !selected || !selected.length,\n    onSubmit: function onSubmit() {\n      return submitSelection();\n    },\n    onClose: function onClose() {\n      return setSelectedItems([]);\n    },\n    onOpen: function onOpen() {\n      return setSelectedItems(initialSelection);\n    }\n  }, /*#__PURE__*/React.createElement(ItemSelector, rb_selector_from_fetch_extends({}, itemsSelectorProps, {\n    selected: selected,\n    labels: itemsSelectorLabels,\n    onSelectionChange: function onSelectionChange(newSelection) {\n      return setSelectedItems(newSelection);\n    }\n  })));\n}; //Manages the fetch of new items when the filters change\n\n\nvar ItemSelector = function ItemSelector(props) {\n  var _props$selected = props.selected,\n      selected = _props$selected === void 0 ? null : _props$selected,\n      _props$itemsFetch = props.itemsFetch,\n      itemsFetch = _props$itemsFetch === void 0 ? null : _props$itemsFetch,\n      _props$getItemData = props.getItemData,\n      _getItemData = _props$getItemData === void 0 ? null : _props$getItemData,\n      _props$onSelectionCha = props.onSelectionChange,\n      _onSelectionChange = _props$onSelectionCha === void 0 ? null : _props$onSelectionCha,\n      _props$pagination = props.pagination,\n      pagination = _props$pagination === void 0 ? true : _props$pagination,\n      _props$initialPage = props.initialPage,\n      initialPage = _props$initialPage === void 0 ? 1 : _props$initialPage,\n      _props$useSearch = props.useSearch,\n      useSearch = _props$useSearch === void 0 ? false : _props$useSearch,\n      _props$initialSearch = props.initialSearch,\n      initialSearch = _props$initialSearch === void 0 ? \'\' : _props$initialSearch,\n      max = props.max,\n      _props$filtersContent = props.filtersContent,\n      filtersContent = _props$filtersContent === void 0 ? null : _props$filtersContent,\n      _props$disabled = props.disabled,\n      disabled = _props$disabled === void 0 ? true : _props$disabled,\n      _props$labels2 = props.labels,\n      labels = _props$labels2 === void 0 ? {} : _props$labels2;\n\n  var _labels$noSelectableI = labels.noSelectableItemsLabel,\n      noSelectableItemsLabel = _labels$noSelectableI === void 0 ? \'There are no items to select from\' : _labels$noSelectableI,\n      _labels$selectedItems = labels.selectedItemsLabel,\n      selectedItemsLabel = _labels$selectedItems === void 0 ? \'Selected Items:\' : _labels$selectedItems,\n      _labels$itemsFetchErr = labels.itemsFetchErrorMessage,\n      itemsFetchErrorMessage = _labels$itemsFetchErr === void 0 ? \'An error ocurred while trying to retrieve neccesary data to render the control\' : _labels$itemsFetchErr,\n      _labels$loadingItemsL = labels.loadingItemsLabel,\n      loadingItemsLabel = _labels$loadingItemsL === void 0 ? \'Loading Items\' : _labels$loadingItemsL; //Pagination State\n\n  var _useState3 = rb_selector_from_fetch_useState(initialPage),\n      _useState4 = rb_selector_from_fetch_slicedToArray(_useState3, 2),\n      page = _useState4[0],\n      setPage = _useState4[1]; //Pagination State\n\n\n  var _useState5 = rb_selector_from_fetch_useState(initialSearch),\n      _useState6 = rb_selector_from_fetch_slicedToArray(_useState5, 2),\n      searchQuery = _useState6[0],\n      setSearchQuery = _useState6[1]; //Filters State\n\n\n  var _useState7 = rb_selector_from_fetch_useState({\n    page: page,\n    searchQuery: searchQuery\n  }),\n      _useState8 = rb_selector_from_fetch_slicedToArray(_useState7, 2),\n      filters = _useState8[0],\n      setFilters = _useState8[1]; //Items fetch data\n\n\n  var _itemsFetch = itemsFetch({\n    filters: filters\n  }),\n      items = _itemsFetch.items,\n      totalPages = _itemsFetch.totalPages,\n      loading = _itemsFetch.loading,\n      error = _itemsFetch.error,\n      _itemsFetch$errorMess = _itemsFetch.errorMessage,\n      errorMessage = _itemsFetch$errorMess === void 0 ? itemsFetchErrorMessage : _itemsFetch$errorMess,\n      errorContent = _itemsFetch.errorContent;\n\n  rb_selector_from_fetch_useEffect(function () {\n    //Set the filter state when on of the filters has changed\n    filtersChange();\n  }, [page, searchQuery]); //Sets the \'filters\' state based on each individual filter\n\n  var filtersChange = function filtersChange() {\n    setFilters({\n      page: page,\n      searchQuery: searchQuery\n    });\n  };\n\n  return /*#__PURE__*/React.createElement(rb_selector_from_fetch_Fragment, null, !error && /*#__PURE__*/React.createElement(RBItemSelector, {\n    items: items,\n    selected: selected,\n    getItemData: function getItemData(item) {\n      return _getItemData(item);\n    },\n    max: max,\n    onSelectionChange: function onSelectionChange(_ref2) {\n      var selected = _ref2.selected;\n      return _onSelectionChange(selected);\n    },\n    disabled: loading || disabled,\n    selectedLabel: selectedItemsLabel,\n    noItemsLabel: noSelectableItemsLabel,\n    topContent: useSearch && /*#__PURE__*/React.createElement(rb_selector_from_fetch_Fragment, null, /*#__PURE__*/React.createElement("div", {\n      "class": "rb-search-filter"\n    }, /*#__PURE__*/React.createElement("input", {\n      type: "text",\n      "class": "search-input",\n      placeholder: "Buscar...",\n      value: searchQuery,\n      onChange: function onChange(event) {\n        return setSearchQuery(event.target.value);\n      }\n    })), filtersContent),\n    middleContent: pagination && /*#__PURE__*/React.createElement(RBPaginator, {\n      page: page,\n      onPageChange: function onPageChange(_ref3) {\n        var pageTo = _ref3.page;\n        return setPage(pageTo);\n      },\n      totalPages: totalPages,\n      disabled: loading || disabled\n    })\n  }), loading && /*#__PURE__*/React.createElement("div", {\n    className: "loading-box"\n  }, /*#__PURE__*/React.createElement("p", null, loadingItemsLabel), /*#__PURE__*/React.createElement(rb_selector_from_fetch_Spinner, null)), error && /*#__PURE__*/React.createElement("div", {\n    "class": "error-notice"\n  }, errorMessage && /*#__PURE__*/React.createElement("p", {\n    "class": "error-message"\n  }, errorMessage), errorContent && /*#__PURE__*/React.createElement("p", {\n    "class": "error-content"\n  }, errorContent)));\n};\n;// CONCATENATED MODULE: ../../../../gutenberg/src/helpers/rb-post-fetch-hoc/rb-post-fetch-hoc.js\nfunction rb_post_fetch_hoc_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rb_post_fetch_hoc_typeof = function _typeof(obj) { return typeof obj; }; } else { rb_post_fetch_hoc_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rb_post_fetch_hoc_typeof(obj); }\n\nfunction rb_post_fetch_hoc_extends() { rb_post_fetch_hoc_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return rb_post_fetch_hoc_extends.apply(this, arguments); }\n\nfunction rb_post_fetch_hoc_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rb_post_fetch_hoc_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rb_post_fetch_hoc_createClass(Constructor, protoProps, staticProps) { if (protoProps) rb_post_fetch_hoc_defineProperties(Constructor.prototype, protoProps); if (staticProps) rb_post_fetch_hoc_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rb_post_fetch_hoc_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rb_post_fetch_hoc_setPrototypeOf(subClass, superClass); }\n\nfunction rb_post_fetch_hoc_setPrototypeOf(o, p) { rb_post_fetch_hoc_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rb_post_fetch_hoc_setPrototypeOf(o, p); }\n\nfunction rb_post_fetch_hoc_createSuper(Derived) { var hasNativeReflectConstruct = rb_post_fetch_hoc_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rb_post_fetch_hoc_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rb_post_fetch_hoc_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rb_post_fetch_hoc_possibleConstructorReturn(this, result); }; }\n\nfunction rb_post_fetch_hoc_possibleConstructorReturn(self, call) { if (call && (rb_post_fetch_hoc_typeof(call) === "object" || typeof call === "function")) { return call; } return rb_post_fetch_hoc_assertThisInitialized(self); }\n\nfunction rb_post_fetch_hoc_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction rb_post_fetch_hoc_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction rb_post_fetch_hoc_getPrototypeOf(o) { rb_post_fetch_hoc_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rb_post_fetch_hoc_getPrototypeOf(o); }\n\nfunction rb_post_fetch_hoc_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction rb_post_fetch_hoc_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { rb_post_fetch_hoc_ownKeys(Object(source), true).forEach(function (key) { rb_post_fetch_hoc_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { rb_post_fetch_hoc_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction rb_post_fetch_hoc_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction rb_post_fetch_hoc_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = rb_post_fetch_hoc_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction rb_post_fetch_hoc_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nvar rb_post_fetch_hoc_Component = wp.element.Component;\n\nfunction usePostsFetch(props) {\n  props = props ? props : {};\n\n  var _props = props,\n      _props$postID = _props.postID,\n      postID = _props$postID === void 0 ? null : _props$postID,\n      _props$postType = _props.postType,\n      postType = _props$postType === void 0 ? \'posts\' : _props$postType,\n      _props$updatePostsOnA = _props.updatePostsOnArgsChange,\n      updatePostsOnArgsChange = _props$updatePostsOnA === void 0 ? true : _props$updatePostsOnA,\n      _props$postsQueryArgs = _props.postsQueryArgs,\n      postsQueryArgs = _props$postsQueryArgs === void 0 ? {} : _props$postsQueryArgs,\n      _props$useRbEndpoint = _props.useRbEndpoint,\n      useRbEndpoint = _props$useRbEndpoint === void 0 ? true : _props$useRbEndpoint,\n      fetchArgs = rb_post_fetch_hoc_objectWithoutProperties(_props, ["postID", "postType", "updatePostsOnArgsChange", "postsQueryArgs", "useRbEndpoint"]);\n\n  var getRestPath = function getRestPath() {\n    if (useRbEndpoint) {\n      return "/rb/v1/posts";\n    } else {\n      if (postID) return "/wp/v2/".concat(postType, "/").concat(postID, "?_embed");else if (postType) return "/wp/v2/".concat(postType, "?_embed");\n    }\n\n    return false;\n  };\n\n  var _useRbFetch = useRbFetch(getRestPath(), rb_post_fetch_hoc_objectSpread(rb_post_fetch_hoc_objectSpread({}, fetchArgs), {}, {\n    restPath: getRestPath(),\n    method: useRbEndpoint ? \'POST\' : \'GET\',\n    queryArgs: useRbEndpoint ? null : postsQueryArgs,\n    data: useRbEndpoint ? {\n      args: postsQueryArgs\n    } : null\n  })),\n      response = _useRbFetch.response,\n      responseData = _useRbFetch.responseData,\n      status = _useRbFetch.status;\n\n  return {\n    posts: responseData,\n    totalPages: response && response.headers ? parseInt(response.headers.get(\'X-WP-TotalPages\')) : 0,\n    status: status,\n    response: response\n  };\n}\nfunction RBPostsFetch() {\n  return function (WrappedComponent) {\n    var _class, _temp;\n\n    return _temp = _class = /*#__PURE__*/function (_Component) {\n      rb_post_fetch_hoc_inherits(_class, _Component);\n\n      var _super = rb_post_fetch_hoc_createSuper(_class);\n\n      function _class(props) {\n        var _this;\n\n        rb_post_fetch_hoc_classCallCheck(this, _class);\n\n        _this = _super.call(this, props);\n        _this.initialState = {\n          posts: null,\n          needsUpdate: false\n        };\n        _this.state = _this.initialState;\n        _this.RBFetch = RBFetchHOC(\'postsFetchData\')(WrappedComponent);\n        return _this;\n      }\n\n      rb_post_fetch_hoc_createClass(_class, [{\n        key: "checkNeedsUpdate",\n        value: function checkNeedsUpdate(prevProps, prevState) {\n          return this.props.updatePostsOnArgsChange && (prevProps.postType !== this.props.postType || prevProps.postID !== this.props.postID || this.restArgsChanged(prevProps));\n        }\n      }, {\n        key: "restArgsChanged",\n        value: function restArgsChanged(prevProps) {\n          var newArgs = this.props.postsFetchArgs;\n          var prevArgs = prevProps.postsFetchArgs;\n          if (newArgs && !prevArgs || !newArgs && prevArgs) return true;\n          if (newArgs == prevArgs) return false;\n          return JSON.stringify(newArgs) != JSON.stringify(prevArgs);\n        }\n      }, {\n        key: "getRestPath",\n        value: function getRestPath() {\n          if (this.props.useRbEndpoint) {\n            return "/rb/v1/posts";\n          } else {\n            if (this.props.postID) return "/wp/v2/".concat(this.props.postType, "/").concat(postID, "?_embed");else if (this.props.postType) return "/wp/v2/".concat(this.props.postType, "?_embed");\n          }\n\n          return false;\n        }\n      }, {\n        key: "getRestMethod",\n        value: function getRestMethod() {\n          return this.props.useRbEndpoint ? \'POST\' : \'GET\';\n        }\n      }, {\n        key: "getRestData",\n        value: function getRestData() {\n          return this.props.useRbEndpoint ? {\n            args: this.props.postsFetchArgs\n          } : null;\n        }\n      }, {\n        key: "getQueryArg",\n        value: function getQueryArg() {\n          return this.props.useRbEndpoint ? null : this.props.postsFetchArgs;\n        }\n      }, {\n        key: "onFetchSuccess",\n        value: function onFetchSuccess(response, data) {\n          var _this2 = this;\n\n          this.setState({\n            totalPages: response.headers ? parseInt(response.headers.get(\'X-WP-TotalPages\')) : 0,\n            posts: data,\n            needsUpdate: false\n          }, function () {\n            if (_this2.props.onFetchSuccess) _this2.props.onFetchSuccess(response, data);\n          });\n        }\n      }, {\n        key: "fetchDataFilter",\n        value: function fetchDataFilter(data) {\n          return rb_post_fetch_hoc_objectSpread(rb_post_fetch_hoc_objectSpread({}, data), {}, {\n            posts: this.state.posts,\n            totalPages: this.state.totalPages\n          });\n        }\n      }, {\n        key: "render",\n        value: function render() {\n          var _this3 = this;\n\n          return /*#__PURE__*/React.createElement(this.RBFetch, rb_post_fetch_hoc_extends({}, this.props, {\n            queryArgs: this.getQueryArg(),\n            restPath: this.getRestPath(),\n            needsUpdateCheck: function needsUpdateCheck(prevProps, prevState) {\n              return _this3.checkNeedsUpdate(prevProps, prevState);\n            },\n            onFetchSuccess: function onFetchSuccess(response, data) {\n              return _this3.onFetchSuccess(response, data);\n            },\n            fetchMethod: this.getRestMethod(),\n            requestData: this.getRestData(),\n            fetchDataFilter: function fetchDataFilter(data) {\n              return _this3.fetchDataFilter(data);\n            }\n          }));\n        }\n      }]);\n\n      return _class;\n    }(rb_post_fetch_hoc_Component), _class.defaultProps = {\n      /**\r\n      *   @property {int}             postID\r\n      *   If specified, and \'useRbEndpoint\' is false, the data retrieve from the fetch will be a json with the post data\r\n      *   , instead of an array of posts data\r\n      */\n      postID: null,\n\n      /**\r\n      *   @property {string}          postType\r\n      *   Post type to fetch. Necessary if \'useRbEndpoint\' is false\r\n      *   Tipo de posts a buscar. Necesario si \'useRbEndpoint\' es falso.\r\n      */\n      postType: \'posts\',\n\n      /**\r\n      *   @property {bool}            updatePostsOnArgsChange\r\n      *   Whether the posts must be refetched after a change in postsFetchArgs\r\n      *   If false, the fetch only runs onMount\r\n      */\n      updatePostsOnArgsChange: true,\n\n      /**\r\n      *   @property {array}           postsFetchArgs\r\n      *   Arguments to use in the WP_Query. In addition to the core arguments, there are a few extra ones\r\n      *\r\n      *       @property {bool}    with_thumbnail              Whether the post thumbnail should be included (stored in thumbnail_url)\r\n      *       @property {bool}    only_include                Only return posts if the \'posts__in\' array is not empty, or\r\n      *                                                       if posts where found that satisfy the condition\r\n      */\n      postsFetchArgs: {\n        per_page: 1\n      },\n\n      /**\r\n      *   @property {bool}            useRbEndpoint\r\n      *   Whether to use the custom RB enpoint (rb/v1/posts) or the core wp rest api endpoint\r\n      */\n      useRbEndpoint: true\n    }, _temp;\n  };\n}\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/rb-posts-selector/rb-posts-selector.js\nfunction rb_posts_selector_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rb_posts_selector_typeof = function _typeof(obj) { return typeof obj; }; } else { rb_posts_selector_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rb_posts_selector_typeof(obj); }\n\nfunction rb_posts_selector_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rb_posts_selector_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rb_posts_selector_createClass(Constructor, protoProps, staticProps) { if (protoProps) rb_posts_selector_defineProperties(Constructor.prototype, protoProps); if (staticProps) rb_posts_selector_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rb_posts_selector_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rb_posts_selector_setPrototypeOf(subClass, superClass); }\n\nfunction rb_posts_selector_setPrototypeOf(o, p) { rb_posts_selector_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rb_posts_selector_setPrototypeOf(o, p); }\n\nfunction rb_posts_selector_createSuper(Derived) { var hasNativeReflectConstruct = rb_posts_selector_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rb_posts_selector_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rb_posts_selector_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rb_posts_selector_possibleConstructorReturn(this, result); }; }\n\nfunction rb_posts_selector_possibleConstructorReturn(self, call) { if (call && (rb_posts_selector_typeof(call) === "object" || typeof call === "function")) { return call; } return rb_posts_selector_assertThisInitialized(self); }\n\nfunction rb_posts_selector_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction rb_posts_selector_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction rb_posts_selector_getPrototypeOf(o) { rb_posts_selector_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rb_posts_selector_getPrototypeOf(o); }\n\nfunction rb_posts_selector_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction rb_posts_selector_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { rb_posts_selector_ownKeys(Object(source), true).forEach(function (key) { rb_posts_selector_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { rb_posts_selector_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction rb_posts_selector_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar rb_posts_selector_Component = wp.element.Component; //import styles from "./style.css";\n\n\n\n\nfunction usePostsFetchMiddle(props) {\n  var _usePostsFetch = usePostsFetch(props),\n      items = _usePostsFetch.posts,\n      _usePostsFetch$status = _usePostsFetch.status,\n      loading = _usePostsFetch$status.loading,\n      error = _usePostsFetch$status.error,\n      totalPages = _usePostsFetch.totalPages;\n\n  return {\n    items: items,\n    loading: loading,\n    error: error,\n    totalPages: totalPages\n  };\n}\n\nfunction postsFetchHook(_ref, _ref2) {\n  var filters = _ref.filters,\n      _ref$postsArgs = _ref.postsArgs,\n      postsArgs = _ref$postsArgs === void 0 ? {} : _ref$postsArgs;\n  var _ref2$filtersModifier = _ref2.filtersModifier,\n      filtersModifier = _ref2$filtersModifier === void 0 ? null : _ref2$filtersModifier,\n      _ref2$queryModifier = _ref2.queryModifier,\n      queryModifier = _ref2$queryModifier === void 0 ? null : _ref2$queryModifier,\n      _ref2$fetchHook = _ref2.fetchHook,\n      fetchHook = _ref2$fetchHook === void 0 ? usePostsFetchMiddle : _ref2$fetchHook;\n  //Modifies the filters based on a function\n  filters = filtersModifier ? filtersModifier(filters) : filters;\n  var postsQueryArgs = {\n    post_type: \'post\',\n    posts_per_page: 10,\n    paged: filters.page\n  };\n  if (filters.searchQuery) postsQueryArgs.s = filters.searchQuery;\n  postsQueryArgs = rb_posts_selector_objectSpread(rb_posts_selector_objectSpread({}, postsQueryArgs), postsArgs);\n  postsQueryArgs = queryModifier ? queryModifier(postsQueryArgs) : postsQueryArgs;\n\n  var _fetchHook = fetchHook({\n    postsQueryArgs: postsQueryArgs,\n    fetchArgs: {\n      updateOnArgsChange: true\n    }\n  }),\n      items = _fetchHook.items,\n      loading = _fetchHook.loading,\n      error = _fetchHook.error,\n      totalPages = _fetchHook.totalPages;\n\n  return {\n    items: items,\n    loading: loading,\n    error: error,\n    totalPages: totalPages\n  };\n}\n\nvar RBPostsSelector = /*#__PURE__*/function (_Component) {\n  rb_posts_selector_inherits(RBPostsSelector, _Component);\n\n  var _super = rb_posts_selector_createSuper(RBPostsSelector);\n\n  function RBPostsSelector(props) {\n    var _this;\n\n    rb_posts_selector_classCallCheck(this, RBPostsSelector);\n\n    _this = _super.call(this, props);\n\n    _this.setLabels();\n\n    return _this;\n  }\n\n  rb_posts_selector_createClass(RBPostsSelector, [{\n    key: "setLabels",\n    value: function setLabels() {\n      this.labels = rb_posts_selector_objectSpread({\n        noSelectedItems: \'No Post has been selected\'\n      }, this.props.labels);\n      this.modalLabels = rb_posts_selector_objectSpread({\n        submitLabel: \'Accept\',\n        openerLabel: \'Select Posts\',\n        modalTitle: \'Posts\'\n      }, this.props.modalLabels);\n      this.itemsSelectorLabels = rb_posts_selector_objectSpread({\n        noSelectableItemsLabel: \'No post has been found\',\n        selectedItemsLabel: \'Selected Posts:\',\n        loadingItemsLabel: \'Loading Posts\'\n      }, this.props.itemsSelectorLabels);\n    }\n  }, {\n    key: "selectionChange",\n    value: function selectionChange(newSelection) {\n      this.props.onSelectionChange ? this.props.onSelectionChange(newSelection) : false;\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _this2 = this;\n\n      return /*#__PURE__*/React.createElement(RBSelectorFromFetch, {\n        items: this.props.posts //initial selection\n        ,\n        onSelectionChange: function onSelectionChange(newSelection) {\n          return _this2.selectionChange(newSelection);\n        },\n        getItemData: function getItemData(item) {\n          return _this2.props.getItemData(item);\n        },\n        itemsFetch: function itemsFetch(data) {\n          return postsFetchHook(rb_posts_selector_objectSpread(rb_posts_selector_objectSpread({}, data), {}, {\n            postsArgs: _this2.props.postsArgs\n          }), _this2.props);\n        },\n        max: this.props.max,\n        labels: this.labels,\n        modalLabels: this.modalLabels,\n        itemsSelectorLabels: this.itemsSelectorLabels,\n        disabled: this.props.disabled,\n        sortable: this.props.sortable,\n        pagination: this.props.pagination,\n        initialPage: this.props.initialPage,\n        filtersContent: this.props.filtersContent,\n        useSearch: true\n      });\n    }\n  }]);\n\n  return RBPostsSelector;\n}(rb_posts_selector_Component);\n\nRBPostsSelector.defaultProps = {\n  /**\r\n  *  Selected posts\r\n  */\n  posts: [],\n\n  /**\r\n  *  @property {int}  max\r\n  *   Max amount of items to select\r\n  */\n  max: 0,\n\n  /**\r\n  *   Function to call when the selection ends\r\n  *   @required\r\n  */\n  onSelectionChange: null,\n\n  /**\r\n  *   Function that returns neccesary data of an item to use in the lists\r\n  *   @required\r\n  */\n  getItemData: function getItemData(post) {\n    return {\n      id: post.ID,\n      detail: post.post_title\n    };\n  },\n  disabled: false,\n  pagination: true,\n  initialPage: 1,\n  labels: {},\n  modalLabels: {},\n  itemsSelectorLabels: {},\n  postsArgs: {},\n  sortable: true,\n\n  /**\r\n  *   @param {function} filtersModifier - Function that takes the filters\r\n  *   for the post fetch, and returns a modified version\r\n  */\n  filtersModifier: null,\n\n  /**\r\n  *   @param {function} filtersContent - Custom filters manager jsx\r\n  */\n  filtersContent: null,\n  fetchHook: usePostsFetchMiddle\n};\n\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/rb-terms-selector/rb-terms-selector.js\nfunction rb_terms_selector_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rb_terms_selector_typeof = function _typeof(obj) { return typeof obj; }; } else { rb_terms_selector_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rb_terms_selector_typeof(obj); }\n\nfunction rb_terms_selector_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rb_terms_selector_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rb_terms_selector_createClass(Constructor, protoProps, staticProps) { if (protoProps) rb_terms_selector_defineProperties(Constructor.prototype, protoProps); if (staticProps) rb_terms_selector_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rb_terms_selector_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rb_terms_selector_setPrototypeOf(subClass, superClass); }\n\nfunction rb_terms_selector_setPrototypeOf(o, p) { rb_terms_selector_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rb_terms_selector_setPrototypeOf(o, p); }\n\nfunction rb_terms_selector_createSuper(Derived) { var hasNativeReflectConstruct = rb_terms_selector_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rb_terms_selector_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rb_terms_selector_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rb_terms_selector_possibleConstructorReturn(this, result); }; }\n\nfunction rb_terms_selector_possibleConstructorReturn(self, call) { if (call && (rb_terms_selector_typeof(call) === "object" || typeof call === "function")) { return call; } return rb_terms_selector_assertThisInitialized(self); }\n\nfunction rb_terms_selector_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction rb_terms_selector_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction rb_terms_selector_getPrototypeOf(o) { rb_terms_selector_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rb_terms_selector_getPrototypeOf(o); }\n\nfunction rb_terms_selector_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction rb_terms_selector_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { rb_terms_selector_ownKeys(Object(source), true).forEach(function (key) { rb_terms_selector_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { rb_terms_selector_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction rb_terms_selector_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar rb_terms_selector_Component = wp.element.Component; //import styles from "./style.css";\n\n\n\n\nfunction termsFetchHook(_ref) {\n  var filters = _ref.filters,\n      _ref$termsArgs = _ref.termsArgs,\n      termsArgs = _ref$termsArgs === void 0 ? {} : _ref$termsArgs,\n      _ref$fetchArgs = _ref.fetchArgs,\n      fetchArgs = _ref$fetchArgs === void 0 ? {\n    updateOnArgsChange: true\n  } : _ref$fetchArgs;\n  var termsQueryArgs = {\n    number: 10,\n    page: filters.page\n  };\n  if (filters.searchQuery) termsQueryArgs.search = filters.searchQuery;\n  termsQueryArgs = rb_terms_selector_objectSpread(rb_terms_selector_objectSpread({}, termsQueryArgs), termsArgs); // termsQueryArgs = queryModifier ? queryModifier(termsQueryArgs) : termsQueryArgs;\n\n  var _useTermsFetch = useTermsFetch({\n    termsQueryArgs: termsQueryArgs,\n    fetchArgs: fetchArgs\n  }),\n      items = _useTermsFetch.terms,\n      _useTermsFetch$status = _useTermsFetch.status,\n      loading = _useTermsFetch$status.loading,\n      error = _useTermsFetch$status.error,\n      totalPages = _useTermsFetch.totalPages;\n\n  return {\n    items: items,\n    loading: loading,\n    error: error,\n    totalPages: totalPages\n  };\n}\n\nvar rb_terms_selector_RBTermsSelector = /*#__PURE__*/function (_Component) {\n  rb_terms_selector_inherits(RBTermsSelector, _Component);\n\n  var _super = rb_terms_selector_createSuper(RBTermsSelector);\n\n  function RBTermsSelector(props) {\n    var _this;\n\n    rb_terms_selector_classCallCheck(this, RBTermsSelector);\n\n    _this = _super.call(this, props);\n\n    _this.setLabels();\n\n    return _this;\n  }\n\n  rb_terms_selector_createClass(RBTermsSelector, [{\n    key: "setLabels",\n    value: function setLabels() {\n      this.labels = rb_terms_selector_objectSpread({\n        noSelectedItems: \'No Term has been selected\'\n      }, this.props.labels);\n      this.modalLabels = rb_terms_selector_objectSpread({\n        submitLabel: \'Accept\',\n        openerLabel: \'Select Terms\',\n        modalTitle: \'Terms\'\n      }, this.props.modalLabels);\n      this.itemsSelectorLabels = rb_terms_selector_objectSpread({\n        noSelectableItemsLabel: \'No term has been found\',\n        selectedItemsLabel: \'Selected Terms:\',\n        loadingItemsLabel: \'Loading Terms\'\n      }, this.props.itemsSelectorLabels);\n    }\n  }, {\n    key: "selectionChange",\n    value: function selectionChange(newSelection) {\n      this.props.onSelectionChange ? this.props.onSelectionChange(newSelection) : false;\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _this2 = this;\n\n      return /*#__PURE__*/React.createElement(RBSelectorFromFetch, {\n        items: this.props.terms //initial selection\n        ,\n        onSelectionChange: function onSelectionChange(newSelection) {\n          return _this2.selectionChange(newSelection);\n        },\n        getItemData: function getItemData(item) {\n          return _this2.props.getItemData(item);\n        },\n        itemsFetch: function itemsFetch(data) {\n          return termsFetchHook(rb_terms_selector_objectSpread(rb_terms_selector_objectSpread({}, data), {}, {\n            termsArgs: _this2.props.termsArgs\n          }));\n        },\n        max: this.props.max,\n        labels: this.labels,\n        modalLabels: this.modalLabels,\n        itemsSelectorLabels: this.itemsSelectorLabels,\n        disabled: this.props.disabled,\n        pagination: this.props.pagination,\n        initialPage: this.props.initialPage,\n        sortable: this.props.sortable,\n        useSearch: this.props.useSearch\n      });\n    }\n  }]);\n\n  return RBTermsSelector;\n}(rb_terms_selector_Component);\n\nrb_terms_selector_RBTermsSelector.defaultProps = {\n  /**\r\n  *  Selected terms\r\n  */\n  terms: [],\n\n  /**\r\n  *  @property {int}  max\r\n  *   Max amount of items to select\r\n  */\n  max: 0,\n\n  /**\r\n  *   Function to call when the selection ends\r\n  *   @required\r\n  */\n  onSelectionChange: null,\n\n  /**\r\n  *   Function that returns neccesary data of an item to use in the lists\r\n  *   @required\r\n  */\n  getItemData: function getItemData(term) {\n    return {\n      id: term.term_id,\n      detail: term.name\n    };\n  },\n  disabled: false,\n  pagination: true,\n  initialPage: 1,\n  labels: {},\n  modalLabels: {},\n  itemsSelectorLabels: {},\n  termsArgs: {},\n  sortable: true,\n  useSearch: false\n};\n\n// EXTERNAL MODULE: ../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js!../../../../gutenberg/src/components/lr-articles-filter/editor.css\nvar editor = __webpack_require__(553);\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/lr-articles-filter/editor.css\n\n            \n\nvar editor_options = {};\n\neditor_options.insert = "head";\neditor_options.singleton = false;\n\nvar editor_update = injectStylesIntoStyleTag_default()(editor/* default */.Z, editor_options);\n\n\n\n/* harmony default export */ const lr_articles_filter_editor = (editor/* default.locals */.Z.locals || {});\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/lr-articles-filter/lr-articles-filter.js\nfunction lr_articles_filter_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction lr_articles_filter_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { lr_articles_filter_ownKeys(Object(source), true).forEach(function (key) { lr_articles_filter_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { lr_articles_filter_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction lr_articles_filter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar lr_articles_filter_Fragment = wp.element.Fragment;\nvar lr_articles_filter_wp$components = wp.components,\n    lr_articles_filter_PanelBody = lr_articles_filter_wp$components.PanelBody,\n    lr_articles_filter_Spinner = lr_articles_filter_wp$components.Spinner,\n    RangeControl = lr_articles_filter_wp$components.RangeControl,\n    ToggleControl = lr_articles_filter_wp$components.ToggleControl;\n\n\nvar lr_articles_filter_LRArticlesFilters = function LRArticlesFilters() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var taxonomiesData = props.taxonomiesData,\n      _props$onTermsChange = props.onTermsChange,\n      onTermsChange = _props$onTermsChange === void 0 ? null : _props$onTermsChange,\n      _props$amountFilter = props.amountFilter,\n      amountFilter = _props$amountFilter === void 0 ? false : _props$amountFilter,\n      _props$amountFilterPr = props.amountFilterProps,\n      amountFilterProps = _props$amountFilterPr === void 0 ? null : _props$amountFilterPr,\n      _props$suplementProps = props.suplementProps,\n      suplementProps = _props$suplementProps === void 0 ? null : _props$suplementProps,\n      _props$tagProps = props.tagProps,\n      tagProps = _props$tagProps === void 0 ? null : _props$tagProps,\n      _props$sectionProps = props.sectionProps,\n      sectionProps = _props$sectionProps === void 0 ? null : _props$sectionProps,\n      _props$requiredTaxono = props.requiredTaxonomies,\n      requiredTaxonomies = _props$requiredTaxono === void 0 ? false : _props$requiredTaxono,\n      _props$onRequiredTerm = props.onRequiredTermsChange,\n      onRequiredTermsChange = _props$onRequiredTerm === void 0 ? null : _props$onRequiredTerm,\n      _props$attributes = props.attributes,\n      attributes = _props$attributes === void 0 ? null : _props$attributes,\n      _props$setAttributes = props.setAttributes,\n      setAttributes = _props$setAttributes === void 0 ? null : _props$setAttributes,\n      _props$mostRecentFilt = props.mostRecentFilter,\n      mostRecentFilter = _props$mostRecentFilt === void 0 ? false : _props$mostRecentFilt,\n      _props$toggleFiltersW = props.toggleFiltersWithMostRecent,\n      toggleFiltersWithMostRecent = _props$toggleFiltersW === void 0 ? true : _props$toggleFiltersW,\n      _props$onMostRecentTo = props.onMostRecentToggle,\n      onMostRecentToggle = _props$onMostRecentTo === void 0 ? null : _props$onMostRecentTo,\n      _props$layoutType = props.layoutType,\n      layoutType = _props$layoutType === void 0 ? \'common\' : _props$layoutType;\n  var useAmountFilter = amountFilter || amountFilterProps;\n\n  var _ref = amountFilterProps ? amountFilterProps : {},\n      maxAmount = _ref.max,\n      _ref$min = _ref.min,\n      minAmount = _ref$min === void 0 ? 1 : _ref$min,\n      onAmountChange = _ref.onChange;\n  /**\r\n  *   Devuelve si existe el campo name de attributes. Si no existe, devuelve default.\r\n  */\n\n\n  var getAttribute = function getAttribute(name) {\n    var def = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return attributes && attributes.hasOwnProperty(name) ? attributes[name] : def;\n  };\n  /**\r\n  *   Efecto que ocurre al cambiar los terms de las taxonomias\r\n  *   @param {string} taxAttribute - Nombre del attribute que guarda los datos de\r\n  *   la taxonomia\r\n  *   @param {mixed[]} selectedTerms - Array de los terms por los cuales filtrar\r\n  *   @param {function} setSuplementData - Funcion para guardar los datos del suplemento.\r\n  *   De estos datos solo se guarda el term_id en el attribute\r\n  */\n\n\n  var termsChanged = function termsChanged(taxAttribute, selectedTerms, setSuplementsData) {\n    setSuplementsData(selectedTerms);\n\n    if (setAttributes && attributes) {\n      var newAttrs = {};\n      newAttrs[taxAttribute] = lr_articles_filter_objectSpread({}, getAttribute(taxAttribute, {}));\n      newAttrs[taxAttribute].terms = selectedTerms.map(function (term) {\n        return term.term_id;\n      });\n      setAttributes(newAttrs);\n    } else if (onTermsChange) onTermsChange(taxAttribute, selectedTerms);\n  };\n\n  var amountChanged = function amountChanged(newAmount) {\n    if (setAttributes) setAttributes({\n      amount: newAmount\n    });else if (onAmountChange) onAmountChange(newAmount);\n  };\n\n  var requiredTermChange = function requiredTermChange(taxAttribute, isRequired) {\n    if (setAttributes && attributes) {\n      var newAttrs = {};\n      newAttrs[taxAttribute] = lr_articles_filter_objectSpread({}, getAttribute(taxAttribute, {}));\n      newAttrs[taxAttribute].required = isRequired;\n      setAttributes(newAttrs);\n    } else if (onRequiredTermsChange) onRequiredTermsChange(taxAttribute, isRequired);\n  };\n\n  var mostRecentFilterChange = function mostRecentFilterChange() {\n    var mostRecentFilter = getAttribute(\'most_recent\', false);\n    setAttributes && attributes ? setAttributes({\n      most_recent: !mostRecentFilter\n    }) : false;\n    onMostRecentToggle ? onMostRecentToggle(!mostRecentFilter) : false;\n  };\n\n  var onlyShowMostRecentFilter = function onlyShowMostRecentFilter() {\n    return toggleFiltersWithMostRecent && mostRecentFilter && !getAttribute(\'most_recent\', false);\n  };\n\n  var RequiredTaxonomyCheckbox = function RequiredTaxonomyCheckbox(_ref2) {\n    var taxName = _ref2.taxName,\n        taxObject = _ref2.taxObject;\n    var isChecked = getAttribute(taxName, {}).required;\n    return requiredTaxonomies && /*#__PURE__*/React.createElement(ToggleControl, {\n      label: "Taxonomia obligatoria",\n      checked: isChecked,\n      onChange: function onChange() {\n        return requiredTermChange(taxName, !isChecked);\n      }\n    });\n  };\n\n  var LRTermSelector = function LRTermSelector() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _props$taxData = props.taxData,\n        taxData = _props$taxData === void 0 ? {} : _props$taxData,\n        _props$taxonomy = props.taxonomy,\n        taxonomy = _props$taxonomy === void 0 ? \'\' : _props$taxonomy,\n        _props$labels = props.labels,\n        labels = _props$labels === void 0 ? {} : _props$labels,\n        _props$taxonomyProps = props.taxonomyProps,\n        taxonomyProps = _props$taxonomyProps === void 0 ? {} : _props$taxonomyProps,\n        _props$attributeName = props.attributeName,\n        attributeName = _props$attributeName === void 0 ? \'\' : _props$attributeName;\n\n    var _ref3 = taxonomyProps ? taxonomyProps : {},\n        _ref3$max = _ref3.max,\n        max = _ref3$max === void 0 ? 0 : _ref3$max;\n\n    return /*#__PURE__*/React.createElement(rb_terms_selector_RBTermsSelector, {\n      max: max,\n      terms: taxData.termsData ? taxData.termsData : [],\n      onSelectionChange: function onSelectionChange(selectedTerms) {\n        return termsChanged(attributeName, selectedTerms, taxData.setTermsData);\n      },\n      termsArgs: {\n        taxonomy: taxonomy,\n        hide_empty: false,\n        number: 10\n      },\n      labels: {\n        noSelectedItems: labels.noSelectedItems\n      },\n      modalLabels: {\n        submitLabel: labels.submitLabel,\n        openerLabel: labels.openerLabel,\n        modalTitle: labels.modalTitle\n      },\n      itemsSelectorLabels: {\n        noSelectableItemsLabel: labels.noSelectableItemsLabel,\n        selectedItemsLabel: labels.selectedItemsLabel,\n        loadingItemsLabel: labels.loadingItemsLabel\n      }\n    });\n  };\n\n  var getLayoutClass = function getLayoutClass() {\n    return layoutType == \'compressed\' ? "compressed-layout" : \'\';\n  };\n\n  return /*#__PURE__*/React.createElement("div", {\n    "class": "lr-articles-filters-component ".concat(getLayoutClass())\n  }, mostRecentFilter && /*#__PURE__*/React.createElement(ToggleControl, {\n    label: "Mas Recientes",\n    checked: getAttribute(\'most_recent\', false),\n    onChange: function onChange() {\n      return mostRecentFilterChange();\n    }\n  }), !onlyShowMostRecentFilter() && /*#__PURE__*/React.createElement(lr_articles_filter_Fragment, null, useAmountFilter && /*#__PURE__*/React.createElement(RangeControl, {\n    label: "Cantidad de articulos",\n    value: getAttribute(\'amount\', 0),\n    onChange: function onChange(amount) {\n      return amountChanged(amount);\n    },\n    min: minAmount,\n    max: maxAmount\n  }), taxonomiesData && /*#__PURE__*/React.createElement("div", {\n    "class": "panel-bodies"\n  }, taxonomiesData.suplement && /*#__PURE__*/React.createElement(lr_articles_filter_PanelBody, {\n    title: "Suplementos",\n    icon: "",\n    initialOpen: taxonomiesData.suplement.termsData && taxonomiesData.suplement.termsData.length > 0\n  }, /*#__PURE__*/React.createElement(RequiredTaxonomyCheckbox, {\n    taxName: \'suplements\',\n    taxObject: taxonomiesData.suplement\n  }), /*#__PURE__*/React.createElement(LRTermSelector, {\n    taxData: taxonomiesData.suplement,\n    taxonomy: "lr-article-suplement",\n    attributeName: "suplements",\n    labels: {},\n    taxonomyProps: suplementProps\n  })), taxonomiesData.section && /*#__PURE__*/React.createElement(lr_articles_filter_PanelBody, {\n    title: "Secciones",\n    icon: "",\n    initialOpen: taxonomiesData.section.termsData && taxonomiesData.section.termsData.length > 0\n  }, /*#__PURE__*/React.createElement(RequiredTaxonomyCheckbox, {\n    taxName: \'sections\',\n    taxObject: taxonomiesData.section\n  }), /*#__PURE__*/React.createElement(LRTermSelector, {\n    taxData: taxonomiesData.section,\n    taxonomy: "ta_article_section",\n    attributeName: "sections",\n    labels: {},\n    taxonomyProps: sectionProps\n  })), taxonomiesData.tag && /*#__PURE__*/React.createElement(lr_articles_filter_PanelBody, {\n    title: "Etiquetas",\n    icon: "",\n    initialOpen: taxonomiesData.tag.termsData && taxonomiesData.tag.termsData.length > 0\n  }, /*#__PURE__*/React.createElement(RequiredTaxonomyCheckbox, {\n    taxName: \'tags\',\n    taxObject: taxonomiesData.tag\n  }), /*#__PURE__*/React.createElement(LRTermSelector, {\n    taxData: taxonomiesData.tag,\n    taxonomy: "ta_article_tag",\n    attributeName: "tags",\n    labels: {},\n    taxonomyProps: sectionProps\n  })), taxonomiesData.author && /*#__PURE__*/React.createElement(lr_articles_filter_PanelBody, {\n    title: "Autores",\n    icon: "",\n    initialOpen: taxonomiesData.author.termsData && taxonomiesData.author.termsData.length > 0\n  }, /*#__PURE__*/React.createElement(RequiredTaxonomyCheckbox, {\n    taxName: \'authors\',\n    taxObject: taxonomiesData.author\n  }), /*#__PURE__*/React.createElement(LRTermSelector, {\n    taxData: taxonomiesData.author,\n    taxonomy: "ta_article_author",\n    attributeName: "authors",\n    labels: {},\n    taxonomyProps: sectionProps\n  })))));\n};\n;// CONCATENATED MODULE: ../../../../gutenberg/src/helpers/lr-articles-taxonomies/lr-articles-taxonomies.js\nfunction lr_articles_taxonomies_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction lr_articles_taxonomies_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { lr_articles_taxonomies_ownKeys(Object(source), true).forEach(function (key) { lr_articles_taxonomies_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { lr_articles_taxonomies_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction lr_articles_taxonomies_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar lr_articles_taxonomies_wp$element = wp.element,\n    lr_articles_taxonomies_useState = lr_articles_taxonomies_wp$element.useState,\n    lr_articles_taxonomies_useRef = lr_articles_taxonomies_wp$element.useRef;\n\n/**\r\n*   Genera un objecto con datos para las taxonomias de articulo que se quieran.\r\n*   @return {object}\r\n*        @property {object} suplement\r\n*        @property {object} tag\r\n*        @property {object} section\r\n*        @property {object} author\r\n*        @property {object} taxQuery                Filtro de tax en base de los datos generados, formateado para ser usado en un WP_Query\r\n*   Cada objecto de taxonomy tiene datos de los terms que se consiguieron de acuerdo a\r\n*   termsQueryArgs que se proveyeron para dicha taxonomy.\r\n*   Un mayor detalle de los datos que se guardan por taxonomy se encuentra en el hook \'useRbTerms\'\r\n*   Entre los datos estan:\r\n*   @property {WP_Term[]}   termsData                   Array de terms con toda la info recibida desde el WP_Terms_Query.\r\n*   @property {function}    setTermsData                Funcion para establecer nueva informacion de terms.\r\n*\r\n*/\n\nvar lr_articles_taxonomies_useLRArticlesTaxonomies = function useLRArticlesTaxonomies() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var initialized = lr_articles_taxonomies_useRef(false);\n  var unmutableProps = lr_articles_taxonomies_useRef();\n\n  if (!initialized.current) {\n    unmutableProps.current = props.usage;\n    initialized.current = true;\n  }\n\n  var _props$taxQueryRelati = props.taxQueryRelation,\n      taxQueryRelation = _props$taxQueryRelati === void 0 ? \'OR\' : _props$taxQueryRelati,\n      _props$suplementProps = props.suplementProps,\n      suplementProps = _props$suplementProps === void 0 ? {} : _props$suplementProps,\n      _props$tagProps = props.tagProps,\n      tagProps = _props$tagProps === void 0 ? {} : _props$tagProps,\n      _props$sectionProps = props.sectionProps,\n      sectionProps = _props$sectionProps === void 0 ? {} : _props$sectionProps,\n      _props$authorProps = props.authorProps,\n      authorProps = _props$authorProps === void 0 ? {} : _props$authorProps,\n      _props$usage = props.usage,\n      usage = _props$usage === void 0 ? {\n    suplement: false,\n    tag: false,\n    section: false,\n    author: false\n  } : _props$usage;\n  var _unmutableProps$curre = unmutableProps.current,\n      useSuplements = _unmutableProps$curre.suplement,\n      useTags = _unmutableProps$curre.tag,\n      useSections = _unmutableProps$curre.section,\n      useAuthors = _unmutableProps$curre.author;\n  var finalData = {};\n  var taxQuery = {}; //Suplementos\n  // if(useSuplements){\n  //     const {terms: suplements = [], queryArgs: suplementsQueryArgs = {}, fetchArgs: suplementsFetchArgs = {}, required: suplementsRequired = false} = suplementProps;\n  //     finalData.suplement = useRbTerms("lr-article-suplement", suplements, {\n  //         termsQueryArgs: {\n  //             only_include: true,\n  //             ...suplementsQueryArgs,\n  //             taxonomy: "lr-article-suplement",\n  //         },\n  //         fetchArgs: suplementsFetchArgs,\n  //     });\n  //     taxQuery["lr-article-suplement"] = {\n  //         required: suplementsRequired,\n  //         field: suplementsQueryArgs.field,\n  //         terms: suplements,\n  //     };\n  // }\n  //Tags\n\n  if (useTags) {\n    var _tagProps$terms = tagProps.terms,\n        tags = _tagProps$terms === void 0 ? [] : _tagProps$terms,\n        _tagProps$queryArgs = tagProps.queryArgs,\n        tagsQueryArgs = _tagProps$queryArgs === void 0 ? {} : _tagProps$queryArgs,\n        _tagProps$fetchArgs = tagProps.fetchArgs,\n        tagsFetchArgs = _tagProps$fetchArgs === void 0 ? {} : _tagProps$fetchArgs,\n        _tagProps$required = tagProps.required,\n        tagsRequired = _tagProps$required === void 0 ? false : _tagProps$required;\n    finalData.tag = useRbTerms("ta_article_tag", tags, {\n      termsQueryArgs: lr_articles_taxonomies_objectSpread(lr_articles_taxonomies_objectSpread({\n        only_include: true\n      }, tagsQueryArgs), {}, {\n        taxonomy: "ta_article_tag"\n      }),\n      fetchArgs: tagsFetchArgs\n    });\n    taxQuery["ta_article_tag"] = {\n      required: tagsRequired,\n      field: tagsQueryArgs.field,\n      terms: tags\n    };\n  } //Secciones\n\n\n  if (useSections) {\n    var _sectionProps$terms = sectionProps.terms,\n        sections = _sectionProps$terms === void 0 ? [] : _sectionProps$terms,\n        _sectionProps$queryAr = sectionProps.queryArgs,\n        sectionsQueryArgs = _sectionProps$queryAr === void 0 ? {} : _sectionProps$queryAr,\n        _sectionProps$fetchAr = sectionProps.fetchArgs,\n        sectionsFetchArgs = _sectionProps$fetchAr === void 0 ? {} : _sectionProps$fetchAr,\n        _sectionProps$require = sectionProps.required,\n        sectionsRequired = _sectionProps$require === void 0 ? false : _sectionProps$require;\n    finalData.section = useRbTerms("ta_article_section", sections, {\n      termsQueryArgs: lr_articles_taxonomies_objectSpread(lr_articles_taxonomies_objectSpread({\n        only_include: true\n      }, sectionsQueryArgs), {}, {\n        taxonomy: "ta_article_section"\n      }),\n      fetchArgs: sectionsFetchArgs\n    });\n    taxQuery["ta_article_section"] = {\n      required: sectionsRequired,\n      field: sectionsQueryArgs.field,\n      terms: sections\n    };\n  } //Secciones\n\n\n  if (useAuthors) {\n    var _authorProps$terms = authorProps.terms,\n        authors = _authorProps$terms === void 0 ? [] : _authorProps$terms,\n        _authorProps$queryArg = authorProps.queryArgs,\n        authorsQueryArgs = _authorProps$queryArg === void 0 ? {} : _authorProps$queryArg,\n        _authorProps$fetchArg = authorProps.fetchArgs,\n        authorsFetchArgs = _authorProps$fetchArg === void 0 ? {} : _authorProps$fetchArg,\n        _authorProps$required = authorProps.required,\n        authorsRequired = _authorProps$required === void 0 ? false : _authorProps$required;\n    finalData.author = useRbTerms("ta_article_author", authors, {\n      termsQueryArgs: lr_articles_taxonomies_objectSpread(lr_articles_taxonomies_objectSpread({\n        only_include: true\n      }, authorsQueryArgs), {}, {\n        taxonomy: "ta_article_author"\n      }),\n      fetchArgs: authorsFetchArgs\n    });\n    taxQuery["ta_article_author"] = {\n      required: authorsRequired,\n      field: authorsQueryArgs.field,\n      terms: authors\n    };\n  }\n\n  finalData.taxQuery = rbTaxQuery(taxQuery);\n  return finalData;\n};\n;// CONCATENATED MODULE: ../../../../gutenberg/src/helpers/ta-article/lr-articles.js\nfunction lr_articles_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = lr_articles_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction lr_articles_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction lr_articles_slicedToArray(arr, i) { return lr_articles_arrayWithHoles(arr) || lr_articles_iterableToArrayLimit(arr, i) || lr_articles_unsupportedIterableToArray(arr, i) || lr_articles_nonIterableRest(); }\n\nfunction lr_articles_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction lr_articles_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return lr_articles_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return lr_articles_arrayLikeToArray(o, minLen); }\n\nfunction lr_articles_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction lr_articles_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction lr_articles_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction lr_articles_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction lr_articles_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { lr_articles_ownKeys(Object(source), true).forEach(function (key) { lr_articles_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { lr_articles_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction lr_articles_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nvar lr_articles_wp$element = wp.element,\n    lr_articles_useState = lr_articles_wp$element.useState,\n    lr_articles_useRef = lr_articles_wp$element.useRef;\nvar lr_articles_PanelBody = wp.components.PanelBody;\n/**\r\n*\tExpected to be used in blocks with articles filters attributes.\r\n*\t@param {mixed[]} attributes\t\t\t\t\t\t\t\t\t\t\t\t\tThe block attributes. Must contain articles filters attributes.\r\n*\t@param {function} setAttributes\t\t\t\t\t\t\t\t\t\t\t\tThe block\'s setAttributes function.\r\n*\t@param {object} taxonomiesFilters\t\t\t\t\t\t\t\t\t\t\tIndicates with taxonomy filters to use.\r\n*/\n\nfunction useTAArticlesManager() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var attributes = props.attributes,\n      setAttributes = props.setAttributes,\n      _props$taxonomiesFilt = props.taxonomiesFilters,\n      taxonomiesFilters = _props$taxonomiesFilt === void 0 ? {\n    tag: true,\n    section: true,\n    author: true\n  } : _props$taxonomiesFilt;\n  var mostRecentTurnedOff = lr_articles_useRef(false);\n  var mostRecentWasActive = lr_articles_useRef(false); // Chequeamos si la opcion de mas recientes fue apagada en este render, lo que provocaria un fetch\n\n  mostRecentTurnedOff.current = mostRecentWasActive.current && !attributes.most_recent;\n  mostRecentWasActive.current = attributes.most_recent; //================================================\n  //\tRENDERS\n  //================================================\n\n  var renderArticlesControls = function renderArticlesControls() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _props$articlesFilter = props.articlesFiltersProps,\n        articlesFiltersProps = _props$articlesFilter === void 0 ? {} : _props$articlesFilter;\n    articlesFiltersProps = lr_articles_objectSpread({\n      amountFilter: true,\n      mostRecentFilter: true,\n      taxonomiesData: lrTaxonomies,\n      attributes: attributes,\n      setAttributes: setAttributes,\n      requiredTaxonomies: true\n    }, articlesFiltersProps);\n    return /*#__PURE__*/React.createElement(lr_articles_PanelBody, {\n      title: "Filtros de Articulos",\n      icon: "",\n      initialOpen: false\n    }, /*#__PURE__*/React.createElement(LRArticlesFilters, articlesFiltersProps), !attributes.most_recent && /*#__PURE__*/React.createElement(lr_articles_PanelBody, {\n      title: "Art\\xEDculos",\n      icon: "",\n      initialOpen: false\n    }, /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(LRArticlesSelector, {\n      articles: articles,\n      onSelectionChange: function onSelectionChange(articles) {\n        return _onSelectionChange(articles);\n      }\n    }))));\n  }; //================================================\n  //\tHELPERS\n  //================================================\n\n\n  var _onSelectionChange = function _onSelectionChange(currentSelected) {\n    var newIds = [];\n    var newArticles = currentSelected.map(function (article) {\n      newIds.push(article.ID);\n      return {\n        data: article.ID,\n        type: \'article_post\'\n      };\n    });\n    updateArticlesData(newIds);\n    setAttributes({\n      articles_data: newArticles\n    }); //saves the new article\n  };\n\n  var hasOnlyOneTermFilter = function hasOnlyOneTermFilter() {\n    var most_recent = attributes.most_recent;\n    var section = lrTaxonomies.section,\n        tag = lrTaxonomies.tag,\n        author = lrTaxonomies.author;\n    var hasUniqueSection = section && section.termsData && section.termsData.length == 1 ? section.termsData[0] : false;\n    var hasUniqueTag = tag && tag.termsData && tag.termsData.length == 1 ? tag.termsData[0] : false;\n    var hasUniqueAuthor = author && author.termsData && author.termsData.length == 1 ? author.termsData[0] : false;\n    if (hasUniqueSection && !hasUniqueTag && !hasUniqueAuthor) return hasUniqueSection;\n    if (hasUniqueTag && !hasUniqueSection && !hasUniqueAuthor) return hasUniqueTag;\n    if (hasUniqueAuthor && !hasUniqueTag && !hasUniqueSection) return hasUniqueAuthor;\n    return false;\n  }; //================================================\n  //\tQUERY ARGS SETUP\n  //================================================\n\n\n  var lrTaxonomies = useLRArticlesTaxonomies({\n    usage: taxonomiesFilters,\n    tagProps: attributes.tags,\n    sectionProps: attributes.sections,\n    authorProps: attributes.authors\n  });\n  var postsQueryArgs = {\n    post_type: \'ta_article\'\n  };\n\n  if (attributes.most_recent) {\n    postsQueryArgs = lr_articles_objectSpread({\n      posts_per_page: attributes.amount,\n      tax_query: lrTaxonomies.taxQuery\n    }, postsQueryArgs);\n  } else {\n    postsQueryArgs = lr_articles_objectSpread({\n      post__in: attributes.articles_data ? attributes.articles_data.map(function (article) {\n        return article.data;\n      }) : null,\n      only_include: true,\n      orderby: \'post__in\',\n      with_thumbnail: true\n    }, postsQueryArgs);\n  } //================================================\n  //\tDATA FETCH & SET\n  //================================================\n\n\n  var _useLRArticlesData = useLRArticlesData({\n    fetchArgs: {\n      // Forzamos fetchs cuando estamos en mas recientes, o se cambia de mas recientes a seleccion manual\n      updateOnArgsChange: mostRecentTurnedOff.current || attributes.most_recent\n    },\n    postsQueryArgs: postsQueryArgs\n  }),\n      articles = _useLRArticlesData.articlesData,\n      articlesFetchStatus = _useLRArticlesData.articlesFetchStatus,\n      updateArticlesData = _useLRArticlesData.updateArticlesData;\n\n  var loadingArticles = articlesFetchStatus.loading,\n      articlesFetchError = articlesFetchStatus.error; // const articlesPosts = articlesData ? articlesData.map( (article) => article.post ) : null;\n  // const {\n  // \tarticles,\n  // \tfetching: fetchingArticles,\n  // \terror: articlesFetchError,\n  // } = useTAArticles({\n  // \tqueryArgs: \'test\',\n  // });\n  // console.log(articles);\n  //\n\n  return {\n    loadingArticles: loadingArticles,\n    articlesFetchError: articlesFetchError,\n    articles: articles,\n    renderArticlesControls: renderArticlesControls,\n    isTermArticles: hasOnlyOneTermFilter()\n  };\n}\n/**\r\n*\tFetchea y guarda los datos de articulos en base a query args\r\n*\tLuego del primer fetch, si los articulos cambian se debe correr\r\n*\treorganizeOrFetchArticles, que actualiza articlesData.\r\n*\t@return {json}\r\n*\t\t@property {LR_Article[]} articlesData\r\n*\t\t\tArray con los datos de los articulos actuales\r\n*\t\t@property {function} reorganizeOrFetchArticles\r\n*\t\t\tReorganiza o fetchea los datos de articulos. Si los ids pasados se encuentran\r\n*\t\t\ten el articlesData actual, se reoganiza y no se realiza el fetch.\r\n*\t\t\t@param {int[]} newArticlesIds\r\n*\t\t\t\tArray con las ids de los articulos a guardar. Si alguno de estos articulos\r\n*\t\t\t\tno se encuentra en articlesData, se realiza un fetch\r\n*\t\t@property {mixed} articlesFetchData\r\n*\t\t\tDatos del fetch\r\n*\t\t@property {mixed} articlesFetchStatus\r\n*\t\t\tEstado del fetch\r\n*\t\t\t@property {bool} loading\r\n*\t\t\t@property {bool} error\r\n*/\n\nfunction useLRArticlesData() {\n  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _args$postsQueryArgs = args.postsQueryArgs,\n      postsQueryArgs = _args$postsQueryArgs === void 0 ? {} : _args$postsQueryArgs,\n      _args$fetchArgs = args.fetchArgs,\n      fetchArgs = _args$fetchArgs === void 0 ? {} : _args$fetchArgs,\n      _args$initialArticles = args.initialArticles,\n      initialArticles = _args$initialArticles === void 0 ? [] : _args$initialArticles;\n\n  var _useState = lr_articles_useState(initialArticles),\n      _useState2 = lr_articles_slicedToArray(_useState, 2),\n      articlesData = _useState2[0],\n      setArticlesStateData = _useState2[1];\n\n  var _useState3 = lr_articles_useState(true),\n      _useState4 = lr_articles_slicedToArray(_useState3, 2),\n      needsFetch = _useState4[0],\n      setNeedsFetch = _useState4[1];\n\n  var needsPostsStateUpdate = lr_articles_useRef(true);\n\n  var setArticlesData = function setArticlesData(stateValue) {\n    setArticlesStateData(stateValue);\n  }; // Checks if there are new articles to fetch, or if it only has to reorganize the current set\n\n\n  var updateArticlesData = function updateArticlesData(newArticlesIds) {\n    var articlesState = checkArticlesState(newArticlesIds, articlesData);\n    if (!articlesState.needsFetch) setArticlesData(articlesState.articlesData);else setNeedsFetch(true);\n  }; // Do fetch only when query args changed, or when manually updating articles data and\n  // and a required article is not in articlesData\n\n\n  var updateOnArgsChange = needsFetch || fetchArgs && fetchArgs.updateOnArgsChange;\n\n  var _useLRArticlesFetch = useLRArticlesFetch(lr_articles_objectSpread(lr_articles_objectSpread({}, fetchArgs), {}, {\n    updateOnArgsChange: updateOnArgsChange,\n    onThen: function onThen(_ref) {\n      var responseData = _ref.responseData;\n      setArticlesStateData(responseData);\n      setNeedsFetch(false);\n    },\n    postsQueryArgs: lr_articles_objectSpread({\n      with_thumbnail: true\n    }, postsQueryArgs)\n  })),\n      articlesFetchData = _useLRArticlesFetch.articles,\n      articlesFetchStatus = _useLRArticlesFetch.status,\n      totalPages = _useLRArticlesFetch.totalPages;\n\n  return {\n    articlesFetchData: articlesFetchData,\n    articlesFetchStatus: articlesFetchStatus,\n    articlesData: articlesData,\n    setArticlesData: setArticlesData,\n    updateArticlesData: updateArticlesData,\n    totalPages: totalPages\n  };\n}\n/**\r\n*\tChequea si alguna id de newArticlesIds no se encuentra en articlesData\r\n*\tpara determinar si se necesita un fetch, o solo reorganizar\r\n*\t@param {int[]} newArticlesIds\r\n*\t\tIds de los articulos a guardar\r\n*\t@param {LR_Article[]} articlesData\r\n*\t\tArray con los articulos que se tienen actualmente\r\n*\t@return {json}\r\n*\t\t@property {bool} needsFetch\r\n*\t\t\tIndica si se necesita fetch o no\r\n*\t\t@property {bool} orderChanged\r\n*\t\t\tIndica si cambio el orden de los articulos (cuando no se requiere fetch)\r\n*\t\t@property {LR_Article[]|[]} articlesData\r\n*\t\t\tEl articlesData actualizada (cuando no se requiere fetch)\r\n*/\n\nvar checkArticlesState = function checkArticlesState(newArticlesIds, articlesData) {\n  var newArticlesData = [];\n  var orderChanged = false;\n  var needsFetch = false;\n\n  if (newArticlesIds.length > articlesData.length) {\n    needsFetch = true;\n  } else {\n    var _loop = function _loop(i) {\n      var articleID = newArticlesIds[i];\n      var index = articlesData.findIndex(function (article) {\n        return article.post.ID == articleID;\n      });\n\n      if (index == -1) {\n        needsFetch = true;\n        return "break";\n      }\n\n      if (i != index) orderChanged = true;\n      var articleData = articlesData[index];\n      newArticlesData.push(articleData);\n    };\n\n    for (var i = 0; i < newArticlesIds.length; i++) {\n      var _ret = _loop(i);\n\n      if (_ret === "break") break;\n    }\n  }\n\n  return {\n    needsFetch: needsFetch ? needsFetch : false,\n    orderChanged: orderChanged,\n    articlesData: newArticlesData\n  };\n};\n\nfunction useLRArticlesFetch(props) {\n  props = props ? props : {};\n\n  var _props = props,\n      _props$postsQueryArgs = _props.postsQueryArgs,\n      postsQueryArgs = _props$postsQueryArgs === void 0 ? {} : _props$postsQueryArgs,\n      fetchArgs = lr_articles_objectWithoutProperties(_props, ["postsQueryArgs"]);\n\n  var _useRbFetch = useRbFetch(\'/ta/v1/articles\', lr_articles_objectSpread(lr_articles_objectSpread({}, fetchArgs), {}, {\n    restPath: \'/ta/v1/articles\',\n    method: \'POST\',\n    queryArgs: postsQueryArgs,\n    data: {\n      args: postsQueryArgs\n    },\n    parse: false\n  })),\n      response = _useRbFetch.response,\n      responseData = _useRbFetch.responseData,\n      status = _useRbFetch.status;\n\n  return {\n    articles: responseData,\n    totalPages: response && response.headers ? parseInt(response.headers.get(\'X-WP-TotalPages\')) : 0,\n    status: status,\n    response: response\n  };\n}\n;// CONCATENATED MODULE: ../../../../gutenberg/src/components/lr-articles-selector/lr-articles-selector.js\nfunction lr_articles_selector_extends() { lr_articles_selector_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return lr_articles_selector_extends.apply(this, arguments); }\n\nfunction lr_articles_selector_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction lr_articles_selector_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { lr_articles_selector_ownKeys(Object(source), true).forEach(function (key) { lr_articles_selector_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { lr_articles_selector_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction lr_articles_selector_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction lr_articles_selector_slicedToArray(arr, i) { return lr_articles_selector_arrayWithHoles(arr) || lr_articles_selector_iterableToArrayLimit(arr, i) || lr_articles_selector_unsupportedIterableToArray(arr, i) || lr_articles_selector_nonIterableRest(); }\n\nfunction lr_articles_selector_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction lr_articles_selector_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return lr_articles_selector_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return lr_articles_selector_arrayLikeToArray(o, minLen); }\n\nfunction lr_articles_selector_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction lr_articles_selector_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction lr_articles_selector_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction lr_articles_selector_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = lr_articles_selector_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction lr_articles_selector_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nvar lr_articles_selector_useState = wp.element.useState;\nvar lr_articles_selector_PanelBody = wp.components.PanelBody;\n\n\n\n\n\nfunction useArticlesFetch(_ref) {\n  var postsQueryArgs = _ref.postsQueryArgs,\n      fetchArgs = _ref.fetchArgs;\n\n  var _useLRArticlesData = useLRArticlesData({\n    postsQueryArgs: postsQueryArgs,\n    fetchArgs: fetchArgs\n  }),\n      items = _useLRArticlesData.articlesData,\n      _useLRArticlesData$ar = _useLRArticlesData.articlesFetchStatus,\n      loading = _useLRArticlesData$ar.loading,\n      error = _useLRArticlesData$ar.error,\n      updateArticlesData = _useLRArticlesData.updateArticlesData,\n      totalPages = _useLRArticlesData.totalPages;\n\n  return {\n    items: items,\n    loading: loading,\n    error: error,\n    totalPages: totalPages\n  };\n}\n\nvar lr_articles_selector_LRArticlesSelector = function LRArticlesSelector() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _props$articles = props.articles,\n      articles = _props$articles === void 0 ? [] : _props$articles,\n      _props$onSelectionCha = props.onSelectionChange,\n      _onSelectionChange = _props$onSelectionCha === void 0 ? null : _props$onSelectionCha,\n      _props$postsArgs = props.postsArgs,\n      postsArgs = _props$postsArgs === void 0 ? {} : _props$postsArgs,\n      _props$useTaxonomiesF = props.useTaxonomiesFilters,\n      useTaxonomiesFilters = _props$useTaxonomiesF === void 0 ? true : _props$useTaxonomiesF,\n      _props$useAmountFilte = props.useAmountFilter,\n      useAmountFilter = _props$useAmountFilte === void 0 ? true : _props$useAmountFilte,\n      selectorProps = lr_articles_selector_objectWithoutProperties(props, ["articles", "onSelectionChange", "postsArgs", "useTaxonomiesFilters", "useAmountFilter"]);\n\n  var _useState = lr_articles_selector_useState({\n    amount: 10,\n    tags: {\n      terms: [],\n      required: false\n    },\n    sections: {\n      terms: [],\n      required: false\n    },\n    authors: {\n      terms: [],\n      required: false\n    }\n  }),\n      _useState2 = lr_articles_selector_slicedToArray(_useState, 2),\n      filtersAttributes = _useState2[0],\n      setFiltersAttributes = _useState2[1];\n\n  var mergueFilterAttributes = function mergueFilterAttributes(newAttributes) {\n    setFiltersAttributes(lr_articles_selector_objectSpread(lr_articles_selector_objectSpread({}, filtersAttributes), newAttributes));\n  };\n\n  var lrTaxonomies = useTaxonomiesFilters ? lr_articles_taxonomies_useLRArticlesTaxonomies({\n    usage: {\n      tag: true,\n      section: true,\n      author: true\n    },\n    tagProps: filtersAttributes.tags,\n    sectionProps: filtersAttributes.sections,\n    authorProps: filtersAttributes.authors\n  }) : {};\n\n  var setQueryFilters = function setQueryFilters(postsQueryArgs) {\n    if (useAmountFilter && filtersAttributes.amount !== null) postsQueryArgs.posts_per_page = filtersAttributes.amount;\n    if (useTaxonomiesFilters && lrTaxonomies.taxQuery) postsQueryArgs.tax_query = lrTaxonomies.taxQuery;\n    return postsQueryArgs;\n  };\n\n  var showFilters = function showFilters() {\n    return useTaxonomiesFilters || useAmountFilter;\n  };\n\n  return /*#__PURE__*/React.createElement(RBPostsSelector, lr_articles_selector_extends({\n    posts: articles,\n    onSelectionChange: function onSelectionChange(articles) {\n      return _onSelectionChange(articles);\n    },\n    fetchHook: useArticlesFetch,\n    getItemData: function getItemData(article) {\n      return {\n        id: article.post.ID,\n        detail: article.title\n      };\n    },\n    postsArgs: lr_articles_selector_objectSpread({\n      post_type: \'ta_article\',\n      with_thumbnail: true,\n      posts_per_page: 10\n    }, postsArgs),\n    filtersContent: showFilters() && /*#__PURE__*/React.createElement(lr_articles_selector_PanelBody, {\n      title: "Filtros avanzados",\n      icon: "search",\n      initialOpen: false\n    }, /*#__PURE__*/React.createElement(lr_articles_filter_LRArticlesFilters, {\n      amountFilter: true,\n      mostRecentFilter: false,\n      taxonomiesData: lrTaxonomies,\n      attributes: filtersAttributes,\n      setAttributes: mergueFilterAttributes,\n      requiredTaxonomies: true,\n      layoutType: \'compressed\'\n    })),\n    queryModifier: function queryModifier(postsQueryArgs) {\n      return setQueryFilters(postsQueryArgs);\n    },\n    labels: {// noSelectedItems: LRLabels.noArticlesSelected,\n    },\n    modalLabels: {// submitLabel: LRLabels.accept,\n      // openerLabel: LRLabels.selectArticles,\n      // modalTitle: LRLabels.articles,\n    },\n    itemsSelectorLabels: {// noSelectableItemsLabel: LRLabels.noArticlesFound,\n      // selectedItemsLabel: LRLabels.selectedArticles,\n      // loadingItemsLabel: LRLabels.loadingArticles,\n    }\n  }, selectorProps));\n};\n;// CONCATENATED MODULE: ../../../../gutenberg/src/helpers/posts/posts.js\nfunction posts_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction posts_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { posts_ownKeys(Object(source), true).forEach(function (key) { posts_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { posts_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction posts_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction posts_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction posts_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { posts_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { posts_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\nvar posts_wp = wp,\n    posts_apiFetch = posts_wp.apiFetch;\nfunction fetchRBPosts(args) {\n  var postsQueryArgs = args.postsQueryArgs;\n  var path = "/rb/v1/posts";\n  return posts_apiFetch({\n    method: \'POST\',\n    path: path,\n    parse: false,\n    data: {\n      args: postsQueryArgs\n    }\n  }).then(function (data) {\n    return data.json();\n  });\n}\n;\nvar useRBPosts = function useRBPosts(props) {\n  var posts = props.posts,\n      _props$postQueryField = props.postQueryField,\n      postQueryField = _props$postQueryField === void 0 ? \'post__in\' : _props$postQueryField,\n      _props$postsQueryArgs = props.postsQueryArgs,\n      postsQueryArgs = _props$postsQueryArgs === void 0 ? {} : _props$postsQueryArgs,\n      onChange = props.onChange;\n\n  var fetchPost = /*#__PURE__*/function () {\n    var _ref2 = posts_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {\n      var index, postFieldValue, fetchResult;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              index = _ref.index, postFieldValue = _ref.value;\n              _context.next = 3;\n              return fetchRBPosts({\n                postsQueryArgs: posts_objectSpread(posts_objectSpread({}, postsQueryArgs), {}, posts_defineProperty({}, postQueryField, [postFieldValue]))\n              });\n\n            case 3:\n              fetchResult = _context.sent;\n              return _context.abrupt("return", fetchResult && fetchResult.length == 1 ? fetchResult[0] : null);\n\n            case 5:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function fetchPost(_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  var _useFetchAndStore = useFetchAndStore({\n    values: posts,\n    fetchData: fetchPost,\n    onChange: onChange\n  }),\n      postsData = _useFetchAndStore.storedData,\n      setPostsData = _useFetchAndStore.setStoredData,\n      loading = _useFetchAndStore.loading,\n      error = _useFetchAndStore.error;\n\n  return {\n    postsData: postsData,\n    setPostsData: setPostsData,\n    loading: loading,\n    error: error\n  };\n};\n;// CONCATENATED MODULE: ../../../../gutenberg/src/helpers/ta-article/useTAArticles.js\nfunction useTAArticles_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction useTAArticles_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { useTAArticles_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { useTAArticles_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction useTAArticles_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction useTAArticles_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { useTAArticles_ownKeys(Object(source), true).forEach(function (key) { useTAArticles_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { useTAArticles_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction useTAArticles_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\nvar useTAArticles_wp = wp,\n    useTAArticles_apiFetch = useTAArticles_wp.apiFetch;\nfunction fetchTAArticles(args) {\n  var postsQueryArgs = args.postsQueryArgs;\n  var path = \'/ta/v1/articles\';\n  return useTAArticles_apiFetch({\n    method: \'POST\',\n    path: path,\n    parse: false,\n    data: {\n      args: useTAArticles_objectSpread({\n        post_type: \'ta_article\'\n      }, postsQueryArgs)\n    }\n  }).then(function (data) {\n    return data.json();\n  });\n}\n;\nvar useTAArticles = function useTAArticles(props) {\n  var posts = props.posts,\n      _props$postQueryField = props.postQueryField,\n      postQueryField = _props$postQueryField === void 0 ? \'post__in\' : _props$postQueryField,\n      _props$postsQueryArgs = props.postsQueryArgs,\n      postsQueryArgs = _props$postsQueryArgs === void 0 ? {} : _props$postsQueryArgs,\n      onChange = props.onChange;\n\n  var fetchPost = /*#__PURE__*/function () {\n    var _ref2 = useTAArticles_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {\n      var index, postFieldValue, fetchResult;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              index = _ref.index, postFieldValue = _ref.value;\n              _context.next = 3;\n              return fetchTAArticles({\n                postsQueryArgs: useTAArticles_objectSpread(useTAArticles_objectSpread({}, postsQueryArgs), {}, useTAArticles_defineProperty({}, postQueryField, [postFieldValue]))\n              });\n\n            case 3:\n              fetchResult = _context.sent;\n              return _context.abrupt("return", fetchResult && fetchResult.length == 1 ? fetchResult[0] : null);\n\n            case 5:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function fetchPost(_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  var _useFetchAndStore = useFetchAndStore({\n    values: posts,\n    fetchData: fetchPost,\n    onChange: onChange\n  }),\n      articlesData = _useFetchAndStore.storedData,\n      setArticlesData = _useFetchAndStore.setStoredData,\n      loading = _useFetchAndStore.loading,\n      error = _useFetchAndStore.error;\n\n  return {\n    articlesData: articlesData,\n    setArticlesData: setArticlesData,\n    loading: loading,\n    error: error\n  };\n};\n;// CONCATENATED MODULE: ../../../../gutenberg/src/blocks/ta-index/article-meta-nota-hermana.js\nfunction article_meta_nota_hermana_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction article_meta_nota_hermana_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { article_meta_nota_hermana_ownKeys(Object(source), true).forEach(function (key) { article_meta_nota_hermana_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { article_meta_nota_hermana_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction article_meta_nota_hermana_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction article_meta_nota_hermana_slicedToArray(arr, i) { return article_meta_nota_hermana_arrayWithHoles(arr) || article_meta_nota_hermana_iterableToArrayLimit(arr, i) || article_meta_nota_hermana_unsupportedIterableToArray(arr, i) || article_meta_nota_hermana_nonIterableRest(); }\n\nfunction article_meta_nota_hermana_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction article_meta_nota_hermana_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return article_meta_nota_hermana_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return article_meta_nota_hermana_arrayLikeToArray(o, minLen); }\n\nfunction article_meta_nota_hermana_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction article_meta_nota_hermana_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction article_meta_nota_hermana_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/**\r\n*   Adds a panel with a control to manage the sister article\r\n*/\n\n\n\n\n\nvar article_meta_nota_hermana_registerPlugin = wp.plugins.registerPlugin;\nvar article_meta_nota_hermana_PluginDocumentSettingPanel = wp.editPost.PluginDocumentSettingPanel;\nvar article_meta_nota_hermana_ = wp.i18n.__;\nvar article_meta_nota_hermana_useEntityProp = wp.coreData.useEntityProp;\nvar article_meta_nota_hermana_Spinner = wp.components.Spinner;\n\nvar TANotaHermanaPanel = function TANotaHermanaPanel() {\n  var postType = wp.data.select(\'core/editor\').getCurrentPostType();\n  if (postType !== \'ta_article\') return null;\n\n  var _useEntityProp = article_meta_nota_hermana_useEntityProp(\'postType\', postType, \'meta\'),\n      _useEntityProp2 = article_meta_nota_hermana_slicedToArray(_useEntityProp, 2),\n      meta = _useEntityProp2[0],\n      setMeta = _useEntityProp2[1];\n\n  var metaValue = meta && meta[\'ta_article_sister_article\'] ? meta[\'ta_article_sister_article\'] : null;\n\n  function updateMetaValue(posts) {\n    var postData = posts ? posts[0] : null;\n    var postID = postData ? postData.ID : null;\n    setArticlesData(postData ? [{\n      data: postData,\n      loading: false,\n      originalValue: postID\n    }] : []);\n    setMeta(article_meta_nota_hermana_objectSpread(article_meta_nota_hermana_objectSpread({}, meta), {}, {\n      \'ta_article_sister_article\': postID\n    }));\n  }\n\n  var _useTAArticles = useTAArticles({\n    posts: metaValue ? [metaValue] : [],\n    postsQueryArgs: {\n      post_type: \'ta_article\'\n    }\n  }),\n      articlesData = _useTAArticles.articlesData,\n      setArticlesData = _useTAArticles.setArticlesData;\n\n  var postFetched = articlesData && articlesData.length ? articlesData[0] : null;\n  var postData = postFetched ? postFetched.data : null;\n  var loading = postFetched ? postFetched.loading : false;\n  return /*#__PURE__*/external_React_default().createElement(article_meta_nota_hermana_PluginDocumentSettingPanel, {\n    name: "ta-nota-hermana",\n    title: "Nota Hermana",\n    className: "custom-panel"\n  }, /*#__PURE__*/external_React_default().createElement(lr_articles_selector_LRArticlesSelector, {\n    articles: postData ? [postData] : [],\n    postsArgs: {\n      post_type: \'ta_article\'\n    },\n    max: 1,\n    onSelectionChange: function onSelectionChange(data) {\n      return updateMetaValue(data);\n    },\n    sortable: false\n  }), loading && /*#__PURE__*/external_React_default().createElement(article_meta_nota_hermana_Spinner, null));\n};\n\narticle_meta_nota_hermana_registerPlugin(\'ta-article-nota-hermana\', {\n  render: TANotaHermanaPanel // icon: \'format-image\',\n\n});\n/*\r\n\r\nimport React, { useEffect } from "react";\r\nimport RBPostsSelector from \'../../components/rb-posts-selector/rb-posts-selector\';\r\nimport { useRBPosts } from \'../../helpers/posts/posts\';\r\nconst { registerPlugin } = wp.plugins;\r\nconst { PluginDocumentSettingPanel } = wp.editPost;\r\nconst { __ } = wp.i18n;\r\nconst { useEntityProp } = wp.coreData;\r\nconst { Spinner } = wp.components;\r\n\r\nconst TANotaHermanaPanel = () => {\r\n    const postType = wp.data.select( \'core/editor\' ).getCurrentPostType();\r\n    if(postType !== \'ta_article\')\r\n        return null;\r\n\r\n    const [ meta, setMeta ] = useEntityProp(\r\n        \'postType\',\r\n        postType,\r\n        \'meta\'\r\n    );\r\n    // useEffect( () => {\r\n    //     console.log(\'CAMBIO\', meta[\'ta_article_sister_article\']);\r\n    // },  meta[\'ta_article_sister_article\']);\r\n    const metaValue = meta && meta[\'ta_article_sister_article\'] ? meta[\'ta_article_sister_article\'] : null;\r\n    function updateMetaValue( posts ) {\r\n        const postData = posts ? posts[0] : null;\r\n        const postID = postData ? postData.ID : null;\r\n        setPostsData(postData ? [{ data: postData, loading: false, originalValue: postID }] : []);\r\n        setMeta( { ...meta, \'ta_article_sister_article\': postID } );\r\n    }\r\n\r\n    const {\r\n        postsData,\r\n        setPostsData,\r\n    } = useRBPosts({\r\n        posts: metaValue ? [metaValue] : [],\r\n        postsQueryArgs: {\r\n            post_type: \'ta_article\',\r\n        },\r\n        // onChange: (data) => {\r\n        //     console.log(\'ON CHANGE\', data);\r\n        // },\r\n    });\r\n\r\n    const postFetched = postsData && postsData.length ? postsData[0] : null;\r\n    const postData = postFetched ? postFetched.data : null;\r\n    const loading = postFetched ? postFetched.loading : false;\r\n\r\n    return (\r\n        <PluginDocumentSettingPanel\r\n            name="ta-nota-hermana"\r\n            title="Nota Hermana"\r\n            className="custom-panel"\r\n        >\r\n            <RBPostsSelector\r\n                posts = { postData ? [postData] : [] }\r\n                postsArgs = {{\r\n                    post_type: \'ta_article\',\r\n                }}\r\n                max = {1}\r\n                onSelectionChange = { (data) => updateMetaValue(data) }\r\n                sortable = {false}\r\n            />\r\n            { loading && <Spinner/> }\r\n        </PluginDocumentSettingPanel>\r\n    );\r\n};\r\n\r\nregisterPlugin( \'ta-article-nota-hermana\', {\r\n    render: TANotaHermanaPanel,\r\n    // icon: \'format-image\',\r\n} );\r\n*/\n;// CONCATENATED MODULE: ../../../../gutenberg/src/blocks/ta-index/article-meta-edicion-impresa.js\nfunction article_meta_edicion_impresa_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction article_meta_edicion_impresa_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { article_meta_edicion_impresa_ownKeys(Object(source), true).forEach(function (key) { article_meta_edicion_impresa_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { article_meta_edicion_impresa_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction article_meta_edicion_impresa_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction article_meta_edicion_impresa_slicedToArray(arr, i) { return article_meta_edicion_impresa_arrayWithHoles(arr) || article_meta_edicion_impresa_iterableToArrayLimit(arr, i) || article_meta_edicion_impresa_unsupportedIterableToArray(arr, i) || article_meta_edicion_impresa_nonIterableRest(); }\n\nfunction article_meta_edicion_impresa_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction article_meta_edicion_impresa_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return article_meta_edicion_impresa_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return article_meta_edicion_impresa_arrayLikeToArray(o, minLen); }\n\nfunction article_meta_edicion_impresa_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction article_meta_edicion_impresa_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction article_meta_edicion_impresa_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/**\r\n*   Adds a panel with a control to manage the related paper post\r\n*/\n\n\n\nvar article_meta_edicion_impresa_registerPlugin = wp.plugins.registerPlugin;\nvar article_meta_edicion_impresa_PluginDocumentSettingPanel = wp.editPost.PluginDocumentSettingPanel;\nvar article_meta_edicion_impresa_ = wp.i18n.__;\nvar article_meta_edicion_impresa_useEntityProp = wp.coreData.useEntityProp;\nvar article_meta_edicion_impresa_Spinner = wp.components.Spinner;\n\nvar TAEdicionImpresaPanel = function TAEdicionImpresaPanel() {\n  var postType = wp.data.select(\'core/editor\').getCurrentPostType();\n  if (postType !== \'ta_article\') return null;\n\n  var _useEntityProp = article_meta_edicion_impresa_useEntityProp(\'postType\', postType, \'meta\'),\n      _useEntityProp2 = article_meta_edicion_impresa_slicedToArray(_useEntityProp, 2),\n      meta = _useEntityProp2[0],\n      setMeta = _useEntityProp2[1];\n\n  var metaValue = meta && meta[\'ta_article_edicion_impresa\'] ? meta[\'ta_article_edicion_impresa\'] : null;\n\n  function updateMetaValue(posts) {\n    var postData = posts ? posts[0] : null;\n    var postID = postData ? postData.ID : null;\n    setPostsData(postData ? [{\n      data: postData,\n      loading: false,\n      originalValue: postID\n    }] : []);\n    setMeta(article_meta_edicion_impresa_objectSpread(article_meta_edicion_impresa_objectSpread({}, meta), {}, {\n      \'ta_article_edicion_impresa\': postID\n    }));\n  }\n\n  var _useRBPosts = useRBPosts({\n    posts: metaValue ? [metaValue] : [],\n    postsQueryArgs: {\n      post_type: \'ta_ed_impresa\'\n    } // onChange: (data) => {\n    //     console.log(\'ON CHANGE\', data);\n    // },\n\n  }),\n      postsData = _useRBPosts.postsData,\n      setPostsData = _useRBPosts.setPostsData;\n\n  var postFetched = postsData && postsData.length ? postsData[0] : null;\n  var postData = postFetched ? postFetched.data : null;\n  var loading = postFetched ? postFetched.loading : false;\n  return /*#__PURE__*/external_React_default().createElement(article_meta_edicion_impresa_PluginDocumentSettingPanel, {\n    name: "ta-ed-impresa",\n    title: "Edici\\xF3n Impresa",\n    className: "custom-panel"\n  }, /*#__PURE__*/external_React_default().createElement(RBPostsSelector, {\n    posts: postData ? [postData] : [],\n    postsArgs: {\n      post_type: \'ta_ed_impresa\'\n    },\n    max: 1,\n    onSelectionChange: function onSelectionChange(data) {\n      return updateMetaValue(data);\n    },\n    sortable: false\n  }), loading && /*#__PURE__*/external_React_default().createElement(article_meta_edicion_impresa_Spinner, null));\n};\n\narticle_meta_edicion_impresa_registerPlugin(\'ta-ed-impresa\', {\n  render: TAEdicionImpresaPanel // icon: \'format-image\',\n\n});\n;// CONCATENATED MODULE: ../../../../gutenberg/src/blocks/ta-index/admin-components.js\nfunction admin_components_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction admin_components_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { admin_components_ownKeys(Object(source), true).forEach(function (key) { admin_components_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { admin_components_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction admin_components_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = admin_components_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }\n\nfunction admin_components_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return admin_components_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return admin_components_arrayLikeToArray(o, minLen); }\n\nfunction admin_components_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n\nvar $ = __webpack_require__(609);\n\nMutationObserver = window.MutationObserver || window.WebKitMutationObserver;\nvar hooks = [];\n/**\r\n*   Runs a filter on every node in a tree and runs a callback for every match\r\n*   @param {Node} node                                                          The first node in the tree\r\n*   @param {Node} cb                                                            Callback to run on matched nodes\r\n*   @param {Node} filter                                                        Callback that indicates wheter a node is a match or not\r\n*   @param {Node} doMatchChilds                                                 If the filter should run on the children of matched nodes\r\n*/\n\nfunction doForEveryMatch(props) {\n  var node = props.node,\n      cb = props.cb,\n      filter = props.filter,\n      doMatchChilds = props.doMatchChilds;\n  var filterResult = filter(node);\n\n  if (filterResult) {\n    cb(node, filterResult);\n  }\n\n  if (node.children && !filterResult && doMatchChilds) {\n    var _iterator = _createForOfIteratorHelper(node.children),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var childNode = _step.value;\n        doForEveryMatch(admin_components_objectSpread(admin_components_objectSpread({}, props), {}, {\n          node: childNode\n        }));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n}\n/**\r\n*   Returns node hook info if matches any hook selector\r\n*/\n\n\nfunction getNodeComponentHook(node) {\n  return node && node.matches ? hooks.filter(function (hook) {\n    return node.matches(hook.querySelector);\n  })[0] : null;\n}\n/**\r\n*   Render the component inside a container that goes into node, to not lose\r\n*   the node reference in DOM\r\n*/\n\n\nfunction renderInside(_ref) {\n  var component = _ref.component,\n      node = _ref.node,\n      removeOldHtml = _ref.removeOldHtml;\n  var containerNode = document.createElement(\'div\');\n  if (removeOldHtml) node.innerHTML = \'\';\n  node.appendChild(containerNode);\n  node.componentContainer = containerNode;\n  (0,external_ReactDOM_namespaceObject.render)(component, containerNode);\n}\n\nfunction renderHook(_ref2) {\n  var node = _ref2.node,\n      hook = _ref2.hook;\n  console.log(\'renderHook\', hook);\n  renderInside({\n    component: hook.component({\n      node: node,\n      nodeBeforeMount: node.cloneNode(true)\n    }),\n    node: node,\n    removeOldHtml: hook.removeOldHtml\n  });\n}\n/**\r\n*   Listens to addition or removal of nodes that matches the querySelector and\r\n*   mount/unmount the desired component in them as needed.\r\n*/\n\n\nfunction hookComponentToNode(props) {\n  var component = props.component,\n      querySelector = props.querySelector,\n      removeOldHtml = props.removeOldHtml;\n  var hook = props;\n  hooks.push(hook); // Current Elements\n\n  document.querySelectorAll(querySelector).forEach(function (node, i) {\n    renderHook({\n      node: node,\n      hook: hook\n    });\n  });\n}\n/**\r\n*   Observe elements and add/remove components as needed\r\n*/\n\nvar obs = new MutationObserver(function (mutations, observer) {\n  if (!hooks || !hooks.length) return; // look through all mutations that just occured\n\n  for (var i = 0; i < mutations.length; ++i) {\n    // look through all added nodes of this mutation\n    for (var j = 0; j < mutations[i].addedNodes.length; ++j) {\n      var mutationNode = mutations[i].addedNodes[j]; // console.log(\'mutationNode\', mutations[i], mutationNode);\n\n      doForEveryMatch({\n        node: mutationNode,\n        doMatchChilds: true,\n        filter: function filter(node) {\n          return getNodeComponentHook(node);\n        },\n        cb: function cb(node, hook) {\n          // console.log("Component mounted", mounted, node, hook);\n          renderHook({\n            node: node,\n            hook: hook\n          });\n        }\n      });\n    } // look through all removed nodes of this mutation\n\n\n    for (var _j = 0; _j < mutations[i].removedNodes.length; ++_j) {\n      var _mutationNode = mutations[i].removedNodes[_j];\n      doForEveryMatch({\n        node: _mutationNode,\n        doMatchChilds: true,\n        filter: function filter(node) {\n          return node.componentContainer;\n        },\n        cb: function cb(node, componentContainer) {\n          console.log("Component unmounted");\n          (0,external_ReactDOM_namespaceObject.unmountComponentAtNode)(componentContainer);\n          componentContainer.parentNode.removeChild(componentContainer);\n        }\n      });\n    }\n  }\n\n  console.log(\'MutationObserver end\');\n});\nobs.observe(document.body, {\n  childList: true,\n  subtree: true\n});\n/************\r\n*   TEST\r\n************/\n// hookComponentToNode({\n//     component: () => <div className="ta_article_images_columntest">Test</div>,\n//     querySelector: `.ta_article_images_column`,\n// });\n// Test control en attachment data\n// hookComponentToNode({\n//     Item: <div className="ta_article_images_column">Test</div>,\n//     querySelector: `.compat-field-ta_attachment_author`,\n// });\n;// CONCATENATED MODULE: ../../../../gutenberg/src/blocks/ta-index/media-popup-photographer.js\nfunction media_popup_photographer_slicedToArray(arr, i) { return media_popup_photographer_arrayWithHoles(arr) || media_popup_photographer_iterableToArrayLimit(arr, i) || media_popup_photographer_unsupportedIterableToArray(arr, i) || media_popup_photographer_nonIterableRest(); }\n\nfunction media_popup_photographer_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction media_popup_photographer_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return media_popup_photographer_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return media_popup_photographer_arrayLikeToArray(o, minLen); }\n\nfunction media_popup_photographer_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction media_popup_photographer_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction media_popup_photographer_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\nvar media_popup_photographer_useSelect = wp.data.useSelect;\n\n\nvar media_popup_photographer_$ = __webpack_require__(609);\n\nvar MediaPopupPhotographerSelector = function MediaPopupPhotographerSelector(props) {\n  var node = props.node,\n      updateCallback = props.onUpdate;\n\n  var _useState = (0,external_React_.useState)([]),\n      _useState2 = media_popup_photographer_slicedToArray(_useState, 2),\n      termSlugs = _useState2[0],\n      setTermSlugs = _useState2[1];\n\n  var _useState3 = (0,external_React_.useState)(false),\n      _useState4 = media_popup_photographer_slicedToArray(_useState3, 2),\n      prepared = _useState4[0],\n      setPrepared = _useState4[1];\n\n  var _useState5 = (0,external_React_.useState)(null),\n      _useState6 = media_popup_photographer_slicedToArray(_useState5, 2),\n      attachmentID = _useState6[0],\n      setAttachmentID = _useState6[1];\n\n  var value = termSlugs.join(\',\');\n  (0,external_React_.useEffect)(function () {\n    var labelFor = node.querySelector(\'input.text\').attributes.id.value;\n    var inputValue = node.querySelector(\'input.text\').value;\n    var value = inputValue && inputValue.trim() ? inputValue.split(\',\') : [];\n    var firstDashIdx = labelFor.indexOf("-");\n    var secondDashIndx = labelFor.indexOf("-", firstDashIdx + 1);\n    var attachmentID = labelFor.substring(firstDashIdx + 1, secondDashIndx);\n    setAttachmentID(attachmentID);\n    setTermSlugs(value);\n    setPrepared(true);\n  }, [node]);\n\n  var onUpdate = function onUpdate(data) {\n    var termsData = data.termsData,\n        dataBeingFetched = data.dataBeingFetched;\n    if (dataBeingFetched) return;\n    if (!!termsData || !termsData.length) setTermSlugs([]);\n    var slugs = termsData.map(function (termData) {\n      return termData.data.slug;\n    });\n    setTermSlugs(slugs);\n    if (updateCallback) updateCallback({\n      slugs: slugs\n    });\n  }; // const terms = useSelect( ( select, props ) => {\n  //     const { getEntityRecords } = select( \'core\' );\n  //     console.log(attachmentID);\n  //     const terms = getEntityRecords( \'taxonomy\', \'ta_photographer\', {\n  //         slug: value,\n  //         post: attachmentID,\n  //     });\n  //     console.log(terms);\n  //     return terms;\n  // } );\n\n\n  return /*#__PURE__*/external_React_default().createElement((external_React_default()).Fragment, null, !prepared && /*#__PURE__*/external_React_default().createElement("p", null, "Cargando"), prepared && /*#__PURE__*/external_React_default().createElement((external_React_default()).Fragment, null, /*#__PURE__*/external_React_default().createElement(RBTermsSelector_RBTermsSelector, {\n    taxonomy: "ta_photographer",\n    terms: termSlugs,\n    termsQueryField: "slug",\n    onUpdate: onUpdate,\n    max: 1,\n    sortable: false\n  })));\n};\n\nhookComponentToNode({\n  component: function component(_ref) {\n    var node = _ref.node,\n        nodeBeforeMount = _ref.nodeBeforeMount;\n\n    var onUpdate = function onUpdate(_ref2) {\n      var slugs = _ref2.slugs;\n      media_popup_photographer_$(node).find(\'input.text\').focus().val(slugs.join(\',\')).trigger(\'change\'); // console.log($(node).find(\'input.text\'));\n    };\n\n    return /*#__PURE__*/external_React_default().createElement(MediaPopupPhotographerSelector, {\n      node: nodeBeforeMount,\n      onUpdate: onUpdate\n    });\n  },\n  querySelector: ".media-sidebar .compat-field-ta_photographer .field",\n  removeOldHtml: false\n});\n;// CONCATENATED MODULE: ../../../../gutenberg/src/blocks/ta-index/commentary-author-selector.js\nfunction commentary_author_selector_slicedToArray(arr, i) { return commentary_author_selector_arrayWithHoles(arr) || commentary_author_selector_iterableToArrayLimit(arr, i) || commentary_author_selector_unsupportedIterableToArray(arr, i) || commentary_author_selector_nonIterableRest(); }\n\nfunction commentary_author_selector_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction commentary_author_selector_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return commentary_author_selector_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return commentary_author_selector_arrayLikeToArray(o, minLen); }\n\nfunction commentary_author_selector_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction commentary_author_selector_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction commentary_author_selector_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/**\r\n*   Replaces the terms selector for the ta_article_author taxonomy in gutenberg editor\r\n*/\n\n\n\nvar commentary_author_selector_wp = wp,\n    commentary_author_selector_apiFetch = commentary_author_selector_wp.apiFetch;\nvar commentary_author_selector_addQueryArgs = wp.url.addQueryArgs;\nvar commentary_author_selector_wp$data = wp.data,\n    commentary_author_selector_useSelect = commentary_author_selector_wp$data.useSelect,\n    commentary_author_selector_useDispatch = commentary_author_selector_wp$data.useDispatch;\nvar commentary_author_selector_Spinner = wp.components.Spinner;\n\nvar commentary_author_selector_$ = __webpack_require__(609);\n\nvar CommentReplyAuthorSelector = function CommentReplyAuthorSelector() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var node = props.node,\n      updateCallback = props.onUpdate;\n\n  var _useState = (0,external_React_.useState)(null),\n      _useState2 = commentary_author_selector_slicedToArray(_useState, 2),\n      termID = _useState2[0],\n      setTermID = _useState2[1];\n\n  var _useState3 = (0,external_React_.useState)(true),\n      _useState4 = commentary_author_selector_slicedToArray(_useState3, 2),\n      loading = _useState4[0],\n      setLoading = _useState4[1];\n\n  (0,external_React_.useEffect)(function () {\n    if (commentReply.act != \'edit-comment\' || !commentReply.cid) {\n      setLoading(false);\n      return;\n    }\n\n    commentary_author_selector_apiFetch({\n      path: "/wp/v2/comments/".concat(commentReply.cid)\n    }).then(function (comment) {\n      console.log(\'COMMENT\', comment);\n      if (comment && comment.meta && comment.meta.ta_comment_author) setTermID(comment.meta.ta_comment_author);\n      setLoading(false);\n    });\n  }, []);\n\n  var onUpdate = function onUpdate(data) {\n    var termsData = data.termsData,\n        dataBeingFetched = data.dataBeingFetched;\n    if (dataBeingFetched) return;\n    var newTermID = null;\n\n    if (termsData && termsData.length && termsData[0].data) {\n      newTermID = termsData[0].data.id;\n      console.log(newTermID);\n    } // console.log(\'SET TERM ID\', newTermID);\n\n\n    setTermID(newTermID);\n    if (updateCallback) updateCallback({\n      termID: newTermID\n    });\n  };\n\n  return /*#__PURE__*/external_React_default().createElement((external_React_default()).Fragment, null, loading && /*#__PURE__*/external_React_default().createElement("p", null, /*#__PURE__*/external_React_default().createElement(commentary_author_selector_Spinner, null), " Cargando"), !loading && /*#__PURE__*/external_React_default().createElement((external_React_default()).Fragment, null, /*#__PURE__*/external_React_default().createElement(RBTermsSelector_RBTermsSelector, {\n    taxonomy: "ta_article_author",\n    terms: termID ? [termID] : [],\n    termsQueryField: "include",\n    onUpdate: onUpdate,\n    max: 1,\n    sortable: false\n  })));\n};\n\nhookComponentToNode({\n  component: function component(_ref) {\n    var node = _ref.node,\n        nodeBeforeMount = _ref.nodeBeforeMount;\n\n    var onUpdate = function onUpdate(_ref2) {\n      var termID = _ref2.termID;\n      commentary_author_selector_$(node).find(\'input[name="ta_comment_author"]\').focus().val(termID).trigger(\'change\');\n    };\n\n    return /*#__PURE__*/external_React_default().createElement(CommentReplyAuthorSelector, {\n      node: nodeBeforeMount,\n      onUpdate: onUpdate\n    });\n  },\n  querySelector: "#replyrow:not([style*=\\"display:none;\\"]) .photographer-field",\n  removeOldHtml: false\n});\n;// CONCATENATED MODULE: ../../../../gutenberg/src/blocks/ta-index/block.js\n\n\n\n\n\n\n\n // import {hookComponentToNode} from \'./admin-components\';\n// setTimeout( () => {\n//     // render(<TAAuthorsSelector/>, document.querySelector(\'.wp-admin.index-php #wpbody\'));\n//     render(<TAAuthorsSelector/>, document.getElementById(\'wpbody\'));\n// }, 2000)\n\n//# sourceURL=webpack://gen-gutenberg/../../../../gutenberg/src/blocks/ta-index/block.js_+_77_modules?')},366:()=>{eval("// Keep track of our locks\nvar locks = [];\n\nfunction lock(lockIt, handle, message) {\n  if (lockIt) {\n    if (!locks[handle]) {\n      locks[handle] = true;\n      wp.data.dispatch('core/editor').lockPostSaving(handle);\n      wp.data.dispatch('core/notices').createNotice('error', message, {\n        id: handle,\n        isDismissible: false\n      });\n    }\n  } else if (locks[handle]) {\n    locks[handle] = false;\n    wp.data.dispatch('core/editor').unlockPostSaving(handle);\n    wp.data.dispatch('core/notices').removeNotice(handle);\n  }\n}\n/********************************************************************\r\n *   Determine required taxonomies\r\n *********************************************************************/\n\n\nvar requiredTaxonomies = null;\nvar taxonomies = null;\nvar requiredTaxonomiesUnsubscribe = wp.data.subscribe(function () {\n  var currentPost = wp.data.select('core/editor').getCurrentPost();\n  if (!currentPost || !currentPost.rb_config || !currentPost.rb_config.required_taxonomies) return;\n  requiredTaxonomies = currentPost.rb_config.required_taxonomies;\n  requiredTaxonomiesUnsubscribe();\n});\n/********************************************************************\r\n *   Lock/Unlock based on required taxonomies\r\n *********************************************************************/\n\nwp.data.subscribe(function () {\n  if (!requiredTaxonomies) return;\n\n  for (var taxonomySlug in requiredTaxonomies) {\n    if (!requiredTaxonomies.hasOwnProperty(taxonomySlug)) continue; // get custom taxonomy\n\n    var taxonomyTerms = wp.data.select('core/editor').getEditedPostAttribute(taxonomySlug);\n    var taxonomy = wp.data.select('core').getTaxonomy(taxonomySlug);\n    if (!taxonomy) continue;\n    var condition = requiredTaxonomies[taxonomySlug]; // Lock post if there are no custom taxonomy terms selected\n\n    lock(condition && taxonomyTerms && !taxonomyTerms.length, \"\".concat(taxonomySlug, \"-lock\"), taxonomy.rb_config.labels.required_term_missing);\n  }\n});\n\n//# sourceURL=webpack://gen-gutenberg/../../../../gutenberg/src/blocks/ta-index/required-taxonomies.js?")},821:(module,exports)=>{eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  Copyright (c) 2018 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames() {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tif (arg.length) {\n\t\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\t\tif (inner) {\n\t\t\t\t\t\tclasses.push(inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tif (arg.toString === Object.prototype.toString) {\n\t\t\t\t\tfor (var key in arg) {\n\t\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tclasses.push(arg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif ( true && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}());\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../../node_modules/classnames/index.js?")},599:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, ".rb-autocomplete-list .rb-autocomplete{margin-bottom:1rem}.rb-autocomplete-list .items-list{margin-right:-0.2rem}.rb-autocomplete-list .items-list .item{display:inline-flex;background:#ddd;border-radius:1rem;padding:3px 12px;margin-right:.2rem;margin-bottom:.2rem;border:solid #ddd}.rb-autocomplete-list .items-list .item.sortable-chosen.sortable-ghost{opacity:.5;border-style:dashed;border-color:#3c434a}.rb-autocomplete-list .items-list .item .title{margin-right:8px;user-select:none;font-size:11px}.rb-autocomplete-list .items-list .item .rmv-btn{cursor:pointer;display:flex;align-items:center;justify-content:center}.rb-autocomplete-list .items-list .item .rmv-btn .dashicon{font-size:13px;height:initial;width:initial}", ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../gutenberg/src/components/RBAutocompleteList/css/style.css?../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js')},975:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, ".rb-autocomplete{position:relative}.rb-autocomplete .search-input{width:100%;box-sizing:border-box;margin:0}.rb-autocomplete .dropdown{background:#fff;width:100%;position:absolute;z-index:10;top:100%;border:solid 1px gray;border-top:0;box-sizing:border-box}.rb-autocomplete .result-item{padding:.5rem 1rem;cursor:pointer;transition:all .3s}.rb-autocomplete .result-item:nth-child(even){background-color:#f6f6f6}.rb-autocomplete .result-item:hover{background-color:#2271b1;color:#fff}.rb-autocomplete .result-item .title{margin:0}", ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../gutenberg/src/components/RBAutocomplete/css/style.css?../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js')},902:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, ".ta-article-author-meta{position:relative;background:#d1f2ff;margin-bottom:1rem}.ta-article-author-meta>.header{background-color:#16a1dc;cursor:pointer}.ta-article-author-meta>.header .name{text-align:center;font-weight:bold;text-transform:unset;padding:.5rem;color:#fff}.ta-article-author-meta .photo-container{display:flex;align-items:center;justify-content:center}.ta-article-author-meta .photo-container .photo{height:5rem;width:5rem;border-radius:0;background-position:center;background-size:cover}.ta-article-author-meta .input-container{margin-bottom:1rem}.ta-article-author-meta .remove-author{color:red;text-align:right}.ta-article-author-meta .remove-author .remove-btn{margin-bottom:0;cursor:pointer;display:inline-block}", ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../gutenberg/src/components/TAArticleAuthorMetaBlock/css/style.css?../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js')},311:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, ".ta-etiquetador{border:solid;border:solid 4px #007cba}.ta-etiquetador .tags-container{margin:0 -0.25rem -0.25rem -0.25rem}.ta-etiquetador .tags-container .tag-btn{margin:0 .25rem .25rem .25rem}button{user-select:none}.ta-etiquetador .header .title{background:#007cba;color:#fff;padding:.2rem 1rem;font-size:1rem;margin-bottom:1rem;text-align:center}.ta-etiquetador .generator-btn{width:100%;text-align:center;justify-content:center;border-radius:0}.ta-etiquetador .tags-container{margin-bottom:2rem;padding:0rem .2rem}.ta-etiquetador .loading-spinner{text-align:center}", ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../gutenberg/src/components/TAEtiquetador/style.css?../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js')},553:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, ".lr-articles-filters-component{margin-bottom:1rem}.lr-articles-filters-component.compressed-layout .panel-bodies{display:flex;flex-wrap:wrap;justify-content:space-between}.lr-articles-filters-component.compressed-layout .panel-bodies>.components-panel__body{width:49%}", ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../gutenberg/src/components/lr-articles-filter/editor.css?../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js')},291:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, ".rb-items-selector .items-selector-list .item.selected .item-content{background-color:#00d5ff;opacity:.5}", ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../gutenberg/src/components/rb-item-selector/style.css?../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js')},105:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, ".rb-list-with-actions{margin-bottom:1rem}.rb-list-container.rb-list-with-actions .item .item-content{padding:0}.rb-list-with-actions .item>.item-content{display:flex}", ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../gutenberg/src/components/rb-list-with-actions/style.css?../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js')},53:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, ".rb-list-container .item .item-content{color:#000;background-color:#f1f1f1;width:100%;padding:.25rem .5rem;min-width:0}.rb-list-container .item:nth-child(even) .item-content{background-color:#e4e4e4}", ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../gutenberg/src/components/rb-list/style.css?../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js')},526:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, ".rb-paginator{display:flex;justify-content:space-between;margin-bottom:1rem}.rb-paginator .pagination{display:flex;font-size:.5rem;overflow:hidden;align-items:center;width:100%;margin:0 1rem}.rb-paginator .pagination .pag{position:relative;transition:all .3s;margin:0 .1rem;cursor:pointer;user-select:none}.rb-paginator .pagination.disabled .pag{color:#d0d0d0}.rb-paginator .pagination .current{font-size:2rem}.rb-paginator .pagination .prev,.rb-paginator .pagination .next,.rb-paginator .pagination .dist-1{font-size:1.5rem}.rb-paginator .pagination .prev-2,.rb-paginator .pagination .next-2,.rb-paginator .pagination .dist-2{font-size:1rem}", ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../gutenberg/src/components/rb-paginator/style.css?../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js')},250:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, ".rb-actions-row{display:flex;align-items:center;width:100%}.rb-actions-row>.data{margin-right:1rem;padding:.25rem 0;padding-left:.25rem;width:100%;white-space:nowrap;min-width:0;text-overflow:ellipsis;overflow:hidden;font-weight:500}.rb-actions-row .actions{display:flex;height:100%}.rb-actions-row .actions button{height:100%}.selected-posts-list{margin-bottom:2rem}", ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../gutenberg/src/components/rb-row-actions/style.css?../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js')},685:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, ".rb-search-filter{margin-bottom:1rem}.rb-search-filter input{width:100%}", ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../gutenberg/src/components/rb-selector-from-fetch/style.css?../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js')},825:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, ".rb-sortable-list-container .item.helper-item .item-content{background-color:#75fff25e}.rb-sortable-list-container .item{display:-ms-flexbox;display:flex;border-bottom:solid 1px #ffffff78}.rb-sortable-list-container .item .item-handle{width:2rem;background-color:#6fc6ff;color:#fff;display:flex;align-items:center;justify-content:center;cursor:move}.rb-sortable-list-container .item .item-handle .icon{height:1.2rem}", ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../gutenberg/src/components/rb-sortable-list/style.css?../../../../../node_modules/css-loader/dist/cjs.js!../../../../../node_modules/sass-loader/dist/cjs.js')},70:module=>{"use strict";eval('\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item);\n\n      if (item[2]) {\n        return "@media ".concat(item[2], " {").concat(content, "}");\n      }\n\n      return content;\n    }).join("");\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === "string") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, ""]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\n//# sourceURL=webpack://gen-gutenberg/../../../../../node_modules/css-loader/dist/runtime/api.js?')},386:module=>{"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (false) {}\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../../node_modules/invariant/browser.js?")},233:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = __webpack_require__(651);\n\nfunction emptyFunction() {}\nfunction emptyFunctionWithReset() {}\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    var err = new Error(\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n    err.name = 'Invariant Violation';\n    throw err;\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../../node_modules/prop-types/factoryWithThrowingShims.js?")},891:(module,__unused_webpack_exports,__webpack_require__)=>{eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (false) { var throwOnDirectAccess, ReactIs; } else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = __webpack_require__(233)();\n}\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../../node_modules/prop-types/index.js?")},651:module=>{"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../../node_modules/prop-types/lib/ReactPropTypesSecret.js?")},320:(__unused_webpack_module,exports,__webpack_require__)=>{eval('var __webpack_unused_export__;\nvar e=g(__webpack_require__(890)),t=__webpack_require__(804),n=t.Children,r=t.cloneElement,o=t.Component,i=t.createElement,l=t.createRef,a=g(__webpack_require__(821)),c=__webpack_require__(304),s=g(c);__webpack_unused_export__=s;var u=c.Direction;__webpack_unused_export__=u;var f=c.DOMRect;__webpack_unused_export__=f;var p=c.GroupOptions;__webpack_unused_export__=p;var d=c.MoveEvent;__webpack_unused_export__=d;var b=c.Options;__webpack_unused_export__=b;var y=c.PullResult;__webpack_unused_export__=y;var v=c.PutResult;__webpack_unused_export__=v;var h=c.SortableEvent;__webpack_unused_export__=h;var m=c.SortableOptions;__webpack_unused_export__=m;var O=c.Utils;function g(e){return e&&e.__esModule?e.default:e}function w(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}function S(e){return function(e){if(Array.isArray(e))return j(e)}(e)||function(e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||function(e,t){if(!e)return;if("string"==typeof e)return j(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return j(e,t)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function j(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function x(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function I(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?x(Object(n),!0).forEach((function(t){P(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):x(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function P(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function E(e){null!==e.parentElement&&e.parentElement.removeChild(e)}function k(e){e.forEach((function(e){return E(e.element)}))}function C(e){e.forEach((function(e){var t,n,r,o;t=e.parentElement,n=e.element,r=e.oldIndex,o=t.children[r]||null,t.insertBefore(n,o)}))}function D(e,t){var n=M(e),r={parentElement:e.from},o=[];switch(n){case"normal":o=[{element:e.item,newIndex:e.newIndex,oldIndex:e.oldIndex,parentElement:e.from}];break;case"swap":o=[I({element:e.item,oldIndex:e.oldIndex,newIndex:e.newIndex},r),I({element:e.swapItem,oldIndex:e.newIndex,newIndex:e.oldIndex},r)];break;case"multidrag":o=e.oldIndicies.map((function(t,n){return I({element:t.multiDragElement,oldIndex:t.index,newIndex:e.newIndicies[n].index},r)}))}return function(e,t){return e.map((function(e){return I(I({},e),{},{item:t[e.oldIndex]})})).sort((function(e,t){return e.oldIndex-t.oldIndex}))}(o,t)}function A(e,t){var n=S(t);return e.concat().reverse().forEach((function(e){return n.splice(e.oldIndex,1)})),n}function R(e,t,n,r){var o=S(t);return e.forEach((function(e){var t=r&&n&&r(e.item,n);o.splice(e.newIndex,0,t||e.item)})),o}function M(e){return e.oldIndicies&&e.oldIndicies.length>0?"multidrag":e.swapItem?"swap":"normal"}function U(e){return(U="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function L(e){return function(e){if(Array.isArray(e))return _(e)}(e)||function(e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||function(e,t){if(!e)return;if("string"==typeof e)return _(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _(e,t)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function _(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function H(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function N(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?H(Object(n),!0).forEach((function(t){B(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):H(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function q(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function T(e,t){return(T=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function F(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,r=$(e);if(t){var o=$(this).constructor;n=Reflect.construct(r,arguments,o)}else n=r.apply(this,arguments);return G(this,n)}}function G(e,t){return!t||"object"!==U(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return e}(e):t}function $(e){return($=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function B(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}__webpack_unused_export__=O;var J={dragging:null},z=function(t){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&T(e,t)}(d,o);var c,u,f,p=F(d);function d(t){var n;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,d),(n=p.call(this,t)).ref=l();var r=t.list.map((function(e){return N(N({},e),{},{chosen:!1,selected:!1})}));return t.setList(r,n.sortable,J),e(!t.plugins,\'\\nPlugins prop is no longer supported.\\nInstead, mount it with "Sortable.mount(new MultiDrag())"\\nPlease read the updated README.md at https://github.com/SortableJS/react-sortablejs.\\n      \'),n}return c=d,(u=[{key:"componentDidMount",value:function(){if(null!==this.ref.current){var e=this.makeOptions();s.create(this.ref.current,e)}}},{key:"render",value:function(){var e=this.props,t=e.tag,n={style:e.style,className:e.className,id:e.id};return i(t&&null!==t?t:"div",N({ref:this.ref},n),this.getChildren())}},{key:"getChildren",value:function(){var e=this.props,t=e.children,o=e.dataIdAttr,i=e.selectedClass,l=void 0===i?"sortable-selected":i,c=e.chosenClass,s=void 0===c?"sortable-chosen":c,u=(e.dragClass,e.fallbackClass,e.ghostClass,e.swapClass,e.filter),f=void 0===u?"sortable-filter":u,p=e.list;if(!t||null==t)return null;var d=o||"data-id";return n.map(t,(function(e,t){var n,o,i=p[t],c=e.props.className,u="string"==typeof f&&B({},f.replace(".",""),!!i.filtered),b=a(c,N((B(n={},l,i.selected),B(n,s,i.chosen),n),u));return r(e,(B(o={},d,e.key),B(o,"className",b),o))}))}},{key:"makeOptions",value:function(){var e,t=this,n=((e=this.props).list,e.setList,e.children,e.tag,e.style,e.className,e.clone,e.onAdd,e.onChange,e.onChoose,e.onClone,e.onEnd,e.onFilter,e.onRemove,e.onSort,e.onStart,e.onUnchoose,e.onUpdate,e.onMove,e.onSpill,e.onSelect,e.onDeselect,w(e,["list","setList","children","tag","style","className","clone","onAdd","onChange","onChoose","onClone","onEnd","onFilter","onRemove","onSort","onStart","onUnchoose","onUpdate","onMove","onSpill","onSelect","onDeselect"]));return["onAdd","onChoose","onDeselect","onEnd","onRemove","onSelect","onSpill","onStart","onUnchoose","onUpdate"].forEach((function(e){return n[e]=t.prepareOnHandlerPropAndDOM(e)})),["onChange","onClone","onFilter","onSort"].forEach((function(e){return n[e]=t.prepareOnHandlerProp(e)})),N(N({},n),{},{onMove:function(e,n){var r=t.props.onMove,o=e.willInsertAfter||-1;if(!r)return o;var i=r(e,n,t.sortable,J);return void 0!==i&&i}})}},{key:"prepareOnHandlerPropAndDOM",value:function(e){var t=this;return function(n){t.callOnHandlerProp(n,e),t[e](n)}}},{key:"prepareOnHandlerProp",value:function(e){var t=this;return function(n){t.callOnHandlerProp(n,e)}}},{key:"callOnHandlerProp",value:function(e,t){var n=this.props[t];n&&n(e,this.sortable,J)}},{key:"onAdd",value:function(e){var t=this.props,n=t.list,r=t.setList,o=t.clone,i=D(e,L(J.dragging.props.list));k(i),r(R(i,n,e,o).map((function(e){return N(N({},e),{},{selected:!1})})),this.sortable,J)}},{key:"onRemove",value:function(t){var n=this,r=this.props,o=r.list,i=r.setList,l=M(t),a=D(t,o);C(a);var c=L(o);if("clone"!==t.pullMode)c=A(a,c);else{var s=a;switch(l){case"multidrag":s=a.map((function(e,n){return N(N({},e),{},{element:t.clones[n]})}));break;case"normal":s=a.map((function(e){return N(N({},e),{},{element:t.clone})}));break;case"swap":default:e(!0,\'mode "\'.concat(l,\'" cannot clone. Please remove "props.clone" from <ReactSortable/> when using the "\').concat(l,\'" plugin\'))}k(s),a.forEach((function(e){var r=e.oldIndex,o=n.props.clone(e.item,t);c.splice(r,1,o)}))}i(c=c.map((function(e){return N(N({},e),{},{selected:!1})})),this.sortable,J)}},{key:"onUpdate",value:function(e){var t=this.props,n=t.list,r=t.setList,o=D(e,n);return k(o),C(o),r(function(e,t){return R(e,A(e,t))}(o,n),this.sortable,J)}},{key:"onStart",value:function(){J.dragging=this}},{key:"onEnd",value:function(){J.dragging=null}},{key:"onChoose",value:function(e){var t=this.props,n=t.list;(0,t.setList)(n.map((function(t,n){return n===e.oldIndex?N(N({},t),{},{chosen:!0}):t})),this.sortable,J)}},{key:"onUnchoose",value:function(e){var t=this.props,n=t.list;(0,t.setList)(n.map((function(t,n){return n===e.oldIndex?N(N({},t),{},{chosen:!1}):t})),this.sortable,J)}},{key:"onSpill",value:function(e){var t=this.props,n=t.removeOnSpill,r=t.revertOnSpill;n&&!r&&E(e.item)}},{key:"onSelect",value:function(e){var t=this.props,n=t.list,r=t.setList,o=n.map((function(e){return N(N({},e),{},{selected:!1})}));e.newIndicies.forEach((function(t){var n=t.index;if(-1===n)return console.log(\'"\'.concat(e.type,\'" had indice of "\').concat(t.index,"\\", which is probably -1 and doesn\'t usually happen here.")),void console.log(e);o[n].selected=!0})),r(o,this.sortable,J)}},{key:"onDeselect",value:function(e){var t=this.props,n=t.list,r=t.setList,o=n.map((function(e){return N(N({},e),{},{selected:!1})}));e.newIndicies.forEach((function(e){var t=e.index;-1!==t&&(o[t].selected=!0)})),r(o,this.sortable,J)}},{key:"sortable",get:function(){var e=this.ref.current;if(null===e)return null;var t=Object.keys(e).find((function(e){return e.includes("Sortable")}));return t?e[t]:null}}])&&q(c.prototype,u),f&&q(c,f),d}();exports._O=z,B(z,"defaultProps",{clone:function(e){return e}});\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../../node_modules/react-sortablejs/dist/index.js?')},304:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"MultiDrag\": () => (/* binding */ MultiDragPlugin),\n/* harmony export */   \"Sortable\": () => (/* binding */ Sortable),\n/* harmony export */   \"Swap\": () => (/* binding */ SwapPlugin)\n/* harmony export */ });\n/**!\n * Sortable 1.13.0\n * @author\tRubaXa   <trash@rubaxa.org>\n * @author\towenm    <owen23355@gmail.com>\n * @license MIT\n */\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nvar version = \"1.13.0\";\n\nfunction userAgent(pattern) {\n  if (typeof window !== 'undefined' && window.navigator) {\n    return !!\n    /*@__PURE__*/\n    navigator.userAgent.match(pattern);\n  }\n}\n\nvar IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\\.|msie|iemobile|Windows Phone)/i);\nvar Edge = userAgent(/Edge/i);\nvar FireFox = userAgent(/firefox/i);\nvar Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);\nvar IOS = userAgent(/iP(ad|od|hone)/i);\nvar ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);\n\nvar captureMode = {\n  capture: false,\n  passive: false\n};\n\nfunction on(el, event, fn) {\n  el.addEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction off(el, event, fn) {\n  el.removeEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction matches(\n/**HTMLElement*/\nel,\n/**String*/\nselector) {\n  if (!selector) return;\n  selector[0] === '>' && (selector = selector.substring(1));\n\n  if (el) {\n    try {\n      if (el.matches) {\n        return el.matches(selector);\n      } else if (el.msMatchesSelector) {\n        return el.msMatchesSelector(selector);\n      } else if (el.webkitMatchesSelector) {\n        return el.webkitMatchesSelector(selector);\n      }\n    } catch (_) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction getParentOrHost(el) {\n  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;\n}\n\nfunction closest(\n/**HTMLElement*/\nel,\n/**String*/\nselector,\n/**HTMLElement*/\nctx, includeCTX) {\n  if (el) {\n    ctx = ctx || document;\n\n    do {\n      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {\n        return el;\n      }\n\n      if (el === ctx) break;\n      /* jshint boss:true */\n    } while (el = getParentOrHost(el));\n  }\n\n  return null;\n}\n\nvar R_SPACE = /\\s+/g;\n\nfunction toggleClass(el, name, state) {\n  if (el && name) {\n    if (el.classList) {\n      el.classList[state ? 'add' : 'remove'](name);\n    } else {\n      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');\n      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');\n    }\n  }\n}\n\nfunction css(el, prop, val) {\n  var style = el && el.style;\n\n  if (style) {\n    if (val === void 0) {\n      if (document.defaultView && document.defaultView.getComputedStyle) {\n        val = document.defaultView.getComputedStyle(el, '');\n      } else if (el.currentStyle) {\n        val = el.currentStyle;\n      }\n\n      return prop === void 0 ? val : val[prop];\n    } else {\n      if (!(prop in style) && prop.indexOf('webkit') === -1) {\n        prop = '-webkit-' + prop;\n      }\n\n      style[prop] = val + (typeof val === 'string' ? '' : 'px');\n    }\n  }\n}\n\nfunction matrix(el, selfOnly) {\n  var appliedTransforms = '';\n\n  if (typeof el === 'string') {\n    appliedTransforms = el;\n  } else {\n    do {\n      var transform = css(el, 'transform');\n\n      if (transform && transform !== 'none') {\n        appliedTransforms = transform + ' ' + appliedTransforms;\n      }\n      /* jshint boss:true */\n\n    } while (!selfOnly && (el = el.parentNode));\n  }\n\n  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;\n  /*jshint -W056 */\n\n  return matrixFn && new matrixFn(appliedTransforms);\n}\n\nfunction find(ctx, tagName, iterator) {\n  if (ctx) {\n    var list = ctx.getElementsByTagName(tagName),\n        i = 0,\n        n = list.length;\n\n    if (iterator) {\n      for (; i < n; i++) {\n        iterator(list[i], i);\n      }\n    }\n\n    return list;\n  }\n\n  return [];\n}\n\nfunction getWindowScrollingElement() {\n  var scrollingElement = document.scrollingElement;\n\n  if (scrollingElement) {\n    return scrollingElement;\n  } else {\n    return document.documentElement;\n  }\n}\n/**\n * Returns the \"bounding client rect\" of given element\n * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\n * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\n * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\n * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\n * @param  {[HTMLElement]} container              The parent the element will be placed in\n * @return {Object}                               The boundingClientRect of el, with specified adjustments\n */\n\n\nfunction getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {\n  if (!el.getBoundingClientRect && el !== window) return;\n  var elRect, top, left, bottom, right, height, width;\n\n  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {\n    elRect = el.getBoundingClientRect();\n    top = elRect.top;\n    left = elRect.left;\n    bottom = elRect.bottom;\n    right = elRect.right;\n    height = elRect.height;\n    width = elRect.width;\n  } else {\n    top = 0;\n    left = 0;\n    bottom = window.innerHeight;\n    right = window.innerWidth;\n    height = window.innerHeight;\n    width = window.innerWidth;\n  }\n\n  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {\n    // Adjust for translate()\n    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\n    // Not needed on <= IE11\n\n    if (!IE11OrLess) {\n      do {\n        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {\n          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container\n\n          top -= containerRect.top + parseInt(css(container, 'border-top-width'));\n          left -= containerRect.left + parseInt(css(container, 'border-left-width'));\n          bottom = top + elRect.height;\n          right = left + elRect.width;\n          break;\n        }\n        /* jshint boss:true */\n\n      } while (container = container.parentNode);\n    }\n  }\n\n  if (undoScale && el !== window) {\n    // Adjust for scale()\n    var elMatrix = matrix(container || el),\n        scaleX = elMatrix && elMatrix.a,\n        scaleY = elMatrix && elMatrix.d;\n\n    if (elMatrix) {\n      top /= scaleY;\n      left /= scaleX;\n      width /= scaleX;\n      height /= scaleY;\n      bottom = top + height;\n      right = left + width;\n    }\n  }\n\n  return {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    width: width,\n    height: height\n  };\n}\n/**\n * Checks if a side of an element is scrolled past a side of its parents\n * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\n * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\n * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\n * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element\n */\n\n\nfunction isScrolledPast(el, elSide, parentSide) {\n  var parent = getParentAutoScrollElement(el, true),\n      elSideVal = getRect(el)[elSide];\n  /* jshint boss:true */\n\n  while (parent) {\n    var parentSideVal = getRect(parent)[parentSide],\n        visible = void 0;\n\n    if (parentSide === 'top' || parentSide === 'left') {\n      visible = elSideVal >= parentSideVal;\n    } else {\n      visible = elSideVal <= parentSideVal;\n    }\n\n    if (!visible) return parent;\n    if (parent === getWindowScrollingElement()) break;\n    parent = getParentAutoScrollElement(parent, false);\n  }\n\n  return false;\n}\n/**\n * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\n * and non-draggable elements\n * @param  {HTMLElement} el       The parent element\n * @param  {Number} childNum      The index of the child\n * @param  {Object} options       Parent Sortable's options\n * @return {HTMLElement}          The child at index childNum, or null if not found\n */\n\n\nfunction getChild(el, childNum, options) {\n  var currentChild = 0,\n      i = 0,\n      children = el.children;\n\n  while (i < children.length) {\n    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && children[i] !== Sortable.dragged && closest(children[i], options.draggable, el, false)) {\n      if (currentChild === childNum) {\n        return children[i];\n      }\n\n      currentChild++;\n    }\n\n    i++;\n  }\n\n  return null;\n}\n/**\n * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\n * @param  {HTMLElement} el       Parent element\n * @param  {selector} selector    Any other elements that should be ignored\n * @return {HTMLElement}          The last child, ignoring ghostEl\n */\n\n\nfunction lastChild(el, selector) {\n  var last = el.lastElementChild;\n\n  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {\n    last = last.previousElementSibling;\n  }\n\n  return last || null;\n}\n/**\n * Returns the index of an element within its parent for a selected set of\n * elements\n * @param  {HTMLElement} el\n * @param  {selector} selector\n * @return {number}\n */\n\n\nfunction index(el, selector) {\n  var index = 0;\n\n  if (!el || !el.parentNode) {\n    return -1;\n  }\n  /* jshint boss:true */\n\n\n  while (el = el.previousElementSibling) {\n    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {\n      index++;\n    }\n  }\n\n  return index;\n}\n/**\n * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\n * The value is returned in real pixels.\n * @param  {HTMLElement} el\n * @return {Array}             Offsets in the format of [left, top]\n */\n\n\nfunction getRelativeScrollOffset(el) {\n  var offsetLeft = 0,\n      offsetTop = 0,\n      winScroller = getWindowScrollingElement();\n\n  if (el) {\n    do {\n      var elMatrix = matrix(el),\n          scaleX = elMatrix.a,\n          scaleY = elMatrix.d;\n      offsetLeft += el.scrollLeft * scaleX;\n      offsetTop += el.scrollTop * scaleY;\n    } while (el !== winScroller && (el = el.parentNode));\n  }\n\n  return [offsetLeft, offsetTop];\n}\n/**\n * Returns the index of the object within the given array\n * @param  {Array} arr   Array that may or may not hold the object\n * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\n * @return {Number}      The index of the object in the array, or -1\n */\n\n\nfunction indexOfObject(arr, obj) {\n  for (var i in arr) {\n    if (!arr.hasOwnProperty(i)) continue;\n\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\n    }\n  }\n\n  return -1;\n}\n\nfunction getParentAutoScrollElement(el, includeSelf) {\n  // skip to window\n  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();\n  var elem = el;\n  var gotSelf = false;\n\n  do {\n    // we don't need to get elem css if it isn't even overflowing in the first place (performance)\n    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {\n      var elemCSS = css(elem);\n\n      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {\n        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();\n        if (gotSelf || includeSelf) return elem;\n        gotSelf = true;\n      }\n    }\n    /* jshint boss:true */\n\n  } while (elem = elem.parentNode);\n\n  return getWindowScrollingElement();\n}\n\nfunction extend(dst, src) {\n  if (dst && src) {\n    for (var key in src) {\n      if (src.hasOwnProperty(key)) {\n        dst[key] = src[key];\n      }\n    }\n  }\n\n  return dst;\n}\n\nfunction isRectEqual(rect1, rect2) {\n  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);\n}\n\nvar _throttleTimeout;\n\nfunction throttle(callback, ms) {\n  return function () {\n    if (!_throttleTimeout) {\n      var args = arguments,\n          _this = this;\n\n      if (args.length === 1) {\n        callback.call(_this, args[0]);\n      } else {\n        callback.apply(_this, args);\n      }\n\n      _throttleTimeout = setTimeout(function () {\n        _throttleTimeout = void 0;\n      }, ms);\n    }\n  };\n}\n\nfunction cancelThrottle() {\n  clearTimeout(_throttleTimeout);\n  _throttleTimeout = void 0;\n}\n\nfunction scrollBy(el, x, y) {\n  el.scrollLeft += x;\n  el.scrollTop += y;\n}\n\nfunction clone(el) {\n  var Polymer = window.Polymer;\n  var $ = window.jQuery || window.Zepto;\n\n  if (Polymer && Polymer.dom) {\n    return Polymer.dom(el).cloneNode(true);\n  } else if ($) {\n    return $(el).clone(true)[0];\n  } else {\n    return el.cloneNode(true);\n  }\n}\n\nfunction setRect(el, rect) {\n  css(el, 'position', 'absolute');\n  css(el, 'top', rect.top);\n  css(el, 'left', rect.left);\n  css(el, 'width', rect.width);\n  css(el, 'height', rect.height);\n}\n\nfunction unsetRect(el) {\n  css(el, 'position', '');\n  css(el, 'top', '');\n  css(el, 'left', '');\n  css(el, 'width', '');\n  css(el, 'height', '');\n}\n\nvar expando = 'Sortable' + new Date().getTime();\n\nfunction AnimationStateManager() {\n  var animationStates = [],\n      animationCallbackId;\n  return {\n    captureAnimationState: function captureAnimationState() {\n      animationStates = [];\n      if (!this.options.animation) return;\n      var children = [].slice.call(this.el.children);\n      children.forEach(function (child) {\n        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;\n        animationStates.push({\n          target: child,\n          rect: getRect(child)\n        });\n\n        var fromRect = _objectSpread({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation\n\n\n        if (child.thisAnimationDuration) {\n          var childMatrix = matrix(child, true);\n\n          if (childMatrix) {\n            fromRect.top -= childMatrix.f;\n            fromRect.left -= childMatrix.e;\n          }\n        }\n\n        child.fromRect = fromRect;\n      });\n    },\n    addAnimationState: function addAnimationState(state) {\n      animationStates.push(state);\n    },\n    removeAnimationState: function removeAnimationState(target) {\n      animationStates.splice(indexOfObject(animationStates, {\n        target: target\n      }), 1);\n    },\n    animateAll: function animateAll(callback) {\n      var _this = this;\n\n      if (!this.options.animation) {\n        clearTimeout(animationCallbackId);\n        if (typeof callback === 'function') callback();\n        return;\n      }\n\n      var animating = false,\n          animationTime = 0;\n      animationStates.forEach(function (state) {\n        var time = 0,\n            target = state.target,\n            fromRect = target.fromRect,\n            toRect = getRect(target),\n            prevFromRect = target.prevFromRect,\n            prevToRect = target.prevToRect,\n            animatingRect = state.rect,\n            targetMatrix = matrix(target, true);\n\n        if (targetMatrix) {\n          // Compensate for current animation\n          toRect.top -= targetMatrix.f;\n          toRect.left -= targetMatrix.e;\n        }\n\n        target.toRect = toRect;\n\n        if (target.thisAnimationDuration) {\n          // Could also check if animatingRect is between fromRect and toRect\n          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect\n          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {\n            // If returning to same place as started from animation and on same axis\n            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);\n          }\n        } // if fromRect != toRect: animate\n\n\n        if (!isRectEqual(toRect, fromRect)) {\n          target.prevFromRect = fromRect;\n          target.prevToRect = toRect;\n\n          if (!time) {\n            time = _this.options.animation;\n          }\n\n          _this.animate(target, animatingRect, toRect, time);\n        }\n\n        if (time) {\n          animating = true;\n          animationTime = Math.max(animationTime, time);\n          clearTimeout(target.animationResetTimer);\n          target.animationResetTimer = setTimeout(function () {\n            target.animationTime = 0;\n            target.prevFromRect = null;\n            target.fromRect = null;\n            target.prevToRect = null;\n            target.thisAnimationDuration = null;\n          }, time);\n          target.thisAnimationDuration = time;\n        }\n      });\n      clearTimeout(animationCallbackId);\n\n      if (!animating) {\n        if (typeof callback === 'function') callback();\n      } else {\n        animationCallbackId = setTimeout(function () {\n          if (typeof callback === 'function') callback();\n        }, animationTime);\n      }\n\n      animationStates = [];\n    },\n    animate: function animate(target, currentRect, toRect, duration) {\n      if (duration) {\n        css(target, 'transition', '');\n        css(target, 'transform', '');\n        var elMatrix = matrix(this.el),\n            scaleX = elMatrix && elMatrix.a,\n            scaleY = elMatrix && elMatrix.d,\n            translateX = (currentRect.left - toRect.left) / (scaleX || 1),\n            translateY = (currentRect.top - toRect.top) / (scaleY || 1);\n        target.animatingX = !!translateX;\n        target.animatingY = !!translateY;\n        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');\n        this.forRepaintDummy = repaint(target); // repaint\n\n        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));\n        css(target, 'transform', 'translate3d(0,0,0)');\n        typeof target.animated === 'number' && clearTimeout(target.animated);\n        target.animated = setTimeout(function () {\n          css(target, 'transition', '');\n          css(target, 'transform', '');\n          target.animated = false;\n          target.animatingX = false;\n          target.animatingY = false;\n        }, duration);\n      }\n    }\n  };\n}\n\nfunction repaint(target) {\n  return target.offsetWidth;\n}\n\nfunction calculateRealTime(animatingRect, fromRect, toRect, options) {\n  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;\n}\n\nvar plugins = [];\nvar defaults = {\n  initializeByDefault: true\n};\nvar PluginManager = {\n  mount: function mount(plugin) {\n    // Set default static properties\n    for (var option in defaults) {\n      if (defaults.hasOwnProperty(option) && !(option in plugin)) {\n        plugin[option] = defaults[option];\n      }\n    }\n\n    plugins.forEach(function (p) {\n      if (p.pluginName === plugin.pluginName) {\n        throw \"Sortable: Cannot mount plugin \".concat(plugin.pluginName, \" more than once\");\n      }\n    });\n    plugins.push(plugin);\n  },\n  pluginEvent: function pluginEvent(eventName, sortable, evt) {\n    var _this = this;\n\n    this.eventCanceled = false;\n\n    evt.cancel = function () {\n      _this.eventCanceled = true;\n    };\n\n    var eventNameGlobal = eventName + 'Global';\n    plugins.forEach(function (plugin) {\n      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable\n\n      if (sortable[plugin.pluginName][eventNameGlobal]) {\n        sortable[plugin.pluginName][eventNameGlobal](_objectSpread({\n          sortable: sortable\n        }, evt));\n      } // Only fire plugin event if plugin is enabled in this sortable,\n      // and plugin has event defined\n\n\n      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {\n        sortable[plugin.pluginName][eventName](_objectSpread({\n          sortable: sortable\n        }, evt));\n      }\n    });\n  },\n  initializePlugins: function initializePlugins(sortable, el, defaults, options) {\n    plugins.forEach(function (plugin) {\n      var pluginName = plugin.pluginName;\n      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;\n      var initialized = new plugin(sortable, el, sortable.options);\n      initialized.sortable = sortable;\n      initialized.options = sortable.options;\n      sortable[pluginName] = initialized; // Add default options from plugin\n\n      _extends(defaults, initialized.defaults);\n    });\n\n    for (var option in sortable.options) {\n      if (!sortable.options.hasOwnProperty(option)) continue;\n      var modified = this.modifyOption(sortable, option, sortable.options[option]);\n\n      if (typeof modified !== 'undefined') {\n        sortable.options[option] = modified;\n      }\n    }\n  },\n  getEventProperties: function getEventProperties(name, sortable) {\n    var eventProperties = {};\n    plugins.forEach(function (plugin) {\n      if (typeof plugin.eventProperties !== 'function') return;\n\n      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));\n    });\n    return eventProperties;\n  },\n  modifyOption: function modifyOption(sortable, name, value) {\n    var modifiedValue;\n    plugins.forEach(function (plugin) {\n      // Plugin must exist on the Sortable\n      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin\n\n      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {\n        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);\n      }\n    });\n    return modifiedValue;\n  }\n};\n\nfunction dispatchEvent(_ref) {\n  var sortable = _ref.sortable,\n      rootEl = _ref.rootEl,\n      name = _ref.name,\n      targetEl = _ref.targetEl,\n      cloneEl = _ref.cloneEl,\n      toEl = _ref.toEl,\n      fromEl = _ref.fromEl,\n      oldIndex = _ref.oldIndex,\n      newIndex = _ref.newIndex,\n      oldDraggableIndex = _ref.oldDraggableIndex,\n      newDraggableIndex = _ref.newDraggableIndex,\n      originalEvent = _ref.originalEvent,\n      putSortable = _ref.putSortable,\n      extraEventProperties = _ref.extraEventProperties;\n  sortable = sortable || rootEl && rootEl[expando];\n  if (!sortable) return;\n  var evt,\n      options = sortable.options,\n      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature\n\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent(name, {\n      bubbles: true,\n      cancelable: true\n    });\n  } else {\n    evt = document.createEvent('Event');\n    evt.initEvent(name, true, true);\n  }\n\n  evt.to = toEl || rootEl;\n  evt.from = fromEl || rootEl;\n  evt.item = targetEl || rootEl;\n  evt.clone = cloneEl;\n  evt.oldIndex = oldIndex;\n  evt.newIndex = newIndex;\n  evt.oldDraggableIndex = oldDraggableIndex;\n  evt.newDraggableIndex = newDraggableIndex;\n  evt.originalEvent = originalEvent;\n  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;\n\n  var allEventProperties = _objectSpread({}, extraEventProperties, PluginManager.getEventProperties(name, sortable));\n\n  for (var option in allEventProperties) {\n    evt[option] = allEventProperties[option];\n  }\n\n  if (rootEl) {\n    rootEl.dispatchEvent(evt);\n  }\n\n  if (options[onName]) {\n    options[onName].call(sortable, evt);\n  }\n}\n\nvar pluginEvent = function pluginEvent(eventName, sortable) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      originalEvent = _ref.evt,\n      data = _objectWithoutProperties(_ref, [\"evt\"]);\n\n  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread({\n    dragEl: dragEl,\n    parentEl: parentEl,\n    ghostEl: ghostEl,\n    rootEl: rootEl,\n    nextEl: nextEl,\n    lastDownEl: lastDownEl,\n    cloneEl: cloneEl,\n    cloneHidden: cloneHidden,\n    dragStarted: moved,\n    putSortable: putSortable,\n    activeSortable: Sortable.active,\n    originalEvent: originalEvent,\n    oldIndex: oldIndex,\n    oldDraggableIndex: oldDraggableIndex,\n    newIndex: newIndex,\n    newDraggableIndex: newDraggableIndex,\n    hideGhostForTarget: _hideGhostForTarget,\n    unhideGhostForTarget: _unhideGhostForTarget,\n    cloneNowHidden: function cloneNowHidden() {\n      cloneHidden = true;\n    },\n    cloneNowShown: function cloneNowShown() {\n      cloneHidden = false;\n    },\n    dispatchSortableEvent: function dispatchSortableEvent(name) {\n      _dispatchEvent({\n        sortable: sortable,\n        name: name,\n        originalEvent: originalEvent\n      });\n    }\n  }, data));\n};\n\nfunction _dispatchEvent(info) {\n  dispatchEvent(_objectSpread({\n    putSortable: putSortable,\n    cloneEl: cloneEl,\n    targetEl: dragEl,\n    rootEl: rootEl,\n    oldIndex: oldIndex,\n    oldDraggableIndex: oldDraggableIndex,\n    newIndex: newIndex,\n    newDraggableIndex: newDraggableIndex\n  }, info));\n}\n\nvar dragEl,\n    parentEl,\n    ghostEl,\n    rootEl,\n    nextEl,\n    lastDownEl,\n    cloneEl,\n    cloneHidden,\n    oldIndex,\n    newIndex,\n    oldDraggableIndex,\n    newDraggableIndex,\n    activeGroup,\n    putSortable,\n    awaitingDragStarted = false,\n    ignoreNextClick = false,\n    sortables = [],\n    tapEvt,\n    touchEvt,\n    lastDx,\n    lastDy,\n    tapDistanceLeft,\n    tapDistanceTop,\n    moved,\n    lastTarget,\n    lastDirection,\n    pastFirstInvertThresh = false,\n    isCircumstantialInvert = false,\n    targetMoveDistance,\n    // For positioning ghost absolutely\nghostRelativeParent,\n    ghostRelativeParentInitialScroll = [],\n    // (left, top)\n_silent = false,\n    savedInputChecked = [];\n/** @const */\n\nvar documentExists = typeof document !== 'undefined',\n    PositionGhostAbsolutely = IOS,\n    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',\n    // This will not pass for IE9, because IE9 DnD only works on anchors\nsupportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),\n    supportCssPointerEvents = function () {\n  if (!documentExists) return; // false when <= IE11\n\n  if (IE11OrLess) {\n    return false;\n  }\n\n  var el = document.createElement('x');\n  el.style.cssText = 'pointer-events:auto';\n  return el.style.pointerEvents === 'auto';\n}(),\n    _detectDirection = function _detectDirection(el, options) {\n  var elCSS = css(el),\n      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),\n      child1 = getChild(el, 0, options),\n      child2 = getChild(el, 1, options),\n      firstChildCSS = child1 && css(child1),\n      secondChildCSS = child2 && css(child2),\n      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,\n      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;\n\n  if (elCSS.display === 'flex') {\n    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';\n  }\n\n  if (elCSS.display === 'grid') {\n    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';\n  }\n\n  if (child1 && firstChildCSS[\"float\"] && firstChildCSS[\"float\"] !== 'none') {\n    var touchingSideChild2 = firstChildCSS[\"float\"] === 'left' ? 'left' : 'right';\n    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';\n  }\n\n  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';\n},\n    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {\n  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,\n      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,\n      dragElOppLength = vertical ? dragRect.width : dragRect.height,\n      targetS1Opp = vertical ? targetRect.left : targetRect.top,\n      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,\n      targetOppLength = vertical ? targetRect.width : targetRect.height;\n  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;\n},\n\n/**\n * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\n * @param  {Number} x      X position\n * @param  {Number} y      Y position\n * @return {HTMLElement}   Element of the first found nearest Sortable\n */\n_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {\n  var ret;\n  sortables.some(function (sortable) {\n    if (lastChild(sortable)) return;\n    var rect = getRect(sortable),\n        threshold = sortable[expando].options.emptyInsertThreshold,\n        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,\n        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;\n\n    if (threshold && insideHorizontally && insideVertically) {\n      return ret = sortable;\n    }\n  });\n  return ret;\n},\n    _prepareGroup = function _prepareGroup(options) {\n  function toFn(value, pull) {\n    return function (to, from, dragEl, evt) {\n      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;\n\n      if (value == null && (pull || sameGroup)) {\n        // Default pull value\n        // Default pull and put value if same group\n        return true;\n      } else if (value == null || value === false) {\n        return false;\n      } else if (pull && value === 'clone') {\n        return value;\n      } else if (typeof value === 'function') {\n        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);\n      } else {\n        var otherGroup = (pull ? to : from).options.group.name;\n        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;\n      }\n    };\n  }\n\n  var group = {};\n  var originalGroup = options.group;\n\n  if (!originalGroup || _typeof(originalGroup) != 'object') {\n    originalGroup = {\n      name: originalGroup\n    };\n  }\n\n  group.name = originalGroup.name;\n  group.checkPull = toFn(originalGroup.pull, true);\n  group.checkPut = toFn(originalGroup.put);\n  group.revertClone = originalGroup.revertClone;\n  options.group = group;\n},\n    _hideGhostForTarget = function _hideGhostForTarget() {\n  if (!supportCssPointerEvents && ghostEl) {\n    css(ghostEl, 'display', 'none');\n  }\n},\n    _unhideGhostForTarget = function _unhideGhostForTarget() {\n  if (!supportCssPointerEvents && ghostEl) {\n    css(ghostEl, 'display', '');\n  }\n}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position\n\n\nif (documentExists) {\n  document.addEventListener('click', function (evt) {\n    if (ignoreNextClick) {\n      evt.preventDefault();\n      evt.stopPropagation && evt.stopPropagation();\n      evt.stopImmediatePropagation && evt.stopImmediatePropagation();\n      ignoreNextClick = false;\n      return false;\n    }\n  }, true);\n}\n\nvar nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {\n  if (dragEl) {\n    evt = evt.touches ? evt.touches[0] : evt;\n\n    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);\n\n    if (nearest) {\n      // Create imitation event\n      var event = {};\n\n      for (var i in evt) {\n        if (evt.hasOwnProperty(i)) {\n          event[i] = evt[i];\n        }\n      }\n\n      event.target = event.rootEl = nearest;\n      event.preventDefault = void 0;\n      event.stopPropagation = void 0;\n\n      nearest[expando]._onDragOver(event);\n    }\n  }\n};\n\nvar _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {\n  if (dragEl) {\n    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n  }\n};\n/**\n * @class  Sortable\n * @param  {HTMLElement}  el\n * @param  {Object}       [options]\n */\n\n\nfunction Sortable(el, options) {\n  if (!(el && el.nodeType && el.nodeType === 1)) {\n    throw \"Sortable: `el` must be an HTMLElement, not \".concat({}.toString.call(el));\n  }\n\n  this.el = el; // root element\n\n  this.options = options = _extends({}, options); // Export instance\n\n  el[expando] = this;\n  var defaults = {\n    group: null,\n    sort: true,\n    disabled: false,\n    store: null,\n    handle: null,\n    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',\n    swapThreshold: 1,\n    // percentage; 0 <= x <= 1\n    invertSwap: false,\n    // invert always\n    invertedSwapThreshold: null,\n    // will be set to same as swapThreshold if default\n    removeCloneOnHide: true,\n    direction: function direction() {\n      return _detectDirection(el, this.options);\n    },\n    ghostClass: 'sortable-ghost',\n    chosenClass: 'sortable-chosen',\n    dragClass: 'sortable-drag',\n    ignore: 'a, img',\n    filter: null,\n    preventOnFilter: true,\n    animation: 0,\n    easing: null,\n    setData: function setData(dataTransfer, dragEl) {\n      dataTransfer.setData('Text', dragEl.textContent);\n    },\n    dropBubble: false,\n    dragoverBubble: false,\n    dataIdAttr: 'data-id',\n    delay: 0,\n    delayOnTouchOnly: false,\n    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,\n    forceFallback: false,\n    fallbackClass: 'sortable-fallback',\n    fallbackOnBody: false,\n    fallbackTolerance: 0,\n    fallbackOffset: {\n      x: 0,\n      y: 0\n    },\n    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,\n    emptyInsertThreshold: 5\n  };\n  PluginManager.initializePlugins(this, el, defaults); // Set default options\n\n  for (var name in defaults) {\n    !(name in options) && (options[name] = defaults[name]);\n  }\n\n  _prepareGroup(options); // Bind all private methods\n\n\n  for (var fn in this) {\n    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n      this[fn] = this[fn].bind(this);\n    }\n  } // Setup drag mode\n\n\n  this.nativeDraggable = options.forceFallback ? false : supportDraggable;\n\n  if (this.nativeDraggable) {\n    // Touch start threshold cannot be greater than the native dragstart threshold\n    this.options.touchStartThreshold = 1;\n  } // Bind events\n\n\n  if (options.supportPointer) {\n    on(el, 'pointerdown', this._onTapStart);\n  } else {\n    on(el, 'mousedown', this._onTapStart);\n    on(el, 'touchstart', this._onTapStart);\n  }\n\n  if (this.nativeDraggable) {\n    on(el, 'dragover', this);\n    on(el, 'dragenter', this);\n  }\n\n  sortables.push(this.el); // Restore sorting\n\n  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager\n\n  _extends(this, AnimationStateManager());\n}\n\nSortable.prototype =\n/** @lends Sortable.prototype */\n{\n  constructor: Sortable,\n  _isOutsideThisEl: function _isOutsideThisEl(target) {\n    if (!this.el.contains(target) && target !== this.el) {\n      lastTarget = null;\n    }\n  },\n  _getDirection: function _getDirection(evt, target) {\n    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;\n  },\n  _onTapStart: function _onTapStart(\n  /** Event|TouchEvent */\n  evt) {\n    if (!evt.cancelable) return;\n\n    var _this = this,\n        el = this.el,\n        options = this.options,\n        preventOnFilter = options.preventOnFilter,\n        type = evt.type,\n        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,\n        target = (touch || evt).target,\n        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,\n        filter = options.filter;\n\n    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\n\n\n    if (dragEl) {\n      return;\n    }\n\n    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {\n      return; // only left button and enabled\n    } // cancel dnd if original target is content editable\n\n\n    if (originalTarget.isContentEditable) {\n      return;\n    } // Safari ignores further event handling after mousedown\n\n\n    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {\n      return;\n    }\n\n    target = closest(target, options.draggable, el, false);\n\n    if (target && target.animated) {\n      return;\n    }\n\n    if (lastDownEl === target) {\n      // Ignoring duplicate `down`\n      return;\n    } // Get the index of the dragged element within its parent\n\n\n    oldIndex = index(target);\n    oldDraggableIndex = index(target, options.draggable); // Check filter\n\n    if (typeof filter === 'function') {\n      if (filter.call(this, evt, target, this)) {\n        _dispatchEvent({\n          sortable: _this,\n          rootEl: originalTarget,\n          name: 'filter',\n          targetEl: target,\n          toEl: el,\n          fromEl: el\n        });\n\n        pluginEvent('filter', _this, {\n          evt: evt\n        });\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    } else if (filter) {\n      filter = filter.split(',').some(function (criteria) {\n        criteria = closest(originalTarget, criteria.trim(), el, false);\n\n        if (criteria) {\n          _dispatchEvent({\n            sortable: _this,\n            rootEl: criteria,\n            name: 'filter',\n            targetEl: target,\n            fromEl: el,\n            toEl: el\n          });\n\n          pluginEvent('filter', _this, {\n            evt: evt\n          });\n          return true;\n        }\n      });\n\n      if (filter) {\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    }\n\n    if (options.handle && !closest(originalTarget, options.handle, el, false)) {\n      return;\n    } // Prepare `dragstart`\n\n\n    this._prepareDragStart(evt, touch, target);\n  },\n  _prepareDragStart: function _prepareDragStart(\n  /** Event */\n  evt,\n  /** Touch */\n  touch,\n  /** HTMLElement */\n  target) {\n    var _this = this,\n        el = _this.el,\n        options = _this.options,\n        ownerDocument = el.ownerDocument,\n        dragStartFn;\n\n    if (target && !dragEl && target.parentNode === el) {\n      var dragRect = getRect(target);\n      rootEl = el;\n      dragEl = target;\n      parentEl = dragEl.parentNode;\n      nextEl = dragEl.nextSibling;\n      lastDownEl = target;\n      activeGroup = options.group;\n      Sortable.dragged = dragEl;\n      tapEvt = {\n        target: dragEl,\n        clientX: (touch || evt).clientX,\n        clientY: (touch || evt).clientY\n      };\n      tapDistanceLeft = tapEvt.clientX - dragRect.left;\n      tapDistanceTop = tapEvt.clientY - dragRect.top;\n      this._lastX = (touch || evt).clientX;\n      this._lastY = (touch || evt).clientY;\n      dragEl.style['will-change'] = 'all';\n\n      dragStartFn = function dragStartFn() {\n        pluginEvent('delayEnded', _this, {\n          evt: evt\n        });\n\n        if (Sortable.eventCanceled) {\n          _this._onDrop();\n\n          return;\n        } // Delayed drag has been triggered\n        // we can re-enable the events: touchmove/mousemove\n\n\n        _this._disableDelayedDragEvents();\n\n        if (!FireFox && _this.nativeDraggable) {\n          dragEl.draggable = true;\n        } // Bind the events: dragstart/dragend\n\n\n        _this._triggerDragStart(evt, touch); // Drag start event\n\n\n        _dispatchEvent({\n          sortable: _this,\n          name: 'choose',\n          originalEvent: evt\n        }); // Chosen item\n\n\n        toggleClass(dragEl, options.chosenClass, true);\n      }; // Disable \"draggable\"\n\n\n      options.ignore.split(',').forEach(function (criteria) {\n        find(dragEl, criteria.trim(), _disableDraggable);\n      });\n      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'mouseup', _this._onDrop);\n      on(ownerDocument, 'touchend', _this._onDrop);\n      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)\n\n      if (FireFox && this.nativeDraggable) {\n        this.options.touchStartThreshold = 4;\n        dragEl.draggable = true;\n      }\n\n      pluginEvent('delayStart', this, {\n        evt: evt\n      }); // Delay is impossible for native DnD in Edge or IE\n\n      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {\n        if (Sortable.eventCanceled) {\n          this._onDrop();\n\n          return;\n        } // If the user moves the pointer or let go the click or touch\n        // before the delay has been reached:\n        // disable the delayed drag\n\n\n        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);\n        on(ownerDocument, 'touchend', _this._disableDelayedDrag);\n        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);\n        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);\n        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);\n        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);\n        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);\n      } else {\n        dragStartFn();\n      }\n    }\n  },\n  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(\n  /** TouchEvent|PointerEvent **/\n  e) {\n    var touch = e.touches ? e.touches[0] : e;\n\n    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {\n      this._disableDelayedDrag();\n    }\n  },\n  _disableDelayedDrag: function _disableDelayedDrag() {\n    dragEl && _disableDraggable(dragEl);\n    clearTimeout(this._dragStartTimer);\n\n    this._disableDelayedDragEvents();\n  },\n  _disableDelayedDragEvents: function _disableDelayedDragEvents() {\n    var ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, 'mouseup', this._disableDelayedDrag);\n    off(ownerDocument, 'touchend', this._disableDelayedDrag);\n    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);\n    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);\n    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);\n    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);\n  },\n  _triggerDragStart: function _triggerDragStart(\n  /** Event */\n  evt,\n  /** Touch */\n  touch) {\n    touch = touch || evt.pointerType == 'touch' && evt;\n\n    if (!this.nativeDraggable || touch) {\n      if (this.options.supportPointer) {\n        on(document, 'pointermove', this._onTouchMove);\n      } else if (touch) {\n        on(document, 'touchmove', this._onTouchMove);\n      } else {\n        on(document, 'mousemove', this._onTouchMove);\n      }\n    } else {\n      on(dragEl, 'dragend', this);\n      on(rootEl, 'dragstart', this._onDragStart);\n    }\n\n    try {\n      if (document.selection) {\n        // Timeout neccessary for IE9\n        _nextTick(function () {\n          document.selection.empty();\n        });\n      } else {\n        window.getSelection().removeAllRanges();\n      }\n    } catch (err) {}\n  },\n  _dragStarted: function _dragStarted(fallback, evt) {\n\n    awaitingDragStarted = false;\n\n    if (rootEl && dragEl) {\n      pluginEvent('dragStarted', this, {\n        evt: evt\n      });\n\n      if (this.nativeDraggable) {\n        on(document, 'dragover', _checkOutsideTargetEl);\n      }\n\n      var options = this.options; // Apply effect\n\n      !fallback && toggleClass(dragEl, options.dragClass, false);\n      toggleClass(dragEl, options.ghostClass, true);\n      Sortable.active = this;\n      fallback && this._appendGhost(); // Drag start event\n\n      _dispatchEvent({\n        sortable: this,\n        name: 'start',\n        originalEvent: evt\n      });\n    } else {\n      this._nulling();\n    }\n  },\n  _emulateDragOver: function _emulateDragOver() {\n    if (touchEvt) {\n      this._lastX = touchEvt.clientX;\n      this._lastY = touchEvt.clientY;\n\n      _hideGhostForTarget();\n\n      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n      var parent = target;\n\n      while (target && target.shadowRoot) {\n        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n        if (target === parent) break;\n        parent = target;\n      }\n\n      dragEl.parentNode[expando]._isOutsideThisEl(target);\n\n      if (parent) {\n        do {\n          if (parent[expando]) {\n            var inserted = void 0;\n            inserted = parent[expando]._onDragOver({\n              clientX: touchEvt.clientX,\n              clientY: touchEvt.clientY,\n              target: target,\n              rootEl: parent\n            });\n\n            if (inserted && !this.options.dragoverBubble) {\n              break;\n            }\n          }\n\n          target = parent; // store last element\n        }\n        /* jshint boss:true */\n        while (parent = parent.parentNode);\n      }\n\n      _unhideGhostForTarget();\n    }\n  },\n  _onTouchMove: function _onTouchMove(\n  /**TouchEvent*/\n  evt) {\n    if (tapEvt) {\n      var options = this.options,\n          fallbackTolerance = options.fallbackTolerance,\n          fallbackOffset = options.fallbackOffset,\n          touch = evt.touches ? evt.touches[0] : evt,\n          ghostMatrix = ghostEl && matrix(ghostEl, true),\n          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,\n          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,\n          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),\n          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),\n          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging\n\n      if (!Sortable.active && !awaitingDragStarted) {\n        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {\n          return;\n        }\n\n        this._onDragStart(evt, true);\n      }\n\n      if (ghostEl) {\n        if (ghostMatrix) {\n          ghostMatrix.e += dx - (lastDx || 0);\n          ghostMatrix.f += dy - (lastDy || 0);\n        } else {\n          ghostMatrix = {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            e: dx,\n            f: dy\n          };\n        }\n\n        var cssMatrix = \"matrix(\".concat(ghostMatrix.a, \",\").concat(ghostMatrix.b, \",\").concat(ghostMatrix.c, \",\").concat(ghostMatrix.d, \",\").concat(ghostMatrix.e, \",\").concat(ghostMatrix.f, \")\");\n        css(ghostEl, 'webkitTransform', cssMatrix);\n        css(ghostEl, 'mozTransform', cssMatrix);\n        css(ghostEl, 'msTransform', cssMatrix);\n        css(ghostEl, 'transform', cssMatrix);\n        lastDx = dx;\n        lastDy = dy;\n        touchEvt = touch;\n      }\n\n      evt.cancelable && evt.preventDefault();\n    }\n  },\n  _appendGhost: function _appendGhost() {\n    // Bug if using scale(): https://stackoverflow.com/questions/2637058\n    // Not being adjusted for\n    if (!ghostEl) {\n      var container = this.options.fallbackOnBody ? document.body : rootEl,\n          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),\n          options = this.options; // Position absolutely\n\n      if (PositionGhostAbsolutely) {\n        // Get relatively positioned parent\n        ghostRelativeParent = container;\n\n        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {\n          ghostRelativeParent = ghostRelativeParent.parentNode;\n        }\n\n        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {\n          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();\n          rect.top += ghostRelativeParent.scrollTop;\n          rect.left += ghostRelativeParent.scrollLeft;\n        } else {\n          ghostRelativeParent = getWindowScrollingElement();\n        }\n\n        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);\n      }\n\n      ghostEl = dragEl.cloneNode(true);\n      toggleClass(ghostEl, options.ghostClass, false);\n      toggleClass(ghostEl, options.fallbackClass, true);\n      toggleClass(ghostEl, options.dragClass, true);\n      css(ghostEl, 'transition', '');\n      css(ghostEl, 'transform', '');\n      css(ghostEl, 'box-sizing', 'border-box');\n      css(ghostEl, 'margin', 0);\n      css(ghostEl, 'top', rect.top);\n      css(ghostEl, 'left', rect.left);\n      css(ghostEl, 'width', rect.width);\n      css(ghostEl, 'height', rect.height);\n      css(ghostEl, 'opacity', '0.8');\n      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');\n      css(ghostEl, 'zIndex', '100000');\n      css(ghostEl, 'pointerEvents', 'none');\n      Sortable.ghost = ghostEl;\n      container.appendChild(ghostEl); // Set transform-origin\n\n      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');\n    }\n  },\n  _onDragStart: function _onDragStart(\n  /**Event*/\n  evt,\n  /**boolean*/\n  fallback) {\n    var _this = this;\n\n    var dataTransfer = evt.dataTransfer;\n    var options = _this.options;\n    pluginEvent('dragStart', this, {\n      evt: evt\n    });\n\n    if (Sortable.eventCanceled) {\n      this._onDrop();\n\n      return;\n    }\n\n    pluginEvent('setupClone', this);\n\n    if (!Sortable.eventCanceled) {\n      cloneEl = clone(dragEl);\n      cloneEl.draggable = false;\n      cloneEl.style['will-change'] = '';\n\n      this._hideClone();\n\n      toggleClass(cloneEl, this.options.chosenClass, false);\n      Sortable.clone = cloneEl;\n    } // #1143: IFrame support workaround\n\n\n    _this.cloneId = _nextTick(function () {\n      pluginEvent('clone', _this);\n      if (Sortable.eventCanceled) return;\n\n      if (!_this.options.removeCloneOnHide) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      }\n\n      _this._hideClone();\n\n      _dispatchEvent({\n        sortable: _this,\n        name: 'clone'\n      });\n    });\n    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events\n\n    if (fallback) {\n      ignoreNextClick = true;\n      _this._loopId = setInterval(_this._emulateDragOver, 50);\n    } else {\n      // Undo what was set in _prepareDragStart before drag started\n      off(document, 'mouseup', _this._onDrop);\n      off(document, 'touchend', _this._onDrop);\n      off(document, 'touchcancel', _this._onDrop);\n\n      if (dataTransfer) {\n        dataTransfer.effectAllowed = 'move';\n        options.setData && options.setData.call(_this, dataTransfer, dragEl);\n      }\n\n      on(document, 'drop', _this); // #1276 fix:\n\n      css(dragEl, 'transform', 'translateZ(0)');\n    }\n\n    awaitingDragStarted = true;\n    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));\n    on(document, 'selectstart', _this);\n    moved = true;\n\n    if (Safari) {\n      css(document.body, 'user-select', 'none');\n    }\n  },\n  // Returns true - if no further action is needed (either inserted or another condition)\n  _onDragOver: function _onDragOver(\n  /**Event*/\n  evt) {\n    var el = this.el,\n        target = evt.target,\n        dragRect,\n        targetRect,\n        revert,\n        options = this.options,\n        group = options.group,\n        activeSortable = Sortable.active,\n        isOwner = activeGroup === group,\n        canSort = options.sort,\n        fromSortable = putSortable || activeSortable,\n        vertical,\n        _this = this,\n        completedFired = false;\n\n    if (_silent) return;\n\n    function dragOverEvent(name, extra) {\n      pluginEvent(name, _this, _objectSpread({\n        evt: evt,\n        isOwner: isOwner,\n        axis: vertical ? 'vertical' : 'horizontal',\n        revert: revert,\n        dragRect: dragRect,\n        targetRect: targetRect,\n        canSort: canSort,\n        fromSortable: fromSortable,\n        target: target,\n        completed: completed,\n        onMove: function onMove(target, after) {\n          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);\n        },\n        changed: changed\n      }, extra));\n    } // Capture animation state\n\n\n    function capture() {\n      dragOverEvent('dragOverAnimationCapture');\n\n      _this.captureAnimationState();\n\n      if (_this !== fromSortable) {\n        fromSortable.captureAnimationState();\n      }\n    } // Return invocation when dragEl is inserted (or completed)\n\n\n    function completed(insertion) {\n      dragOverEvent('dragOverCompleted', {\n        insertion: insertion\n      });\n\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        } else {\n          activeSortable._showClone(_this);\n        }\n\n        if (_this !== fromSortable) {\n          // Set ghost class to new sortable's ghost class\n          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);\n          toggleClass(dragEl, options.ghostClass, true);\n        }\n\n        if (putSortable !== _this && _this !== Sortable.active) {\n          putSortable = _this;\n        } else if (_this === Sortable.active && putSortable) {\n          putSortable = null;\n        } // Animation\n\n\n        if (fromSortable === _this) {\n          _this._ignoreWhileAnimating = target;\n        }\n\n        _this.animateAll(function () {\n          dragOverEvent('dragOverAnimationComplete');\n          _this._ignoreWhileAnimating = null;\n        });\n\n        if (_this !== fromSortable) {\n          fromSortable.animateAll();\n          fromSortable._ignoreWhileAnimating = null;\n        }\n      } // Null lastTarget if it is not inside a previously swapped element\n\n\n      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {\n        lastTarget = null;\n      } // no bubbling and not fallback\n\n\n      if (!options.dragoverBubble && !evt.rootEl && target !== document) {\n        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted\n\n\n        !insertion && nearestEmptyInsertDetectEvent(evt);\n      }\n\n      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\n      return completedFired = true;\n    } // Call when dragEl has been inserted\n\n\n    function changed() {\n      newIndex = index(dragEl);\n      newDraggableIndex = index(dragEl, options.draggable);\n\n      _dispatchEvent({\n        sortable: _this,\n        name: 'change',\n        toEl: el,\n        newIndex: newIndex,\n        newDraggableIndex: newDraggableIndex,\n        originalEvent: evt\n      });\n    }\n\n    if (evt.preventDefault !== void 0) {\n      evt.cancelable && evt.preventDefault();\n    }\n\n    target = closest(target, options.draggable, el, true);\n    dragOverEvent('dragOver');\n    if (Sortable.eventCanceled) return completedFired;\n\n    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {\n      return completed(false);\n    }\n\n    ignoreNextClick = false;\n\n    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list\n    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {\n      vertical = this._getDirection(evt, target) === 'vertical';\n      dragRect = getRect(dragEl);\n      dragOverEvent('dragOverValid');\n      if (Sortable.eventCanceled) return completedFired;\n\n      if (revert) {\n        parentEl = rootEl; // actualization\n\n        capture();\n\n        this._hideClone();\n\n        dragOverEvent('revert');\n\n        if (!Sortable.eventCanceled) {\n          if (nextEl) {\n            rootEl.insertBefore(dragEl, nextEl);\n          } else {\n            rootEl.appendChild(dragEl);\n          }\n        }\n\n        return completed(true);\n      }\n\n      var elLastChild = lastChild(el, options.draggable);\n\n      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {\n        // If already at end of list: Do not insert\n        if (elLastChild === dragEl) {\n          return completed(false);\n        } // assign target only if condition is true\n\n\n        if (elLastChild && el === evt.target) {\n          target = elLastChild;\n        }\n\n        if (target) {\n          targetRect = getRect(target);\n        }\n\n        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {\n          capture();\n          el.appendChild(dragEl);\n          parentEl = el; // actualization\n\n          changed();\n          return completed(true);\n        }\n      } else if (target.parentNode === el) {\n        targetRect = getRect(target);\n        var direction = 0,\n            targetBeforeFirstSwap,\n            differentLevel = dragEl.parentNode !== el,\n            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),\n            side1 = vertical ? 'top' : 'left',\n            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),\n            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\n\n        if (lastTarget !== target) {\n          targetBeforeFirstSwap = targetRect[side1];\n          pastFirstInvertThresh = false;\n          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;\n        }\n\n        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);\n        var sibling;\n\n        if (direction !== 0) {\n          // Check if target is beside dragEl in respective direction (ignoring hidden elements)\n          var dragIndex = index(dragEl);\n\n          do {\n            dragIndex -= direction;\n            sibling = parentEl.children[dragIndex];\n          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));\n        } // If dragEl is already beside target: Do not insert\n\n\n        if (direction === 0 || sibling === target) {\n          return completed(false);\n        }\n\n        lastTarget = target;\n        lastDirection = direction;\n        var nextSibling = target.nextElementSibling,\n            after = false;\n        after = direction === 1;\n\n        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);\n\n        if (moveVector !== false) {\n          if (moveVector === 1 || moveVector === -1) {\n            after = moveVector === 1;\n          }\n\n          _silent = true;\n          setTimeout(_unsilent, 30);\n          capture();\n\n          if (after && !nextSibling) {\n            el.appendChild(dragEl);\n          } else {\n            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);\n          } // Undo chrome's scroll adjustment (has no effect on other browsers)\n\n\n          if (scrolledPastTop) {\n            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);\n          }\n\n          parentEl = dragEl.parentNode; // actualization\n          // must be done before animation\n\n          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\n            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);\n          }\n\n          changed();\n          return completed(true);\n        }\n      }\n\n      if (el.contains(dragEl)) {\n        return completed(false);\n      }\n    }\n\n    return false;\n  },\n  _ignoreWhileAnimating: null,\n  _offMoveEvents: function _offMoveEvents() {\n    off(document, 'mousemove', this._onTouchMove);\n    off(document, 'touchmove', this._onTouchMove);\n    off(document, 'pointermove', this._onTouchMove);\n    off(document, 'dragover', nearestEmptyInsertDetectEvent);\n    off(document, 'mousemove', nearestEmptyInsertDetectEvent);\n    off(document, 'touchmove', nearestEmptyInsertDetectEvent);\n  },\n  _offUpEvents: function _offUpEvents() {\n    var ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, 'mouseup', this._onDrop);\n    off(ownerDocument, 'touchend', this._onDrop);\n    off(ownerDocument, 'pointerup', this._onDrop);\n    off(ownerDocument, 'touchcancel', this._onDrop);\n    off(document, 'selectstart', this);\n  },\n  _onDrop: function _onDrop(\n  /**Event*/\n  evt) {\n    var el = this.el,\n        options = this.options; // Get the index of the dragged element within its parent\n\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n    pluginEvent('drop', this, {\n      evt: evt\n    });\n    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event\n\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n\n    if (Sortable.eventCanceled) {\n      this._nulling();\n\n      return;\n    }\n\n    awaitingDragStarted = false;\n    isCircumstantialInvert = false;\n    pastFirstInvertThresh = false;\n    clearInterval(this._loopId);\n    clearTimeout(this._dragStartTimer);\n\n    _cancelNextTick(this.cloneId);\n\n    _cancelNextTick(this._dragStartId); // Unbind events\n\n\n    if (this.nativeDraggable) {\n      off(document, 'drop', this);\n      off(el, 'dragstart', this._onDragStart);\n    }\n\n    this._offMoveEvents();\n\n    this._offUpEvents();\n\n    if (Safari) {\n      css(document.body, 'user-select', '');\n    }\n\n    css(dragEl, 'transform', '');\n\n    if (evt) {\n      if (moved) {\n        evt.cancelable && evt.preventDefault();\n        !options.dropBubble && evt.stopPropagation();\n      }\n\n      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\n\n      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n        // Remove clone(s)\n        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);\n      }\n\n      if (dragEl) {\n        if (this.nativeDraggable) {\n          off(dragEl, 'dragend', this);\n        }\n\n        _disableDraggable(dragEl);\n\n        dragEl.style['will-change'] = ''; // Remove classes\n        // ghostClass is added in dragStarted\n\n        if (moved && !awaitingDragStarted) {\n          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);\n        }\n\n        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event\n\n        _dispatchEvent({\n          sortable: this,\n          name: 'unchoose',\n          toEl: parentEl,\n          newIndex: null,\n          newDraggableIndex: null,\n          originalEvent: evt\n        });\n\n        if (rootEl !== parentEl) {\n          if (newIndex >= 0) {\n            // Add event\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: 'add',\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt\n            }); // Remove event\n\n\n            _dispatchEvent({\n              sortable: this,\n              name: 'remove',\n              toEl: parentEl,\n              originalEvent: evt\n            }); // drag from one list and drop into another\n\n\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: 'sort',\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt\n            });\n\n            _dispatchEvent({\n              sortable: this,\n              name: 'sort',\n              toEl: parentEl,\n              originalEvent: evt\n            });\n          }\n\n          putSortable && putSortable.save();\n        } else {\n          if (newIndex !== oldIndex) {\n            if (newIndex >= 0) {\n              // drag & drop within the same list\n              _dispatchEvent({\n                sortable: this,\n                name: 'update',\n                toEl: parentEl,\n                originalEvent: evt\n              });\n\n              _dispatchEvent({\n                sortable: this,\n                name: 'sort',\n                toEl: parentEl,\n                originalEvent: evt\n              });\n            }\n          }\n        }\n\n        if (Sortable.active) {\n          /* jshint eqnull:true */\n          if (newIndex == null || newIndex === -1) {\n            newIndex = oldIndex;\n            newDraggableIndex = oldDraggableIndex;\n          }\n\n          _dispatchEvent({\n            sortable: this,\n            name: 'end',\n            toEl: parentEl,\n            originalEvent: evt\n          }); // Save sorting\n\n\n          this.save();\n        }\n      }\n    }\n\n    this._nulling();\n  },\n  _nulling: function _nulling() {\n    pluginEvent('nulling', this);\n    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;\n    savedInputChecked.forEach(function (el) {\n      el.checked = true;\n    });\n    savedInputChecked.length = lastDx = lastDy = 0;\n  },\n  handleEvent: function handleEvent(\n  /**Event*/\n  evt) {\n    switch (evt.type) {\n      case 'drop':\n      case 'dragend':\n        this._onDrop(evt);\n\n        break;\n\n      case 'dragenter':\n      case 'dragover':\n        if (dragEl) {\n          this._onDragOver(evt);\n\n          _globalDragOver(evt);\n        }\n\n        break;\n\n      case 'selectstart':\n        evt.preventDefault();\n        break;\n    }\n  },\n\n  /**\n   * Serializes the item into an array of string.\n   * @returns {String[]}\n   */\n  toArray: function toArray() {\n    var order = [],\n        el,\n        children = this.el.children,\n        i = 0,\n        n = children.length,\n        options = this.options;\n\n    for (; i < n; i++) {\n      el = children[i];\n\n      if (closest(el, options.draggable, this.el, false)) {\n        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n      }\n    }\n\n    return order;\n  },\n\n  /**\n   * Sorts the elements according to the array.\n   * @param  {String[]}  order  order of the items\n   */\n  sort: function sort(order, useAnimation) {\n    var items = {},\n        rootEl = this.el;\n    this.toArray().forEach(function (id, i) {\n      var el = rootEl.children[i];\n\n      if (closest(el, this.options.draggable, rootEl, false)) {\n        items[id] = el;\n      }\n    }, this);\n    useAnimation && this.captureAnimationState();\n    order.forEach(function (id) {\n      if (items[id]) {\n        rootEl.removeChild(items[id]);\n        rootEl.appendChild(items[id]);\n      }\n    });\n    useAnimation && this.animateAll();\n  },\n\n  /**\n   * Save the current sorting\n   */\n  save: function save() {\n    var store = this.options.store;\n    store && store.set && store.set(this);\n  },\n\n  /**\n   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\n   * @param   {HTMLElement}  el\n   * @param   {String}       [selector]  default: `options.draggable`\n   * @returns {HTMLElement|null}\n   */\n  closest: function closest$1(el, selector) {\n    return closest(el, selector || this.options.draggable, this.el, false);\n  },\n\n  /**\n   * Set/get option\n   * @param   {string} name\n   * @param   {*}      [value]\n   * @returns {*}\n   */\n  option: function option(name, value) {\n    var options = this.options;\n\n    if (value === void 0) {\n      return options[name];\n    } else {\n      var modifiedValue = PluginManager.modifyOption(this, name, value);\n\n      if (typeof modifiedValue !== 'undefined') {\n        options[name] = modifiedValue;\n      } else {\n        options[name] = value;\n      }\n\n      if (name === 'group') {\n        _prepareGroup(options);\n      }\n    }\n  },\n\n  /**\n   * Destroy\n   */\n  destroy: function destroy() {\n    pluginEvent('destroy', this);\n    var el = this.el;\n    el[expando] = null;\n    off(el, 'mousedown', this._onTapStart);\n    off(el, 'touchstart', this._onTapStart);\n    off(el, 'pointerdown', this._onTapStart);\n\n    if (this.nativeDraggable) {\n      off(el, 'dragover', this);\n      off(el, 'dragenter', this);\n    } // Remove draggable attributes\n\n\n    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {\n      el.removeAttribute('draggable');\n    });\n\n    this._onDrop();\n\n    this._disableDelayedDragEvents();\n\n    sortables.splice(sortables.indexOf(this.el), 1);\n    this.el = el = null;\n  },\n  _hideClone: function _hideClone() {\n    if (!cloneHidden) {\n      pluginEvent('hideClone', this);\n      if (Sortable.eventCanceled) return;\n      css(cloneEl, 'display', 'none');\n\n      if (this.options.removeCloneOnHide && cloneEl.parentNode) {\n        cloneEl.parentNode.removeChild(cloneEl);\n      }\n\n      cloneHidden = true;\n    }\n  },\n  _showClone: function _showClone(putSortable) {\n    if (putSortable.lastPutMode !== 'clone') {\n      this._hideClone();\n\n      return;\n    }\n\n    if (cloneHidden) {\n      pluginEvent('showClone', this);\n      if (Sortable.eventCanceled) return; // show clone at dragEl or original position\n\n      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      } else if (nextEl) {\n        rootEl.insertBefore(cloneEl, nextEl);\n      } else {\n        rootEl.appendChild(cloneEl);\n      }\n\n      if (this.options.group.revertClone) {\n        this.animate(dragEl, cloneEl);\n      }\n\n      css(cloneEl, 'display', '');\n      cloneHidden = false;\n    }\n  }\n};\n\nfunction _globalDragOver(\n/**Event*/\nevt) {\n  if (evt.dataTransfer) {\n    evt.dataTransfer.dropEffect = 'move';\n  }\n\n  evt.cancelable && evt.preventDefault();\n}\n\nfunction _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {\n  var evt,\n      sortable = fromEl[expando],\n      onMoveFn = sortable.options.onMove,\n      retVal; // Support for new CustomEvent feature\n\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent('move', {\n      bubbles: true,\n      cancelable: true\n    });\n  } else {\n    evt = document.createEvent('Event');\n    evt.initEvent('move', true, true);\n  }\n\n  evt.to = toEl;\n  evt.from = fromEl;\n  evt.dragged = dragEl;\n  evt.draggedRect = dragRect;\n  evt.related = targetEl || toEl;\n  evt.relatedRect = targetRect || getRect(toEl);\n  evt.willInsertAfter = willInsertAfter;\n  evt.originalEvent = originalEvent;\n  fromEl.dispatchEvent(evt);\n\n  if (onMoveFn) {\n    retVal = onMoveFn.call(sortable, evt, originalEvent);\n  }\n\n  return retVal;\n}\n\nfunction _disableDraggable(el) {\n  el.draggable = false;\n}\n\nfunction _unsilent() {\n  _silent = false;\n}\n\nfunction _ghostIsLast(evt, vertical, sortable) {\n  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));\n  var spacer = 10;\n  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;\n}\n\nfunction _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {\n  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,\n      targetLength = vertical ? targetRect.height : targetRect.width,\n      targetS1 = vertical ? targetRect.top : targetRect.left,\n      targetS2 = vertical ? targetRect.bottom : targetRect.right,\n      invert = false;\n\n  if (!invertSwap) {\n    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\n    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {\n      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\n      // check if past first invert threshold on side opposite of lastDirection\n      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {\n        // past first invert threshold, do not restrict inverted threshold to dragEl shadow\n        pastFirstInvertThresh = true;\n      }\n\n      if (!pastFirstInvertThresh) {\n        // dragEl shadow (target move distance shadow)\n        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\n        : mouseOnAxis > targetS2 - targetMoveDistance) {\n          return -lastDirection;\n        }\n      } else {\n        invert = true;\n      }\n    } else {\n      // Regular\n      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {\n        return _getInsertDirection(target);\n      }\n    }\n  }\n\n  invert = invert || invertSwap;\n\n  if (invert) {\n    // Invert of regular\n    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {\n      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;\n    }\n  }\n\n  return 0;\n}\n/**\n * Gets the direction dragEl must be swapped relative to target in order to make it\n * seem that dragEl has been \"inserted\" into that element's position\n * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\n * @return {Number}                   Direction dragEl must be swapped\n */\n\n\nfunction _getInsertDirection(target) {\n  if (index(dragEl) < index(target)) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n/**\n * Generate id\n * @param   {HTMLElement} el\n * @returns {String}\n * @private\n */\n\n\nfunction _generateId(el) {\n  var str = el.tagName + el.className + el.src + el.href + el.textContent,\n      i = str.length,\n      sum = 0;\n\n  while (i--) {\n    sum += str.charCodeAt(i);\n  }\n\n  return sum.toString(36);\n}\n\nfunction _saveInputCheckedState(root) {\n  savedInputChecked.length = 0;\n  var inputs = root.getElementsByTagName('input');\n  var idx = inputs.length;\n\n  while (idx--) {\n    var el = inputs[idx];\n    el.checked && savedInputChecked.push(el);\n  }\n}\n\nfunction _nextTick(fn) {\n  return setTimeout(fn, 0);\n}\n\nfunction _cancelNextTick(id) {\n  return clearTimeout(id);\n} // Fixed #973:\n\n\nif (documentExists) {\n  on(document, 'touchmove', function (evt) {\n    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {\n      evt.preventDefault();\n    }\n  });\n} // Export utils\n\n\nSortable.utils = {\n  on: on,\n  off: off,\n  css: css,\n  find: find,\n  is: function is(el, selector) {\n    return !!closest(el, selector, el, false);\n  },\n  extend: extend,\n  throttle: throttle,\n  closest: closest,\n  toggleClass: toggleClass,\n  clone: clone,\n  index: index,\n  nextTick: _nextTick,\n  cancelNextTick: _cancelNextTick,\n  detectDirection: _detectDirection,\n  getChild: getChild\n};\n/**\n * Get the Sortable instance of an element\n * @param  {HTMLElement} element The element\n * @return {Sortable|undefined}         The instance of Sortable\n */\n\nSortable.get = function (element) {\n  return element[expando];\n};\n/**\n * Mount a plugin to Sortable\n * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted\n */\n\n\nSortable.mount = function () {\n  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {\n    plugins[_key] = arguments[_key];\n  }\n\n  if (plugins[0].constructor === Array) plugins = plugins[0];\n  plugins.forEach(function (plugin) {\n    if (!plugin.prototype || !plugin.prototype.constructor) {\n      throw \"Sortable: Mounted plugin must be a constructor function, not \".concat({}.toString.call(plugin));\n    }\n\n    if (plugin.utils) Sortable.utils = _objectSpread({}, Sortable.utils, plugin.utils);\n    PluginManager.mount(plugin);\n  });\n};\n/**\n * Create sortable instance\n * @param {HTMLElement}  el\n * @param {Object}      [options]\n */\n\n\nSortable.create = function (el, options) {\n  return new Sortable(el, options);\n}; // Export\n\n\nSortable.version = version;\n\nvar autoScrolls = [],\n    scrollEl,\n    scrollRootEl,\n    scrolling = false,\n    lastAutoScrollX,\n    lastAutoScrollY,\n    touchEvt$1,\n    pointerElemChangedInterval;\n\nfunction AutoScrollPlugin() {\n  function AutoScroll() {\n    this.defaults = {\n      scroll: true,\n      scrollSensitivity: 30,\n      scrollSpeed: 10,\n      bubbleScroll: true\n    }; // Bind all private methods\n\n    for (var fn in this) {\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n  }\n\n  AutoScroll.prototype = {\n    dragStarted: function dragStarted(_ref) {\n      var originalEvent = _ref.originalEvent;\n\n      if (this.sortable.nativeDraggable) {\n        on(document, 'dragover', this._handleAutoScroll);\n      } else {\n        if (this.options.supportPointer) {\n          on(document, 'pointermove', this._handleFallbackAutoScroll);\n        } else if (originalEvent.touches) {\n          on(document, 'touchmove', this._handleFallbackAutoScroll);\n        } else {\n          on(document, 'mousemove', this._handleFallbackAutoScroll);\n        }\n      }\n    },\n    dragOverCompleted: function dragOverCompleted(_ref2) {\n      var originalEvent = _ref2.originalEvent;\n\n      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)\n      if (!this.options.dragOverBubble && !originalEvent.rootEl) {\n        this._handleAutoScroll(originalEvent);\n      }\n    },\n    drop: function drop() {\n      if (this.sortable.nativeDraggable) {\n        off(document, 'dragover', this._handleAutoScroll);\n      } else {\n        off(document, 'pointermove', this._handleFallbackAutoScroll);\n        off(document, 'touchmove', this._handleFallbackAutoScroll);\n        off(document, 'mousemove', this._handleFallbackAutoScroll);\n      }\n\n      clearPointerElemChangedInterval();\n      clearAutoScrolls();\n      cancelThrottle();\n    },\n    nulling: function nulling() {\n      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;\n      autoScrolls.length = 0;\n    },\n    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {\n      this._handleAutoScroll(evt, true);\n    },\n    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {\n      var _this = this;\n\n      var x = (evt.touches ? evt.touches[0] : evt).clientX,\n          y = (evt.touches ? evt.touches[0] : evt).clientY,\n          elem = document.elementFromPoint(x, y);\n      touchEvt$1 = evt; // IE does not seem to have native autoscroll,\n      // Edge's autoscroll seems too conditional,\n      // MACOS Safari does not have autoscroll,\n      // Firefox and Chrome are good\n\n      if (fallback || Edge || IE11OrLess || Safari) {\n        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change\n\n        var ogElemScroller = getParentAutoScrollElement(elem, true);\n\n        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {\n          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour\n\n          pointerElemChangedInterval = setInterval(function () {\n            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);\n\n            if (newElem !== ogElemScroller) {\n              ogElemScroller = newElem;\n              clearAutoScrolls();\n            }\n\n            autoScroll(evt, _this.options, newElem, fallback);\n          }, 10);\n          lastAutoScrollX = x;\n          lastAutoScrollY = y;\n        }\n      } else {\n        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll\n        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {\n          clearAutoScrolls();\n          return;\n        }\n\n        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);\n      }\n    }\n  };\n  return _extends(AutoScroll, {\n    pluginName: 'scroll',\n    initializeByDefault: true\n  });\n}\n\nfunction clearAutoScrolls() {\n  autoScrolls.forEach(function (autoScroll) {\n    clearInterval(autoScroll.pid);\n  });\n  autoScrolls = [];\n}\n\nfunction clearPointerElemChangedInterval() {\n  clearInterval(pointerElemChangedInterval);\n}\n\nvar autoScroll = throttle(function (evt, options, rootEl, isFallback) {\n  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\n  if (!options.scroll) return;\n  var x = (evt.touches ? evt.touches[0] : evt).clientX,\n      y = (evt.touches ? evt.touches[0] : evt).clientY,\n      sens = options.scrollSensitivity,\n      speed = options.scrollSpeed,\n      winScroller = getWindowScrollingElement();\n  var scrollThisInstance = false,\n      scrollCustomFn; // New scroll root, set scrollEl\n\n  if (scrollRootEl !== rootEl) {\n    scrollRootEl = rootEl;\n    clearAutoScrolls();\n    scrollEl = options.scroll;\n    scrollCustomFn = options.scrollFn;\n\n    if (scrollEl === true) {\n      scrollEl = getParentAutoScrollElement(rootEl, true);\n    }\n  }\n\n  var layersOut = 0;\n  var currentParent = scrollEl;\n\n  do {\n    var el = currentParent,\n        rect = getRect(el),\n        top = rect.top,\n        bottom = rect.bottom,\n        left = rect.left,\n        right = rect.right,\n        width = rect.width,\n        height = rect.height,\n        canScrollX = void 0,\n        canScrollY = void 0,\n        scrollWidth = el.scrollWidth,\n        scrollHeight = el.scrollHeight,\n        elCSS = css(el),\n        scrollPosX = el.scrollLeft,\n        scrollPosY = el.scrollTop;\n\n    if (el === winScroller) {\n      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');\n      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');\n    } else {\n      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');\n      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');\n    }\n\n    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);\n    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);\n\n    if (!autoScrolls[layersOut]) {\n      for (var i = 0; i <= layersOut; i++) {\n        if (!autoScrolls[i]) {\n          autoScrolls[i] = {};\n        }\n      }\n    }\n\n    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {\n      autoScrolls[layersOut].el = el;\n      autoScrolls[layersOut].vx = vx;\n      autoScrolls[layersOut].vy = vy;\n      clearInterval(autoScrolls[layersOut].pid);\n\n      if (vx != 0 || vy != 0) {\n        scrollThisInstance = true;\n        /* jshint loopfunc:true */\n\n        autoScrolls[layersOut].pid = setInterval(function () {\n          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour\n          if (isFallback && this.layer === 0) {\n            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely\n\n          }\n\n          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;\n          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;\n\n          if (typeof scrollCustomFn === 'function') {\n            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {\n              return;\n            }\n          }\n\n          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);\n        }.bind({\n          layer: layersOut\n        }), 24);\n      }\n    }\n\n    layersOut++;\n  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));\n\n  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not\n}, 30);\n\nvar drop = function drop(_ref) {\n  var originalEvent = _ref.originalEvent,\n      putSortable = _ref.putSortable,\n      dragEl = _ref.dragEl,\n      activeSortable = _ref.activeSortable,\n      dispatchSortableEvent = _ref.dispatchSortableEvent,\n      hideGhostForTarget = _ref.hideGhostForTarget,\n      unhideGhostForTarget = _ref.unhideGhostForTarget;\n  if (!originalEvent) return;\n  var toSortable = putSortable || activeSortable;\n  hideGhostForTarget();\n  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;\n  var target = document.elementFromPoint(touch.clientX, touch.clientY);\n  unhideGhostForTarget();\n\n  if (toSortable && !toSortable.el.contains(target)) {\n    dispatchSortableEvent('spill');\n    this.onSpill({\n      dragEl: dragEl,\n      putSortable: putSortable\n    });\n  }\n};\n\nfunction Revert() {}\n\nRevert.prototype = {\n  startIndex: null,\n  dragStart: function dragStart(_ref2) {\n    var oldDraggableIndex = _ref2.oldDraggableIndex;\n    this.startIndex = oldDraggableIndex;\n  },\n  onSpill: function onSpill(_ref3) {\n    var dragEl = _ref3.dragEl,\n        putSortable = _ref3.putSortable;\n    this.sortable.captureAnimationState();\n\n    if (putSortable) {\n      putSortable.captureAnimationState();\n    }\n\n    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);\n\n    if (nextSibling) {\n      this.sortable.el.insertBefore(dragEl, nextSibling);\n    } else {\n      this.sortable.el.appendChild(dragEl);\n    }\n\n    this.sortable.animateAll();\n\n    if (putSortable) {\n      putSortable.animateAll();\n    }\n  },\n  drop: drop\n};\n\n_extends(Revert, {\n  pluginName: 'revertOnSpill'\n});\n\nfunction Remove() {}\n\nRemove.prototype = {\n  onSpill: function onSpill(_ref4) {\n    var dragEl = _ref4.dragEl,\n        putSortable = _ref4.putSortable;\n    var parentSortable = putSortable || this.sortable;\n    parentSortable.captureAnimationState();\n    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);\n    parentSortable.animateAll();\n  },\n  drop: drop\n};\n\n_extends(Remove, {\n  pluginName: 'removeOnSpill'\n});\n\nvar lastSwapEl;\n\nfunction SwapPlugin() {\n  function Swap() {\n    this.defaults = {\n      swapClass: 'sortable-swap-highlight'\n    };\n  }\n\n  Swap.prototype = {\n    dragStart: function dragStart(_ref) {\n      var dragEl = _ref.dragEl;\n      lastSwapEl = dragEl;\n    },\n    dragOverValid: function dragOverValid(_ref2) {\n      var completed = _ref2.completed,\n          target = _ref2.target,\n          onMove = _ref2.onMove,\n          activeSortable = _ref2.activeSortable,\n          changed = _ref2.changed,\n          cancel = _ref2.cancel;\n      if (!activeSortable.options.swap) return;\n      var el = this.sortable.el,\n          options = this.options;\n\n      if (target && target !== el) {\n        var prevSwapEl = lastSwapEl;\n\n        if (onMove(target) !== false) {\n          toggleClass(target, options.swapClass, true);\n          lastSwapEl = target;\n        } else {\n          lastSwapEl = null;\n        }\n\n        if (prevSwapEl && prevSwapEl !== lastSwapEl) {\n          toggleClass(prevSwapEl, options.swapClass, false);\n        }\n      }\n\n      changed();\n      completed(true);\n      cancel();\n    },\n    drop: function drop(_ref3) {\n      var activeSortable = _ref3.activeSortable,\n          putSortable = _ref3.putSortable,\n          dragEl = _ref3.dragEl;\n      var toSortable = putSortable || this.sortable;\n      var options = this.options;\n      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);\n\n      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {\n        if (dragEl !== lastSwapEl) {\n          toSortable.captureAnimationState();\n          if (toSortable !== activeSortable) activeSortable.captureAnimationState();\n          swapNodes(dragEl, lastSwapEl);\n          toSortable.animateAll();\n          if (toSortable !== activeSortable) activeSortable.animateAll();\n        }\n      }\n    },\n    nulling: function nulling() {\n      lastSwapEl = null;\n    }\n  };\n  return _extends(Swap, {\n    pluginName: 'swap',\n    eventProperties: function eventProperties() {\n      return {\n        swapItem: lastSwapEl\n      };\n    }\n  });\n}\n\nfunction swapNodes(n1, n2) {\n  var p1 = n1.parentNode,\n      p2 = n2.parentNode,\n      i1,\n      i2;\n  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;\n  i1 = index(n1);\n  i2 = index(n2);\n\n  if (p1.isEqualNode(p2) && i1 < i2) {\n    i2++;\n  }\n\n  p1.insertBefore(n2, p1.children[i1]);\n  p2.insertBefore(n1, p2.children[i2]);\n}\n\nvar multiDragElements = [],\n    multiDragClones = [],\n    lastMultiDragSelect,\n    // for selection with modifier key down (SHIFT)\nmultiDragSortable,\n    initialFolding = false,\n    // Initial multi-drag fold when drag started\nfolding = false,\n    // Folding any other time\ndragStarted = false,\n    dragEl$1,\n    clonesFromRect,\n    clonesHidden;\n\nfunction MultiDragPlugin() {\n  function MultiDrag(sortable) {\n    // Bind all private methods\n    for (var fn in this) {\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n\n    if (sortable.options.supportPointer) {\n      on(document, 'pointerup', this._deselectMultiDrag);\n    } else {\n      on(document, 'mouseup', this._deselectMultiDrag);\n      on(document, 'touchend', this._deselectMultiDrag);\n    }\n\n    on(document, 'keydown', this._checkKeyDown);\n    on(document, 'keyup', this._checkKeyUp);\n    this.defaults = {\n      selectedClass: 'sortable-selected',\n      multiDragKey: null,\n      setData: function setData(dataTransfer, dragEl) {\n        var data = '';\n\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          multiDragElements.forEach(function (multiDragElement, i) {\n            data += (!i ? '' : ', ') + multiDragElement.textContent;\n          });\n        } else {\n          data = dragEl.textContent;\n        }\n\n        dataTransfer.setData('Text', data);\n      }\n    };\n  }\n\n  MultiDrag.prototype = {\n    multiDragKeyDown: false,\n    isMultiDrag: false,\n    delayStartGlobal: function delayStartGlobal(_ref) {\n      var dragged = _ref.dragEl;\n      dragEl$1 = dragged;\n    },\n    delayEnded: function delayEnded() {\n      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);\n    },\n    setupClone: function setupClone(_ref2) {\n      var sortable = _ref2.sortable,\n          cancel = _ref2.cancel;\n      if (!this.isMultiDrag) return;\n\n      for (var i = 0; i < multiDragElements.length; i++) {\n        multiDragClones.push(clone(multiDragElements[i]));\n        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;\n        multiDragClones[i].draggable = false;\n        multiDragClones[i].style['will-change'] = '';\n        toggleClass(multiDragClones[i], this.options.selectedClass, false);\n        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);\n      }\n\n      sortable._hideClone();\n\n      cancel();\n    },\n    clone: function clone(_ref3) {\n      var sortable = _ref3.sortable,\n          rootEl = _ref3.rootEl,\n          dispatchSortableEvent = _ref3.dispatchSortableEvent,\n          cancel = _ref3.cancel;\n      if (!this.isMultiDrag) return;\n\n      if (!this.options.removeCloneOnHide) {\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          insertMultiDragClones(true, rootEl);\n          dispatchSortableEvent('clone');\n          cancel();\n        }\n      }\n    },\n    showClone: function showClone(_ref4) {\n      var cloneNowShown = _ref4.cloneNowShown,\n          rootEl = _ref4.rootEl,\n          cancel = _ref4.cancel;\n      if (!this.isMultiDrag) return;\n      insertMultiDragClones(false, rootEl);\n      multiDragClones.forEach(function (clone) {\n        css(clone, 'display', '');\n      });\n      cloneNowShown();\n      clonesHidden = false;\n      cancel();\n    },\n    hideClone: function hideClone(_ref5) {\n      var _this = this;\n\n      var sortable = _ref5.sortable,\n          cloneNowHidden = _ref5.cloneNowHidden,\n          cancel = _ref5.cancel;\n      if (!this.isMultiDrag) return;\n      multiDragClones.forEach(function (clone) {\n        css(clone, 'display', 'none');\n\n        if (_this.options.removeCloneOnHide && clone.parentNode) {\n          clone.parentNode.removeChild(clone);\n        }\n      });\n      cloneNowHidden();\n      clonesHidden = true;\n      cancel();\n    },\n    dragStartGlobal: function dragStartGlobal(_ref6) {\n      var sortable = _ref6.sortable;\n\n      if (!this.isMultiDrag && multiDragSortable) {\n        multiDragSortable.multiDrag._deselectMultiDrag();\n      }\n\n      multiDragElements.forEach(function (multiDragElement) {\n        multiDragElement.sortableIndex = index(multiDragElement);\n      }); // Sort multi-drag elements\n\n      multiDragElements = multiDragElements.sort(function (a, b) {\n        return a.sortableIndex - b.sortableIndex;\n      });\n      dragStarted = true;\n    },\n    dragStarted: function dragStarted(_ref7) {\n      var _this2 = this;\n\n      var sortable = _ref7.sortable;\n      if (!this.isMultiDrag) return;\n\n      if (this.options.sort) {\n        // Capture rects,\n        // hide multi drag elements (by positioning them absolute),\n        // set multi drag elements rects to dragRect,\n        // show multi drag elements,\n        // animate to rects,\n        // unset rects & remove from DOM\n        sortable.captureAnimationState();\n\n        if (this.options.animation) {\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            css(multiDragElement, 'position', 'absolute');\n          });\n          var dragRect = getRect(dragEl$1, false, true, true);\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            setRect(multiDragElement, dragRect);\n          });\n          folding = true;\n          initialFolding = true;\n        }\n      }\n\n      sortable.animateAll(function () {\n        folding = false;\n        initialFolding = false;\n\n        if (_this2.options.animation) {\n          multiDragElements.forEach(function (multiDragElement) {\n            unsetRect(multiDragElement);\n          });\n        } // Remove all auxiliary multidrag items from el, if sorting enabled\n\n\n        if (_this2.options.sort) {\n          removeMultiDragElements();\n        }\n      });\n    },\n    dragOver: function dragOver(_ref8) {\n      var target = _ref8.target,\n          completed = _ref8.completed,\n          cancel = _ref8.cancel;\n\n      if (folding && ~multiDragElements.indexOf(target)) {\n        completed(false);\n        cancel();\n      }\n    },\n    revert: function revert(_ref9) {\n      var fromSortable = _ref9.fromSortable,\n          rootEl = _ref9.rootEl,\n          sortable = _ref9.sortable,\n          dragRect = _ref9.dragRect;\n\n      if (multiDragElements.length > 1) {\n        // Setup unfold animation\n        multiDragElements.forEach(function (multiDragElement) {\n          sortable.addAnimationState({\n            target: multiDragElement,\n            rect: folding ? getRect(multiDragElement) : dragRect\n          });\n          unsetRect(multiDragElement);\n          multiDragElement.fromRect = dragRect;\n          fromSortable.removeAnimationState(multiDragElement);\n        });\n        folding = false;\n        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);\n      }\n    },\n    dragOverCompleted: function dragOverCompleted(_ref10) {\n      var sortable = _ref10.sortable,\n          isOwner = _ref10.isOwner,\n          insertion = _ref10.insertion,\n          activeSortable = _ref10.activeSortable,\n          parentEl = _ref10.parentEl,\n          putSortable = _ref10.putSortable;\n      var options = this.options;\n\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        }\n\n        initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location\n\n        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {\n          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible\n          var dragRectAbsolute = getRect(dragEl$1, false, true, true);\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted\n            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable\n\n            parentEl.appendChild(multiDragElement);\n          });\n          folding = true;\n        } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out\n\n\n        if (!isOwner) {\n          // Only remove if not folding (folding will remove them anyways)\n          if (!folding) {\n            removeMultiDragElements();\n          }\n\n          if (multiDragElements.length > 1) {\n            var clonesHiddenBefore = clonesHidden;\n\n            activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden\n\n\n            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {\n              multiDragClones.forEach(function (clone) {\n                activeSortable.addAnimationState({\n                  target: clone,\n                  rect: clonesFromRect\n                });\n                clone.fromRect = clonesFromRect;\n                clone.thisAnimationDuration = null;\n              });\n            }\n          } else {\n            activeSortable._showClone(sortable);\n          }\n        }\n      }\n    },\n    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {\n      var dragRect = _ref11.dragRect,\n          isOwner = _ref11.isOwner,\n          activeSortable = _ref11.activeSortable;\n      multiDragElements.forEach(function (multiDragElement) {\n        multiDragElement.thisAnimationDuration = null;\n      });\n\n      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {\n        clonesFromRect = _extends({}, dragRect);\n        var dragMatrix = matrix(dragEl$1, true);\n        clonesFromRect.top -= dragMatrix.f;\n        clonesFromRect.left -= dragMatrix.e;\n      }\n    },\n    dragOverAnimationComplete: function dragOverAnimationComplete() {\n      if (folding) {\n        folding = false;\n        removeMultiDragElements();\n      }\n    },\n    drop: function drop(_ref12) {\n      var evt = _ref12.originalEvent,\n          rootEl = _ref12.rootEl,\n          parentEl = _ref12.parentEl,\n          sortable = _ref12.sortable,\n          dispatchSortableEvent = _ref12.dispatchSortableEvent,\n          oldIndex = _ref12.oldIndex,\n          putSortable = _ref12.putSortable;\n      var toSortable = putSortable || this.sortable;\n      if (!evt) return;\n      var options = this.options,\n          children = parentEl.children; // Multi-drag selection\n\n      if (!dragStarted) {\n        if (options.multiDragKey && !this.multiDragKeyDown) {\n          this._deselectMultiDrag();\n        }\n\n        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));\n\n        if (!~multiDragElements.indexOf(dragEl$1)) {\n          multiDragElements.push(dragEl$1);\n          dispatchEvent({\n            sortable: sortable,\n            rootEl: rootEl,\n            name: 'select',\n            targetEl: dragEl$1,\n            originalEvt: evt\n          }); // Modifier activated, select from last to dragEl\n\n          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {\n            var lastIndex = index(lastMultiDragSelect),\n                currentIndex = index(dragEl$1);\n\n            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {\n              // Must include lastMultiDragSelect (select it), in case modified selection from no selection\n              // (but previous selection existed)\n              var n, i;\n\n              if (currentIndex > lastIndex) {\n                i = lastIndex;\n                n = currentIndex;\n              } else {\n                i = currentIndex;\n                n = lastIndex + 1;\n              }\n\n              for (; i < n; i++) {\n                if (~multiDragElements.indexOf(children[i])) continue;\n                toggleClass(children[i], options.selectedClass, true);\n                multiDragElements.push(children[i]);\n                dispatchEvent({\n                  sortable: sortable,\n                  rootEl: rootEl,\n                  name: 'select',\n                  targetEl: children[i],\n                  originalEvt: evt\n                });\n              }\n            }\n          } else {\n            lastMultiDragSelect = dragEl$1;\n          }\n\n          multiDragSortable = toSortable;\n        } else {\n          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);\n          lastMultiDragSelect = null;\n          dispatchEvent({\n            sortable: sortable,\n            rootEl: rootEl,\n            name: 'deselect',\n            targetEl: dragEl$1,\n            originalEvt: evt\n          });\n        }\n      } // Multi-drag drop\n\n\n      if (dragStarted && this.isMultiDrag) {\n        // Do not \"unfold\" after around dragEl if reverted\n        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {\n          var dragRect = getRect(dragEl$1),\n              multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');\n          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;\n          toSortable.captureAnimationState();\n\n          if (!initialFolding) {\n            if (options.animation) {\n              dragEl$1.fromRect = dragRect;\n              multiDragElements.forEach(function (multiDragElement) {\n                multiDragElement.thisAnimationDuration = null;\n\n                if (multiDragElement !== dragEl$1) {\n                  var rect = folding ? getRect(multiDragElement) : dragRect;\n                  multiDragElement.fromRect = rect; // Prepare unfold animation\n\n                  toSortable.addAnimationState({\n                    target: multiDragElement,\n                    rect: rect\n                  });\n                }\n              });\n            } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert\n            // properly they must all be removed\n\n\n            removeMultiDragElements();\n            multiDragElements.forEach(function (multiDragElement) {\n              if (children[multiDragIndex]) {\n                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);\n              } else {\n                parentEl.appendChild(multiDragElement);\n              }\n\n              multiDragIndex++;\n            }); // If initial folding is done, the elements may have changed position because they are now\n            // unfolding around dragEl, even though dragEl may not have his index changed, so update event\n            // must be fired here as Sortable will not.\n\n            if (oldIndex === index(dragEl$1)) {\n              var update = false;\n              multiDragElements.forEach(function (multiDragElement) {\n                if (multiDragElement.sortableIndex !== index(multiDragElement)) {\n                  update = true;\n                  return;\n                }\n              });\n\n              if (update) {\n                dispatchSortableEvent('update');\n              }\n            }\n          } // Must be done after capturing individual rects (scroll bar)\n\n\n          multiDragElements.forEach(function (multiDragElement) {\n            unsetRect(multiDragElement);\n          });\n          toSortable.animateAll();\n        }\n\n        multiDragSortable = toSortable;\n      } // Remove clones if necessary\n\n\n      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n        multiDragClones.forEach(function (clone) {\n          clone.parentNode && clone.parentNode.removeChild(clone);\n        });\n      }\n    },\n    nullingGlobal: function nullingGlobal() {\n      this.isMultiDrag = dragStarted = false;\n      multiDragClones.length = 0;\n    },\n    destroyGlobal: function destroyGlobal() {\n      this._deselectMultiDrag();\n\n      off(document, 'pointerup', this._deselectMultiDrag);\n      off(document, 'mouseup', this._deselectMultiDrag);\n      off(document, 'touchend', this._deselectMultiDrag);\n      off(document, 'keydown', this._checkKeyDown);\n      off(document, 'keyup', this._checkKeyUp);\n    },\n    _deselectMultiDrag: function _deselectMultiDrag(evt) {\n      if (typeof dragStarted !== \"undefined\" && dragStarted) return; // Only deselect if selection is in this sortable\n\n      if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable\n\n      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click\n\n      if (evt && evt.button !== 0) return;\n\n      while (multiDragElements.length) {\n        var el = multiDragElements[0];\n        toggleClass(el, this.options.selectedClass, false);\n        multiDragElements.shift();\n        dispatchEvent({\n          sortable: this.sortable,\n          rootEl: this.sortable.el,\n          name: 'deselect',\n          targetEl: el,\n          originalEvt: evt\n        });\n      }\n    },\n    _checkKeyDown: function _checkKeyDown(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = true;\n      }\n    },\n    _checkKeyUp: function _checkKeyUp(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = false;\n      }\n    }\n  };\n  return _extends(MultiDrag, {\n    // Static methods & properties\n    pluginName: 'multiDrag',\n    utils: {\n      /**\r\n       * Selects the provided multi-drag item\r\n       * @param  {HTMLElement} el    The element to be selected\r\n       */\n      select: function select(el) {\n        var sortable = el.parentNode[expando];\n        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;\n\n        if (multiDragSortable && multiDragSortable !== sortable) {\n          multiDragSortable.multiDrag._deselectMultiDrag();\n\n          multiDragSortable = sortable;\n        }\n\n        toggleClass(el, sortable.options.selectedClass, true);\n        multiDragElements.push(el);\n      },\n\n      /**\r\n       * Deselects the provided multi-drag item\r\n       * @param  {HTMLElement} el    The element to be deselected\r\n       */\n      deselect: function deselect(el) {\n        var sortable = el.parentNode[expando],\n            index = multiDragElements.indexOf(el);\n        if (!sortable || !sortable.options.multiDrag || !~index) return;\n        toggleClass(el, sortable.options.selectedClass, false);\n        multiDragElements.splice(index, 1);\n      }\n    },\n    eventProperties: function eventProperties() {\n      var _this3 = this;\n\n      var oldIndicies = [],\n          newIndicies = [];\n      multiDragElements.forEach(function (multiDragElement) {\n        oldIndicies.push({\n          multiDragElement: multiDragElement,\n          index: multiDragElement.sortableIndex\n        }); // multiDragElements will already be sorted if folding\n\n        var newIndex;\n\n        if (folding && multiDragElement !== dragEl$1) {\n          newIndex = -1;\n        } else if (folding) {\n          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');\n        } else {\n          newIndex = index(multiDragElement);\n        }\n\n        newIndicies.push({\n          multiDragElement: multiDragElement,\n          index: newIndex\n        });\n      });\n      return {\n        items: _toConsumableArray(multiDragElements),\n        clones: [].concat(multiDragClones),\n        oldIndicies: oldIndicies,\n        newIndicies: newIndicies\n      };\n    },\n    optionListeners: {\n      multiDragKey: function multiDragKey(key) {\n        key = key.toLowerCase();\n\n        if (key === 'ctrl') {\n          key = 'Control';\n        } else if (key.length > 1) {\n          key = key.charAt(0).toUpperCase() + key.substr(1);\n        }\n\n        return key;\n      }\n    }\n  });\n}\n\nfunction insertMultiDragElements(clonesInserted, rootEl) {\n  multiDragElements.forEach(function (multiDragElement, i) {\n    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];\n\n    if (target) {\n      rootEl.insertBefore(multiDragElement, target);\n    } else {\n      rootEl.appendChild(multiDragElement);\n    }\n  });\n}\n/**\r\n * Insert multi-drag clones\r\n * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted\r\n * @param  {HTMLElement} rootEl\r\n */\n\n\nfunction insertMultiDragClones(elementsInserted, rootEl) {\n  multiDragClones.forEach(function (clone, i) {\n    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];\n\n    if (target) {\n      rootEl.insertBefore(clone, target);\n    } else {\n      rootEl.appendChild(clone);\n    }\n  });\n}\n\nfunction removeMultiDragElements() {\n  multiDragElements.forEach(function (multiDragElement) {\n    if (multiDragElement === dragEl$1) return;\n    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);\n  });\n}\n\nSortable.mount(new AutoScrollPlugin());\nSortable.mount(Remove, Revert);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Sortable);\n\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../../node_modules/sortablejs/modular/sortable.esm.js?")},191:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : 0;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://gen-gutenberg/../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?")},890:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar isProduction = \"production\" === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    throw new Error(prefix + \": \" + (message || ''));\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (invariant);\n\n\n//# sourceURL=webpack://gen-gutenberg/../../../../../node_modules/tiny-invariant/dist/tiny-invariant.esm.js?")},804:e=>{"use strict";e.exports=React},609:e=>{"use strict";e.exports=jQuery}},__webpack_module_cache__={};function __webpack_require__(e){if(__webpack_module_cache__[e])return __webpack_module_cache__[e].exports;var t=__webpack_module_cache__[e]={id:e,exports:{}};return __webpack_modules__[e](t,t.exports,__webpack_require__),t.exports}__webpack_require__.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(t,{a:t}),t},__webpack_require__.d=(e,t)=>{for(var n in t)__webpack_require__.o(t,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(984)})();